//////////////////////////////////////////////////////////////////////////
//                                                                      //
// This is a generated file. You can view the original                  //
// source in your browser if your browser supports source maps.         //
// Source maps are supported by all recent versions of Chrome, Safari,  //
// and Firefox, and by Internet Explorer 11.                            //
//                                                                      //
//////////////////////////////////////////////////////////////////////////


(function () {

/* Imports */
var Meteor = Package.meteor.Meteor;
var check = Package.check.check;
var Match = Package.check.Match;
var Random = Package.random.Random;
var EJSON = Package.ejson.EJSON;
var _ = Package.underscore._;
var Tracker = Package.tracker.Tracker;
var Deps = Package.tracker.Deps;
var Retry = Package.retry.Retry;

/* Package-scope variables */
var DDPCommon, ProtoBuf, ByteBuffer, JSONproto;

(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/namespace.js                                                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/**                                                                                                                    // 1
 * @namespace DDPCommon                                                                                                // 2
 * @summary Namespace for DDPCommon-related methods/classes. Shared between                                            // 3
 * `ddp-client` and `ddp-server`, where the ddp-client is the implementation                                           // 4
 * of a ddp client for both client AND server; and the ddp server is the                                               // 5
 * implementation of the livedata server and stream server. Common                                                     // 6
 * functionality shared between both can be shared under this namespace                                                // 7
 */                                                                                                                    // 8
DDPCommon = {};                                                                                                        // 9
                                                                                                                       // 10
ProtoBuf = {};                                                                                                         // 11
                                                                                                                       // 12
ByteBuffer = {};                                                                                                       // 13
                                                                                                                       // 14
JSONproto = {};                                                                                                        // 15
                                                                                                                       // 16
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/bytebuffer.js                                                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*                                                                                                                     // 1
 Copyright 2013-2014 Daniel Wirtz <dcode@dcode.io>                                                                     // 2
                                                                                                                       // 3
 Licensed under the Apache License, Version 2.0 (the "License");                                                       // 4
 you may not use this file except in compliance with the License.                                                      // 5
 You may obtain a copy of the License at                                                                               // 6
                                                                                                                       // 7
 http://www.apache.org/licenses/LICENSE-2.0                                                                            // 8
                                                                                                                       // 9
 Unless required by applicable law or agreed to in writing, software                                                   // 10
 distributed under the License is distributed on an "AS IS" BASIS,                                                     // 11
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                                              // 12
 See the License for the specific language governing permissions and                                                   // 13
 limitations under the License.                                                                                        // 14
 */                                                                                                                    // 15
                                                                                                                       // 16
/**                                                                                                                    // 17
 * @license bytebuffer.js (c) 2015 Daniel Wirtz <dcode@dcode.io>                                                       // 18
 * Backing buffer: ArrayBuffer, Accessor: Uint8Array                                                                   // 19
 * Released under the Apache License, Version 2.0                                                                      // 20
 * see: https://github.com/dcodeIO/bytebuffer.js for details                                                           // 21
 */                                                                                                                    // 22
// (function(global, factory) {                                                                                        // 23
//                                                                                                                     // 24
//     /* AMD */ if (typeof define === 'function' && define["amd"])                                                    // 25
//         define(["long"], factory);                                                                                  // 26
//     /* CommonJS */ else if (typeof require === 'function' && typeof module === "object" && module && module["exports"])
//         module['exports'] = (function() {                                                                           // 28
//             var Long; try { Long = require("long"); } catch (e) {}                                                  // 29
//             return factory(Long);                                                                                   // 30
//         })();                                                                                                       // 31
//     /* Global */ else                                                                                               // 32
//         (global["dcodeIO"] = global["dcodeIO"] || {})["ByteBuffer"] = factory(global["dcodeIO"]["Long"]);           // 33
//                                                                                                                     // 34
// })(this, function(Long) {                                                                                           // 35
//     "use strict";                                                                                                   // 36
                                                                                                                       // 37
    /**                                                                                                                // 38
     * Constructs a new ByteBuffer.                                                                                    // 39
     * @class The swiss army knife for binary data in JavaScript.                                                      // 40
     * @exports ByteBuffer                                                                                             // 41
     * @constructor                                                                                                    // 42
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.                    // 43
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 44
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 45
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 46
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 47
     * @expose                                                                                                         // 48
     */                                                                                                                // 49
    ByteBuffer = function(capacity, littleEndian, noAssert) {                                                          // 50
        if (typeof capacity === 'undefined')                                                                           // 51
            capacity = ByteBuffer.DEFAULT_CAPACITY;                                                                    // 52
        if (typeof littleEndian === 'undefined')                                                                       // 53
            littleEndian = ByteBuffer.DEFAULT_ENDIAN;                                                                  // 54
        if (typeof noAssert === 'undefined')                                                                           // 55
            noAssert = ByteBuffer.DEFAULT_NOASSERT;                                                                    // 56
        if (!noAssert) {                                                                                               // 57
            capacity = capacity | 0;                                                                                   // 58
            if (capacity < 0)                                                                                          // 59
                throw RangeError("Illegal capacity");                                                                  // 60
            littleEndian = !!littleEndian;                                                                             // 61
            noAssert = !!noAssert;                                                                                     // 62
        }                                                                                                              // 63
                                                                                                                       // 64
        /**                                                                                                            // 65
         * Backing ArrayBuffer.                                                                                        // 66
         * @type {!ArrayBuffer}                                                                                        // 67
         * @expose                                                                                                     // 68
         */                                                                                                            // 69
        this.buffer = capacity === 0 ? EMPTY_BUFFER : new ArrayBuffer(capacity);                                       // 70
                                                                                                                       // 71
        /**                                                                                                            // 72
         * Uint8Array utilized to manipulate the backing buffer. Becomes `null` if the backing buffer has a capacity of `0`.
         * @type {?Uint8Array}                                                                                         // 74
         * @expose                                                                                                     // 75
         */                                                                                                            // 76
        this.view = capacity === 0 ? null : new Uint8Array(this.buffer);                                               // 77
                                                                                                                       // 78
        /**                                                                                                            // 79
         * Absolute read/write offset.                                                                                 // 80
         * @type {number}                                                                                              // 81
         * @expose                                                                                                     // 82
         * @see ByteBuffer#flip                                                                                        // 83
         * @see ByteBuffer#clear                                                                                       // 84
         */                                                                                                            // 85
        this.offset = 0;                                                                                               // 86
                                                                                                                       // 87
        /**                                                                                                            // 88
         * Marked offset.                                                                                              // 89
         * @type {number}                                                                                              // 90
         * @expose                                                                                                     // 91
         * @see ByteBuffer#mark                                                                                        // 92
         * @see ByteBuffer#reset                                                                                       // 93
         */                                                                                                            // 94
        this.markedOffset = -1;                                                                                        // 95
                                                                                                                       // 96
        /**                                                                                                            // 97
         * Absolute limit of the contained data. Set to the backing buffer's capacity upon allocation.                 // 98
         * @type {number}                                                                                              // 99
         * @expose                                                                                                     // 100
         * @see ByteBuffer#flip                                                                                        // 101
         * @see ByteBuffer#clear                                                                                       // 102
         */                                                                                                            // 103
        this.limit = capacity;                                                                                         // 104
                                                                                                                       // 105
        /**                                                                                                            // 106
         * Whether to use little endian byte order, defaults to `false` for big endian.                                // 107
         * @type {boolean}                                                                                             // 108
         * @expose                                                                                                     // 109
         */                                                                                                            // 110
        this.littleEndian = littleEndian;                                                                              // 111
                                                                                                                       // 112
        /**                                                                                                            // 113
         * Whether to skip assertions of offsets and values, defaults to `false`.                                      // 114
         * @type {boolean}                                                                                             // 115
         * @expose                                                                                                     // 116
         */                                                                                                            // 117
        this.noAssert = noAssert;                                                                                      // 118
    };                                                                                                                 // 119
                                                                                                                       // 120
    /**                                                                                                                // 121
     * ByteBuffer version.                                                                                             // 122
     * @type {string}                                                                                                  // 123
     * @const                                                                                                          // 124
     * @expose                                                                                                         // 125
     */                                                                                                                // 126
    ByteBuffer.VERSION = "5.0.1";                                                                                      // 127
                                                                                                                       // 128
    /**                                                                                                                // 129
     * Little endian constant that can be used instead of its boolean value. Evaluates to `true`.                      // 130
     * @type {boolean}                                                                                                 // 131
     * @const                                                                                                          // 132
     * @expose                                                                                                         // 133
     */                                                                                                                // 134
    ByteBuffer.LITTLE_ENDIAN = true;                                                                                   // 135
                                                                                                                       // 136
    /**                                                                                                                // 137
     * Big endian constant that can be used instead of its boolean value. Evaluates to `false`.                        // 138
     * @type {boolean}                                                                                                 // 139
     * @const                                                                                                          // 140
     * @expose                                                                                                         // 141
     */                                                                                                                // 142
    ByteBuffer.BIG_ENDIAN = false;                                                                                     // 143
                                                                                                                       // 144
    /**                                                                                                                // 145
     * Default initial capacity of `16`.                                                                               // 146
     * @type {number}                                                                                                  // 147
     * @expose                                                                                                         // 148
     */                                                                                                                // 149
    ByteBuffer.DEFAULT_CAPACITY = 16;                                                                                  // 150
                                                                                                                       // 151
    /**                                                                                                                // 152
     * Default endianess of `false` for big endian.                                                                    // 153
     * @type {boolean}                                                                                                 // 154
     * @expose                                                                                                         // 155
     */                                                                                                                // 156
    ByteBuffer.DEFAULT_ENDIAN = ByteBuffer.BIG_ENDIAN;                                                                 // 157
                                                                                                                       // 158
    /**                                                                                                                // 159
     * Default no assertions flag of `false`.                                                                          // 160
     * @type {boolean}                                                                                                 // 161
     * @expose                                                                                                         // 162
     */                                                                                                                // 163
    ByteBuffer.DEFAULT_NOASSERT = false;                                                                               // 164
                                                                                                                       // 165
    /**                                                                                                                // 166
     * A `Long` class for representing a 64-bit two's-complement integer value. May be `null` if Long.js has not been loaded
     *  and int64 support is not available.                                                                            // 168
     * @type {?Long}                                                                                                   // 169
     * @const                                                                                                          // 170
     * @see https://github.com/dcodeIO/long.js                                                                         // 171
     * @expose                                                                                                         // 172
     */                                                                                                                // 173
    var Long = null;                                                                                                   // 174
                                                                                                                       // 175
    ByteBuffer.Long = Long || null;                                                                                    // 176
                                                                                                                       // 177
    /**                                                                                                                // 178
     * @alias ByteBuffer.prototype                                                                                     // 179
     * @inner                                                                                                          // 180
     */                                                                                                                // 181
    var ByteBufferPrototype = ByteBuffer.prototype;                                                                    // 182
                                                                                                                       // 183
    /**                                                                                                                // 184
     * An indicator used to reliably determine if an object is a ByteBuffer or not.                                    // 185
     * @type {boolean}                                                                                                 // 186
     * @const                                                                                                          // 187
     * @expose                                                                                                         // 188
     * @private                                                                                                        // 189
     */                                                                                                                // 190
    ByteBufferPrototype.__isByteBuffer__;                                                                              // 191
                                                                                                                       // 192
    Object.defineProperty(ByteBufferPrototype, "__isByteBuffer__", {                                                   // 193
        value: true,                                                                                                   // 194
        enumerable: false,                                                                                             // 195
        configurable: false                                                                                            // 196
    });                                                                                                                // 197
                                                                                                                       // 198
    // helpers                                                                                                         // 199
                                                                                                                       // 200
    /**                                                                                                                // 201
     * @type {!ArrayBuffer}                                                                                            // 202
     * @inner                                                                                                          // 203
     */                                                                                                                // 204
    var EMPTY_BUFFER = new ArrayBuffer(0);                                                                             // 205
                                                                                                                       // 206
    /**                                                                                                                // 207
     * String.fromCharCode reference for compile-time renaming.                                                        // 208
     * @type {function(...number):string}                                                                              // 209
     * @inner                                                                                                          // 210
     */                                                                                                                // 211
    var stringFromCharCode = String.fromCharCode;                                                                      // 212
                                                                                                                       // 213
    /**                                                                                                                // 214
     * Creates a source function for a string.                                                                         // 215
     * @param {string} s String to read from                                                                           // 216
     * @returns {function():number|null} Source function returning the next char code respectively `null` if there are
     *  no more characters left.                                                                                       // 218
     * @throws {TypeError} If the argument is invalid                                                                  // 219
     * @inner                                                                                                          // 220
     */                                                                                                                // 221
    function stringSource(s) {                                                                                         // 222
        var i=0; return function() {                                                                                   // 223
            return i < s.length ? s.charCodeAt(i++) : null;                                                            // 224
        };                                                                                                             // 225
    }                                                                                                                  // 226
                                                                                                                       // 227
    /**                                                                                                                // 228
     * Creates a destination function for a string.                                                                    // 229
     * @returns {function(number=):undefined|string} Destination function successively called with the next char code.
     *  Returns the final string when called without arguments.                                                        // 231
     * @inner                                                                                                          // 232
     */                                                                                                                // 233
    function stringDestination() {                                                                                     // 234
        var cs = [], ps = []; return function() {                                                                      // 235
            if (arguments.length === 0)                                                                                // 236
                return ps.join('')+stringFromCharCode.apply(String, cs);                                               // 237
            if (cs.length + arguments.length > 1024)                                                                   // 238
                ps.push(stringFromCharCode.apply(String, cs)),                                                         // 239
                    cs.length = 0;                                                                                     // 240
            Array.prototype.push.apply(cs, arguments);                                                                 // 241
        };                                                                                                             // 242
    }                                                                                                                  // 243
                                                                                                                       // 244
    /**                                                                                                                // 245
     * Gets the accessor type.                                                                                         // 246
     * @returns {Function} `Buffer` under node.js, `Uint8Array` respectively `DataView` in the browser (classes)       // 247
     * @expose                                                                                                         // 248
     */                                                                                                                // 249
    ByteBuffer.accessor = function() {                                                                                 // 250
        return Uint8Array;                                                                                             // 251
    };                                                                                                                 // 252
    /**                                                                                                                // 253
     * Allocates a new ByteBuffer backed by a buffer of the specified capacity.                                        // 254
     * @param {number=} capacity Initial capacity. Defaults to {@link ByteBuffer.DEFAULT_CAPACITY}.                    // 255
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 256
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 257
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 258
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 259
     * @returns {!ByteBuffer}                                                                                          // 260
     * @expose                                                                                                         // 261
     */                                                                                                                // 262
    ByteBuffer.allocate = function(capacity, littleEndian, noAssert) {                                                 // 263
        return new ByteBuffer(capacity, littleEndian, noAssert);                                                       // 264
    };                                                                                                                 // 265
                                                                                                                       // 266
    /**                                                                                                                // 267
     * Concatenates multiple ByteBuffers into one.                                                                     // 268
     * @param {!Array.<!ByteBuffer|!ArrayBuffer|!Uint8Array|string>} buffers Buffers to concatenate                    // 269
     * @param {(string|boolean)=} encoding String encoding if `buffers` contains a string ("base64", "hex", "binary",  // 270
     *  defaults to "utf8")                                                                                            // 271
     * @param {boolean=} littleEndian Whether to use little or big endian byte order for the resulting ByteBuffer. Defaults
     *  to {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                          // 273
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values for the resulting ByteBuffer. Defaults to
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 275
     * @returns {!ByteBuffer} Concatenated ByteBuffer                                                                  // 276
     * @expose                                                                                                         // 277
     */                                                                                                                // 278
    ByteBuffer.concat = function(buffers, encoding, littleEndian, noAssert) {                                          // 279
        if (typeof encoding === 'boolean' || typeof encoding !== 'string') {                                           // 280
            noAssert = littleEndian;                                                                                   // 281
            littleEndian = encoding;                                                                                   // 282
            encoding = undefined;                                                                                      // 283
        }                                                                                                              // 284
        var capacity = 0;                                                                                              // 285
        for (var i=0, k=buffers.length, length; i<k; ++i) {                                                            // 286
            if (!ByteBuffer.isByteBuffer(buffers[i]))                                                                  // 287
                buffers[i] = ByteBuffer.wrap(buffers[i], encoding);                                                    // 288
            length = buffers[i].limit - buffers[i].offset;                                                             // 289
            if (length > 0) capacity += length;                                                                        // 290
        }                                                                                                              // 291
        if (capacity === 0)                                                                                            // 292
            return new ByteBuffer(0, littleEndian, noAssert);                                                          // 293
        var bb = new ByteBuffer(capacity, littleEndian, noAssert),                                                     // 294
            bi;                                                                                                        // 295
        i=0; while (i<k) {                                                                                             // 296
            bi = buffers[i++];                                                                                         // 297
            length = bi.limit - bi.offset;                                                                             // 298
            if (length <= 0) continue;                                                                                 // 299
            bb.view.set(bi.view.subarray(bi.offset, bi.limit), bb.offset);                                             // 300
            bb.offset += length;                                                                                       // 301
        }                                                                                                              // 302
        bb.limit = bb.offset;                                                                                          // 303
        bb.offset = 0;                                                                                                 // 304
        return bb;                                                                                                     // 305
    };                                                                                                                 // 306
                                                                                                                       // 307
    /**                                                                                                                // 308
     * Tests if the specified type is a ByteBuffer.                                                                    // 309
     * @param {*} bb ByteBuffer to test                                                                                // 310
     * @returns {boolean} `true` if it is a ByteBuffer, otherwise `false`                                              // 311
     * @expose                                                                                                         // 312
     */                                                                                                                // 313
    ByteBuffer.isByteBuffer = function(bb) {                                                                           // 314
        return (bb && bb["__isByteBuffer__"]) === true;                                                                // 315
    };                                                                                                                 // 316
    /**                                                                                                                // 317
     * Gets the backing buffer type.                                                                                   // 318
     * @returns {Function} `Buffer` under node.js, `ArrayBuffer` in the browser (classes)                              // 319
     * @expose                                                                                                         // 320
     */                                                                                                                // 321
    ByteBuffer.type = function() {                                                                                     // 322
        return ArrayBuffer;                                                                                            // 323
    };                                                                                                                 // 324
    /**                                                                                                                // 325
     * Wraps a buffer or a string. Sets the allocated ByteBuffer's {@link ByteBuffer#offset} to `0` and its            // 326
     *  {@link ByteBuffer#limit} to the length of the wrapped data.                                                    // 327
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string|!Array.<number>} buffer Anything that can be wrapped        // 328
     * @param {(string|boolean)=} encoding String encoding if `buffer` is a string ("base64", "hex", "binary", defaults to
     *  "utf8")                                                                                                        // 330
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 331
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 332
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 333
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 334
     * @returns {!ByteBuffer} A ByteBuffer wrapping `buffer`                                                           // 335
     * @expose                                                                                                         // 336
     */                                                                                                                // 337
    ByteBuffer.wrap = function(buffer, encoding, littleEndian, noAssert) {                                             // 338
        if (typeof encoding !== 'string') {                                                                            // 339
            noAssert = littleEndian;                                                                                   // 340
            littleEndian = encoding;                                                                                   // 341
            encoding = undefined;                                                                                      // 342
        }                                                                                                              // 343
        if (typeof buffer === 'string') {                                                                              // 344
            if (typeof encoding === 'undefined')                                                                       // 345
                encoding = "utf8";                                                                                     // 346
            switch (encoding) {                                                                                        // 347
                case "base64":                                                                                         // 348
                    return ByteBuffer.fromBase64(buffer, littleEndian);                                                // 349
                case "hex":                                                                                            // 350
                    return ByteBuffer.fromHex(buffer, littleEndian);                                                   // 351
                case "binary":                                                                                         // 352
                    return ByteBuffer.fromBinary(buffer, littleEndian);                                                // 353
                case "utf8":                                                                                           // 354
                    return ByteBuffer.fromUTF8(buffer, littleEndian);                                                  // 355
                case "debug":                                                                                          // 356
                    return ByteBuffer.fromDebug(buffer, littleEndian);                                                 // 357
                default:                                                                                               // 358
                    throw Error("Unsupported encoding: "+encoding);                                                    // 359
            }                                                                                                          // 360
        }                                                                                                              // 361
        if (buffer === null || typeof buffer !== 'object')                                                             // 362
            throw TypeError("Illegal buffer");                                                                         // 363
        var bb;                                                                                                        // 364
        if (ByteBuffer.isByteBuffer(buffer)) {                                                                         // 365
            bb = ByteBufferPrototype.clone.call(buffer);                                                               // 366
            bb.markedOffset = -1;                                                                                      // 367
            return bb;                                                                                                 // 368
        }                                                                                                              // 369
        if (buffer instanceof Uint8Array) { // Extract ArrayBuffer from Uint8Array                                     // 370
            bb = new ByteBuffer(0, littleEndian, noAssert);                                                            // 371
            if (buffer.length > 0) { // Avoid references to more than one EMPTY_BUFFER                                 // 372
                bb.buffer = buffer.buffer;                                                                             // 373
                bb.offset = buffer.byteOffset;                                                                         // 374
                bb.limit = buffer.byteOffset + buffer.byteLength;                                                      // 375
                bb.view = new Uint8Array(buffer.buffer);                                                               // 376
            }                                                                                                          // 377
        } else if (buffer instanceof ArrayBuffer) { // Reuse ArrayBuffer                                               // 378
            bb = new ByteBuffer(0, littleEndian, noAssert);                                                            // 379
            if (buffer.byteLength > 0) {                                                                               // 380
                bb.buffer = buffer;                                                                                    // 381
                bb.offset = 0;                                                                                         // 382
                bb.limit = buffer.byteLength;                                                                          // 383
                bb.view = buffer.byteLength > 0 ? new Uint8Array(buffer) : null;                                       // 384
            }                                                                                                          // 385
        } else if (Object.prototype.toString.call(buffer) === "[object Array]") { // Create from octets                // 386
            bb = new ByteBuffer(buffer.length, littleEndian, noAssert);                                                // 387
            bb.limit = buffer.length;                                                                                  // 388
            for (var i=0; i<buffer.length; ++i)                                                                        // 389
                bb.view[i] = buffer[i];                                                                                // 390
        } else                                                                                                         // 391
            throw TypeError("Illegal buffer"); // Otherwise fail                                                       // 392
        return bb;                                                                                                     // 393
    };                                                                                                                 // 394
                                                                                                                       // 395
    /**                                                                                                                // 396
     * Writes the array as a bitset.                                                                                   // 397
     * @param {Array<boolean>} value Array of booleans to write                                                        // 398
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}                                                                                          // 400
     * @expose                                                                                                         // 401
     */                                                                                                                // 402
    ByteBufferPrototype.writeBitSet = function(value, offset) {                                                        // 403
      var relative = typeof offset === 'undefined';                                                                    // 404
      if (relative) offset = this.offset;                                                                              // 405
      if (!this.noAssert) {                                                                                            // 406
        if (!(value instanceof Array))                                                                                 // 407
          throw TypeError("Illegal BitSet: Not an array");                                                             // 408
        if (typeof offset !== 'number' || offset % 1 !== 0)                                                            // 409
            throw TypeError("Illegal offset: "+offset+" (not an integer)");                                            // 410
        offset >>>= 0;                                                                                                 // 411
        if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                         // 412
            throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);                   // 413
      }                                                                                                                // 414
                                                                                                                       // 415
      var start = offset,                                                                                              // 416
          bits = value.length,                                                                                         // 417
          bytes = (bits >> 3),                                                                                         // 418
          bit = 0,                                                                                                     // 419
          k;                                                                                                           // 420
                                                                                                                       // 421
      offset += this.writeVarint32(bits,offset);                                                                       // 422
                                                                                                                       // 423
      while(bytes--) {                                                                                                 // 424
        k = (!!value[bit++] & 1) |                                                                                     // 425
            ((!!value[bit++] & 1) << 1) |                                                                              // 426
            ((!!value[bit++] & 1) << 2) |                                                                              // 427
            ((!!value[bit++] & 1) << 3) |                                                                              // 428
            ((!!value[bit++] & 1) << 4) |                                                                              // 429
            ((!!value[bit++] & 1) << 5) |                                                                              // 430
            ((!!value[bit++] & 1) << 6) |                                                                              // 431
            ((!!value[bit++] & 1) << 7);                                                                               // 432
        this.writeByte(k,offset++);                                                                                    // 433
      }                                                                                                                // 434
                                                                                                                       // 435
      if(bit < bits) {                                                                                                 // 436
        var m = 0; k = 0;                                                                                              // 437
        while(bit < bits) k = k | ((!!value[bit++] & 1) << (m++));                                                     // 438
        this.writeByte(k,offset++);                                                                                    // 439
      }                                                                                                                // 440
                                                                                                                       // 441
      if (relative) {                                                                                                  // 442
        this.offset = offset;                                                                                          // 443
        return this;                                                                                                   // 444
      }                                                                                                                // 445
      return offset - start;                                                                                           // 446
    }                                                                                                                  // 447
                                                                                                                       // 448
    /**                                                                                                                // 449
     * Reads a BitSet as an array of booleans.                                                                         // 450
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {Array<boolean>                                                                                        // 452
     * @expose                                                                                                         // 453
     */                                                                                                                // 454
    ByteBufferPrototype.readBitSet = function(offset) {                                                                // 455
      var relative = typeof offset === 'undefined';                                                                    // 456
      if (relative) offset = this.offset;                                                                              // 457
                                                                                                                       // 458
      var ret = this.readVarint32(offset),                                                                             // 459
          bits = ret.value,                                                                                            // 460
          bytes = (bits >> 3),                                                                                         // 461
          bit = 0,                                                                                                     // 462
          value = [],                                                                                                  // 463
          k;                                                                                                           // 464
                                                                                                                       // 465
      offset += ret.length;                                                                                            // 466
                                                                                                                       // 467
      while(bytes--) {                                                                                                 // 468
        k = this.readByte(offset++);                                                                                   // 469
        value[bit++] = !!(k & 0x01);                                                                                   // 470
        value[bit++] = !!(k & 0x02);                                                                                   // 471
        value[bit++] = !!(k & 0x04);                                                                                   // 472
        value[bit++] = !!(k & 0x08);                                                                                   // 473
        value[bit++] = !!(k & 0x10);                                                                                   // 474
        value[bit++] = !!(k & 0x20);                                                                                   // 475
        value[bit++] = !!(k & 0x40);                                                                                   // 476
        value[bit++] = !!(k & 0x80);                                                                                   // 477
      }                                                                                                                // 478
                                                                                                                       // 479
      if(bit < bits) {                                                                                                 // 480
        var m = 0;                                                                                                     // 481
        k = this.readByte(offset++);                                                                                   // 482
        while(bit < bits) value[bit++] = !!((k >> (m++)) & 1);                                                         // 483
      }                                                                                                                // 484
                                                                                                                       // 485
      if (relative) {                                                                                                  // 486
        this.offset = offset;                                                                                          // 487
      }                                                                                                                // 488
      return value;                                                                                                    // 489
    }                                                                                                                  // 490
    /**                                                                                                                // 491
     * Reads the specified number of bytes.                                                                            // 492
     * @param {number} length Number of bytes to read                                                                  // 493
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `length` if omitted.
     * @returns {!ByteBuffer}                                                                                          // 495
     * @expose                                                                                                         // 496
     */                                                                                                                // 497
    ByteBufferPrototype.readBytes = function(length, offset) {                                                         // 498
        var relative = typeof offset === 'undefined';                                                                  // 499
        if (relative) offset = this.offset;                                                                            // 500
        if (!this.noAssert) {                                                                                          // 501
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 502
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 503
            offset >>>= 0;                                                                                             // 504
            if (offset < 0 || offset + length > this.buffer.byteLength)                                                // 505
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);          // 506
        }                                                                                                              // 507
        var slice = this.slice(offset, offset + length);                                                               // 508
        if (relative) this.offset += length;                                                                           // 509
        return slice;                                                                                                  // 510
    };                                                                                                                 // 511
                                                                                                                       // 512
    /**                                                                                                                // 513
     * Writes a payload of bytes. This is an alias of {@link ByteBuffer#append}.                                       // 514
     * @function                                                                                                       // 515
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to write. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.                                                    // 517
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 520
     * @returns {!ByteBuffer} this                                                                                     // 521
     * @expose                                                                                                         // 522
     */                                                                                                                // 523
    ByteBufferPrototype.writeBytes = ByteBufferPrototype.append;                                                       // 524
                                                                                                                       // 525
    // types/ints/int8                                                                                                 // 526
                                                                                                                       // 527
    /**                                                                                                                // 528
     * Writes an 8bit signed integer.                                                                                  // 529
     * @param {number} value Value to write                                                                            // 530
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.   // 531
     * @returns {!ByteBuffer} this                                                                                     // 532
     * @expose                                                                                                         // 533
     */                                                                                                                // 534
    ByteBufferPrototype.writeInt8 = function(value, offset) {                                                          // 535
        var relative = typeof offset === 'undefined';                                                                  // 536
        if (relative) offset = this.offset;                                                                            // 537
        if (!this.noAssert) {                                                                                          // 538
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 539
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 540
            value |= 0;                                                                                                // 541
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 542
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 543
            offset >>>= 0;                                                                                             // 544
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 545
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 546
        }                                                                                                              // 547
        offset += 1;                                                                                                   // 548
        var capacity0 = this.buffer.byteLength;                                                                        // 549
        if (offset > capacity0)                                                                                        // 550
            this.resize((capacity0 *= 2) > offset ? capacity0 : offset);                                               // 551
        offset -= 1;                                                                                                   // 552
        this.view[offset] = value;                                                                                     // 553
        if (relative) this.offset += 1;                                                                                // 554
        return this;                                                                                                   // 555
    };                                                                                                                 // 556
                                                                                                                       // 557
    /**                                                                                                                // 558
     * Writes an 8bit signed integer. This is an alias of {@link ByteBuffer#writeInt8}.                                // 559
     * @function                                                                                                       // 560
     * @param {number} value Value to write                                                                            // 561
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.   // 562
     * @returns {!ByteBuffer} this                                                                                     // 563
     * @expose                                                                                                         // 564
     */                                                                                                                // 565
    ByteBufferPrototype.writeByte = ByteBufferPrototype.writeInt8;                                                     // 566
                                                                                                                       // 567
    /**                                                                                                                // 568
     * Reads an 8bit signed integer.                                                                                   // 569
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.  // 570
     * @returns {number} Value read                                                                                    // 571
     * @expose                                                                                                         // 572
     */                                                                                                                // 573
    ByteBufferPrototype.readInt8 = function(offset) {                                                                  // 574
        var relative = typeof offset === 'undefined';                                                                  // 575
        if (relative) offset = this.offset;                                                                            // 576
        if (!this.noAssert) {                                                                                          // 577
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 578
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 579
            offset >>>= 0;                                                                                             // 580
            if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                     // 581
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);               // 582
        }                                                                                                              // 583
        var value = this.view[offset];                                                                                 // 584
        if ((value & 0x80) === 0x80) value = -(0xFF - value + 1); // Cast to signed                                    // 585
        if (relative) this.offset += 1;                                                                                // 586
        return value;                                                                                                  // 587
    };                                                                                                                 // 588
                                                                                                                       // 589
    /**                                                                                                                // 590
     * Reads an 8bit signed integer. This is an alias of {@link ByteBuffer#readInt8}.                                  // 591
     * @function                                                                                                       // 592
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.  // 593
     * @returns {number} Value read                                                                                    // 594
     * @expose                                                                                                         // 595
     */                                                                                                                // 596
    ByteBufferPrototype.readByte = ByteBufferPrototype.readInt8;                                                       // 597
                                                                                                                       // 598
    /**                                                                                                                // 599
     * Writes an 8bit unsigned integer.                                                                                // 600
     * @param {number} value Value to write                                                                            // 601
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.   // 602
     * @returns {!ByteBuffer} this                                                                                     // 603
     * @expose                                                                                                         // 604
     */                                                                                                                // 605
    ByteBufferPrototype.writeUint8 = function(value, offset) {                                                         // 606
        var relative = typeof offset === 'undefined';                                                                  // 607
        if (relative) offset = this.offset;                                                                            // 608
        if (!this.noAssert) {                                                                                          // 609
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 610
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 611
            value >>>= 0;                                                                                              // 612
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 613
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 614
            offset >>>= 0;                                                                                             // 615
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 616
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 617
        }                                                                                                              // 618
        offset += 1;                                                                                                   // 619
        var capacity1 = this.buffer.byteLength;                                                                        // 620
        if (offset > capacity1)                                                                                        // 621
            this.resize((capacity1 *= 2) > offset ? capacity1 : offset);                                               // 622
        offset -= 1;                                                                                                   // 623
        this.view[offset] = value;                                                                                     // 624
        if (relative) this.offset += 1;                                                                                // 625
        return this;                                                                                                   // 626
    };                                                                                                                 // 627
                                                                                                                       // 628
    /**                                                                                                                // 629
     * Writes an 8bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint8}.                             // 630
     * @function                                                                                                       // 631
     * @param {number} value Value to write                                                                            // 632
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.   // 633
     * @returns {!ByteBuffer} this                                                                                     // 634
     * @expose                                                                                                         // 635
     */                                                                                                                // 636
    ByteBufferPrototype.writeUInt8 = ByteBufferPrototype.writeUint8;                                                   // 637
                                                                                                                       // 638
    /**                                                                                                                // 639
     * Reads an 8bit unsigned integer.                                                                                 // 640
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.  // 641
     * @returns {number} Value read                                                                                    // 642
     * @expose                                                                                                         // 643
     */                                                                                                                // 644
    ByteBufferPrototype.readUint8 = function(offset) {                                                                 // 645
        var relative = typeof offset === 'undefined';                                                                  // 646
        if (relative) offset = this.offset;                                                                            // 647
        if (!this.noAssert) {                                                                                          // 648
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 649
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 650
            offset >>>= 0;                                                                                             // 651
            if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                     // 652
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);               // 653
        }                                                                                                              // 654
        var value = this.view[offset];                                                                                 // 655
        if (relative) this.offset += 1;                                                                                // 656
        return value;                                                                                                  // 657
    };                                                                                                                 // 658
                                                                                                                       // 659
    /**                                                                                                                // 660
     * Reads an 8bit unsigned integer. This is an alias of {@link ByteBuffer#readUint8}.                               // 661
     * @function                                                                                                       // 662
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `1` if omitted.  // 663
     * @returns {number} Value read                                                                                    // 664
     * @expose                                                                                                         // 665
     */                                                                                                                // 666
    ByteBufferPrototype.readUInt8 = ByteBufferPrototype.readUint8;                                                     // 667
                                                                                                                       // 668
    // types/ints/int16                                                                                                // 669
                                                                                                                       // 670
    /**                                                                                                                // 671
     * Writes a 16bit signed integer.                                                                                  // 672
     * @param {number} value Value to write                                                                            // 673
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.   // 674
     * @throws {TypeError} If `offset` or `value` is not a valid number                                                // 675
     * @throws {RangeError} If `offset` is out of bounds                                                               // 676
     * @expose                                                                                                         // 677
     */                                                                                                                // 678
    ByteBufferPrototype.writeInt16 = function(value, offset) {                                                         // 679
        var relative = typeof offset === 'undefined';                                                                  // 680
        if (relative) offset = this.offset;                                                                            // 681
        if (!this.noAssert) {                                                                                          // 682
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 683
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 684
            value |= 0;                                                                                                // 685
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 686
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 687
            offset >>>= 0;                                                                                             // 688
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 689
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 690
        }                                                                                                              // 691
        offset += 2;                                                                                                   // 692
        var capacity2 = this.buffer.byteLength;                                                                        // 693
        if (offset > capacity2)                                                                                        // 694
            this.resize((capacity2 *= 2) > offset ? capacity2 : offset);                                               // 695
        offset -= 2;                                                                                                   // 696
        if (this.littleEndian) {                                                                                       // 697
            this.view[offset+1] = (value & 0xFF00) >>> 8;                                                              // 698
            this.view[offset  ] =  value & 0x00FF;                                                                     // 699
        } else {                                                                                                       // 700
            this.view[offset]   = (value & 0xFF00) >>> 8;                                                              // 701
            this.view[offset+1] =  value & 0x00FF;                                                                     // 702
        }                                                                                                              // 703
        if (relative) this.offset += 2;                                                                                // 704
        return this;                                                                                                   // 705
    };                                                                                                                 // 706
                                                                                                                       // 707
    /**                                                                                                                // 708
     * Writes a 16bit signed integer. This is an alias of {@link ByteBuffer#writeInt16}.                               // 709
     * @function                                                                                                       // 710
     * @param {number} value Value to write                                                                            // 711
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.   // 712
     * @throws {TypeError} If `offset` or `value` is not a valid number                                                // 713
     * @throws {RangeError} If `offset` is out of bounds                                                               // 714
     * @expose                                                                                                         // 715
     */                                                                                                                // 716
    ByteBufferPrototype.writeShort = ByteBufferPrototype.writeInt16;                                                   // 717
                                                                                                                       // 718
    /**                                                                                                                // 719
     * Reads a 16bit signed integer.                                                                                   // 720
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.  // 721
     * @returns {number} Value read                                                                                    // 722
     * @throws {TypeError} If `offset` is not a valid number                                                           // 723
     * @throws {RangeError} If `offset` is out of bounds                                                               // 724
     * @expose                                                                                                         // 725
     */                                                                                                                // 726
    ByteBufferPrototype.readInt16 = function(offset) {                                                                 // 727
        var relative = typeof offset === 'undefined';                                                                  // 728
        if (relative) offset = this.offset;                                                                            // 729
        if (!this.noAssert) {                                                                                          // 730
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 731
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 732
            offset >>>= 0;                                                                                             // 733
            if (offset < 0 || offset + 2 > this.buffer.byteLength)                                                     // 734
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);               // 735
        }                                                                                                              // 736
        var value = 0;                                                                                                 // 737
        if (this.littleEndian) {                                                                                       // 738
            value  = this.view[offset  ];                                                                              // 739
            value |= this.view[offset+1] << 8;                                                                         // 740
        } else {                                                                                                       // 741
            value  = this.view[offset  ] << 8;                                                                         // 742
            value |= this.view[offset+1];                                                                              // 743
        }                                                                                                              // 744
        if ((value & 0x8000) === 0x8000) value = -(0xFFFF - value + 1); // Cast to signed                              // 745
        if (relative) this.offset += 2;                                                                                // 746
        return value;                                                                                                  // 747
    };                                                                                                                 // 748
                                                                                                                       // 749
    /**                                                                                                                // 750
     * Reads a 16bit signed integer. This is an alias of {@link ByteBuffer#readInt16}.                                 // 751
     * @function                                                                                                       // 752
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.  // 753
     * @returns {number} Value read                                                                                    // 754
     * @throws {TypeError} If `offset` is not a valid number                                                           // 755
     * @throws {RangeError} If `offset` is out of bounds                                                               // 756
     * @expose                                                                                                         // 757
     */                                                                                                                // 758
    ByteBufferPrototype.readShort = ByteBufferPrototype.readInt16;                                                     // 759
                                                                                                                       // 760
    /**                                                                                                                // 761
     * Writes a 16bit unsigned integer.                                                                                // 762
     * @param {number} value Value to write                                                                            // 763
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.   // 764
     * @throws {TypeError} If `offset` or `value` is not a valid number                                                // 765
     * @throws {RangeError} If `offset` is out of bounds                                                               // 766
     * @expose                                                                                                         // 767
     */                                                                                                                // 768
    ByteBufferPrototype.writeUint16 = function(value, offset) {                                                        // 769
        var relative = typeof offset === 'undefined';                                                                  // 770
        if (relative) offset = this.offset;                                                                            // 771
        if (!this.noAssert) {                                                                                          // 772
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 773
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 774
            value >>>= 0;                                                                                              // 775
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 776
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 777
            offset >>>= 0;                                                                                             // 778
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 779
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 780
        }                                                                                                              // 781
        offset += 2;                                                                                                   // 782
        var capacity3 = this.buffer.byteLength;                                                                        // 783
        if (offset > capacity3)                                                                                        // 784
            this.resize((capacity3 *= 2) > offset ? capacity3 : offset);                                               // 785
        offset -= 2;                                                                                                   // 786
        if (this.littleEndian) {                                                                                       // 787
            this.view[offset+1] = (value & 0xFF00) >>> 8;                                                              // 788
            this.view[offset  ] =  value & 0x00FF;                                                                     // 789
        } else {                                                                                                       // 790
            this.view[offset]   = (value & 0xFF00) >>> 8;                                                              // 791
            this.view[offset+1] =  value & 0x00FF;                                                                     // 792
        }                                                                                                              // 793
        if (relative) this.offset += 2;                                                                                // 794
        return this;                                                                                                   // 795
    };                                                                                                                 // 796
                                                                                                                       // 797
    /**                                                                                                                // 798
     * Writes a 16bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint16}.                            // 799
     * @function                                                                                                       // 800
     * @param {number} value Value to write                                                                            // 801
     * @param {number=} offset Offset to write to. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.   // 802
     * @throws {TypeError} If `offset` or `value` is not a valid number                                                // 803
     * @throws {RangeError} If `offset` is out of bounds                                                               // 804
     * @expose                                                                                                         // 805
     */                                                                                                                // 806
    ByteBufferPrototype.writeUInt16 = ByteBufferPrototype.writeUint16;                                                 // 807
                                                                                                                       // 808
    /**                                                                                                                // 809
     * Reads a 16bit unsigned integer.                                                                                 // 810
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.  // 811
     * @returns {number} Value read                                                                                    // 812
     * @throws {TypeError} If `offset` is not a valid number                                                           // 813
     * @throws {RangeError} If `offset` is out of bounds                                                               // 814
     * @expose                                                                                                         // 815
     */                                                                                                                // 816
    ByteBufferPrototype.readUint16 = function(offset) {                                                                // 817
        var relative = typeof offset === 'undefined';                                                                  // 818
        if (relative) offset = this.offset;                                                                            // 819
        if (!this.noAssert) {                                                                                          // 820
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 821
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 822
            offset >>>= 0;                                                                                             // 823
            if (offset < 0 || offset + 2 > this.buffer.byteLength)                                                     // 824
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+2+") <= "+this.buffer.byteLength);               // 825
        }                                                                                                              // 826
        var value = 0;                                                                                                 // 827
        if (this.littleEndian) {                                                                                       // 828
            value  = this.view[offset  ];                                                                              // 829
            value |= this.view[offset+1] << 8;                                                                         // 830
        } else {                                                                                                       // 831
            value  = this.view[offset  ] << 8;                                                                         // 832
            value |= this.view[offset+1];                                                                              // 833
        }                                                                                                              // 834
        if (relative) this.offset += 2;                                                                                // 835
        return value;                                                                                                  // 836
    };                                                                                                                 // 837
                                                                                                                       // 838
    /**                                                                                                                // 839
     * Reads a 16bit unsigned integer. This is an alias of {@link ByteBuffer#readUint16}.                              // 840
     * @function                                                                                                       // 841
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `2` if omitted.  // 842
     * @returns {number} Value read                                                                                    // 843
     * @throws {TypeError} If `offset` is not a valid number                                                           // 844
     * @throws {RangeError} If `offset` is out of bounds                                                               // 845
     * @expose                                                                                                         // 846
     */                                                                                                                // 847
    ByteBufferPrototype.readUInt16 = ByteBufferPrototype.readUint16;                                                   // 848
                                                                                                                       // 849
    // types/ints/int32                                                                                                // 850
                                                                                                                       // 851
    /**                                                                                                                // 852
     * Writes a 32bit signed integer.                                                                                  // 853
     * @param {number} value Value to write                                                                            // 854
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 855
     * @expose                                                                                                         // 856
     */                                                                                                                // 857
    ByteBufferPrototype.writeInt32 = function(value, offset) {                                                         // 858
        var relative = typeof offset === 'undefined';                                                                  // 859
        if (relative) offset = this.offset;                                                                            // 860
        if (!this.noAssert) {                                                                                          // 861
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 862
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 863
            value |= 0;                                                                                                // 864
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 865
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 866
            offset >>>= 0;                                                                                             // 867
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 868
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 869
        }                                                                                                              // 870
        offset += 4;                                                                                                   // 871
        var capacity4 = this.buffer.byteLength;                                                                        // 872
        if (offset > capacity4)                                                                                        // 873
            this.resize((capacity4 *= 2) > offset ? capacity4 : offset);                                               // 874
        offset -= 4;                                                                                                   // 875
        if (this.littleEndian) {                                                                                       // 876
            this.view[offset+3] = (value >>> 24) & 0xFF;                                                               // 877
            this.view[offset+2] = (value >>> 16) & 0xFF;                                                               // 878
            this.view[offset+1] = (value >>>  8) & 0xFF;                                                               // 879
            this.view[offset  ] =  value         & 0xFF;                                                               // 880
        } else {                                                                                                       // 881
            this.view[offset  ] = (value >>> 24) & 0xFF;                                                               // 882
            this.view[offset+1] = (value >>> 16) & 0xFF;                                                               // 883
            this.view[offset+2] = (value >>>  8) & 0xFF;                                                               // 884
            this.view[offset+3] =  value         & 0xFF;                                                               // 885
        }                                                                                                              // 886
        if (relative) this.offset += 4;                                                                                // 887
        return this;                                                                                                   // 888
    };                                                                                                                 // 889
                                                                                                                       // 890
    /**                                                                                                                // 891
     * Writes a 32bit signed integer. This is an alias of {@link ByteBuffer#writeInt32}.                               // 892
     * @param {number} value Value to write                                                                            // 893
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 894
     * @expose                                                                                                         // 895
     */                                                                                                                // 896
    ByteBufferPrototype.writeInt = ByteBufferPrototype.writeInt32;                                                     // 897
                                                                                                                       // 898
    /**                                                                                                                // 899
     * Reads a 32bit signed integer.                                                                                   // 900
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read                                                                                    // 902
     * @expose                                                                                                         // 903
     */                                                                                                                // 904
    ByteBufferPrototype.readInt32 = function(offset) {                                                                 // 905
        var relative = typeof offset === 'undefined';                                                                  // 906
        if (relative) offset = this.offset;                                                                            // 907
        if (!this.noAssert) {                                                                                          // 908
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 909
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 910
            offset >>>= 0;                                                                                             // 911
            if (offset < 0 || offset + 4 > this.buffer.byteLength)                                                     // 912
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);               // 913
        }                                                                                                              // 914
        var value = 0;                                                                                                 // 915
        if (this.littleEndian) {                                                                                       // 916
            value  = this.view[offset+2] << 16;                                                                        // 917
            value |= this.view[offset+1] <<  8;                                                                        // 918
            value |= this.view[offset  ];                                                                              // 919
            value += this.view[offset+3] << 24 >>> 0;                                                                  // 920
        } else {                                                                                                       // 921
            value  = this.view[offset+1] << 16;                                                                        // 922
            value |= this.view[offset+2] <<  8;                                                                        // 923
            value |= this.view[offset+3];                                                                              // 924
            value += this.view[offset  ] << 24 >>> 0;                                                                  // 925
        }                                                                                                              // 926
        value |= 0; // Cast to signed                                                                                  // 927
        if (relative) this.offset += 4;                                                                                // 928
        return value;                                                                                                  // 929
    };                                                                                                                 // 930
                                                                                                                       // 931
    /**                                                                                                                // 932
     * Reads a 32bit signed integer. This is an alias of {@link ByteBuffer#readInt32}.                                 // 933
     * @param {number=} offset Offset to read from. Will use and advance {@link ByteBuffer#offset} by `4` if omitted.  // 934
     * @returns {number} Value read                                                                                    // 935
     * @expose                                                                                                         // 936
     */                                                                                                                // 937
    ByteBufferPrototype.readInt = ByteBufferPrototype.readInt32;                                                       // 938
                                                                                                                       // 939
    /**                                                                                                                // 940
     * Writes a 32bit unsigned integer.                                                                                // 941
     * @param {number} value Value to write                                                                            // 942
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 943
     * @expose                                                                                                         // 944
     */                                                                                                                // 945
    ByteBufferPrototype.writeUint32 = function(value, offset) {                                                        // 946
        var relative = typeof offset === 'undefined';                                                                  // 947
        if (relative) offset = this.offset;                                                                            // 948
        if (!this.noAssert) {                                                                                          // 949
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 950
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 951
            value >>>= 0;                                                                                              // 952
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 953
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 954
            offset >>>= 0;                                                                                             // 955
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 956
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 957
        }                                                                                                              // 958
        offset += 4;                                                                                                   // 959
        var capacity5 = this.buffer.byteLength;                                                                        // 960
        if (offset > capacity5)                                                                                        // 961
            this.resize((capacity5 *= 2) > offset ? capacity5 : offset);                                               // 962
        offset -= 4;                                                                                                   // 963
        if (this.littleEndian) {                                                                                       // 964
            this.view[offset+3] = (value >>> 24) & 0xFF;                                                               // 965
            this.view[offset+2] = (value >>> 16) & 0xFF;                                                               // 966
            this.view[offset+1] = (value >>>  8) & 0xFF;                                                               // 967
            this.view[offset  ] =  value         & 0xFF;                                                               // 968
        } else {                                                                                                       // 969
            this.view[offset  ] = (value >>> 24) & 0xFF;                                                               // 970
            this.view[offset+1] = (value >>> 16) & 0xFF;                                                               // 971
            this.view[offset+2] = (value >>>  8) & 0xFF;                                                               // 972
            this.view[offset+3] =  value         & 0xFF;                                                               // 973
        }                                                                                                              // 974
        if (relative) this.offset += 4;                                                                                // 975
        return this;                                                                                                   // 976
    };                                                                                                                 // 977
                                                                                                                       // 978
    /**                                                                                                                // 979
     * Writes a 32bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint32}.                            // 980
     * @function                                                                                                       // 981
     * @param {number} value Value to write                                                                            // 982
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 983
     * @expose                                                                                                         // 984
     */                                                                                                                // 985
    ByteBufferPrototype.writeUInt32 = ByteBufferPrototype.writeUint32;                                                 // 986
                                                                                                                       // 987
    /**                                                                                                                // 988
     * Reads a 32bit unsigned integer.                                                                                 // 989
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read                                                                                    // 991
     * @expose                                                                                                         // 992
     */                                                                                                                // 993
    ByteBufferPrototype.readUint32 = function(offset) {                                                                // 994
        var relative = typeof offset === 'undefined';                                                                  // 995
        if (relative) offset = this.offset;                                                                            // 996
        if (!this.noAssert) {                                                                                          // 997
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 998
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 999
            offset >>>= 0;                                                                                             // 1000
            if (offset < 0 || offset + 4 > this.buffer.byteLength)                                                     // 1001
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);               // 1002
        }                                                                                                              // 1003
        var value = 0;                                                                                                 // 1004
        if (this.littleEndian) {                                                                                       // 1005
            value  = this.view[offset+2] << 16;                                                                        // 1006
            value |= this.view[offset+1] <<  8;                                                                        // 1007
            value |= this.view[offset  ];                                                                              // 1008
            value += this.view[offset+3] << 24 >>> 0;                                                                  // 1009
        } else {                                                                                                       // 1010
            value  = this.view[offset+1] << 16;                                                                        // 1011
            value |= this.view[offset+2] <<  8;                                                                        // 1012
            value |= this.view[offset+3];                                                                              // 1013
            value += this.view[offset  ] << 24 >>> 0;                                                                  // 1014
        }                                                                                                              // 1015
        if (relative) this.offset += 4;                                                                                // 1016
        return value;                                                                                                  // 1017
    };                                                                                                                 // 1018
                                                                                                                       // 1019
    /**                                                                                                                // 1020
     * Reads a 32bit unsigned integer. This is an alias of {@link ByteBuffer#readUint32}.                              // 1021
     * @function                                                                                                       // 1022
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number} Value read                                                                                    // 1024
     * @expose                                                                                                         // 1025
     */                                                                                                                // 1026
    ByteBufferPrototype.readUInt32 = ByteBufferPrototype.readUint32;                                                   // 1027
                                                                                                                       // 1028
    // types/ints/int64                                                                                                // 1029
                                                                                                                       // 1030
    if (Long) {                                                                                                        // 1031
                                                                                                                       // 1032
        /**                                                                                                            // 1033
         * Writes a 64bit signed integer.                                                                              // 1034
         * @param {number|!Long} value Value to write                                                                  // 1035
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this                                                                                 // 1037
         * @expose                                                                                                     // 1038
         */                                                                                                            // 1039
        ByteBufferPrototype.writeInt64 = function(value, offset) {                                                     // 1040
            var relative = typeof offset === 'undefined';                                                              // 1041
            if (relative) offset = this.offset;                                                                        // 1042
            if (!this.noAssert) {                                                                                      // 1043
                if (typeof value === 'number')                                                                         // 1044
                    value = Long.fromNumber(value);                                                                    // 1045
                else if (typeof value === 'string')                                                                    // 1046
                    value = Long.fromString(value);                                                                    // 1047
                else if (!(value && value instanceof Long))                                                            // 1048
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");                              // 1049
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1050
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1051
                offset >>>= 0;                                                                                         // 1052
                if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                 // 1053
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);           // 1054
            }                                                                                                          // 1055
            if (typeof value === 'number')                                                                             // 1056
                value = Long.fromNumber(value);                                                                        // 1057
            else if (typeof value === 'string')                                                                        // 1058
                value = Long.fromString(value);                                                                        // 1059
            offset += 8;                                                                                               // 1060
            var capacity6 = this.buffer.byteLength;                                                                    // 1061
            if (offset > capacity6)                                                                                    // 1062
                this.resize((capacity6 *= 2) > offset ? capacity6 : offset);                                           // 1063
            offset -= 8;                                                                                               // 1064
            var lo = value.low,                                                                                        // 1065
                hi = value.high;                                                                                       // 1066
            if (this.littleEndian) {                                                                                   // 1067
                this.view[offset+3] = (lo >>> 24) & 0xFF;                                                              // 1068
                this.view[offset+2] = (lo >>> 16) & 0xFF;                                                              // 1069
                this.view[offset+1] = (lo >>>  8) & 0xFF;                                                              // 1070
                this.view[offset  ] =  lo         & 0xFF;                                                              // 1071
                offset += 4;                                                                                           // 1072
                this.view[offset+3] = (hi >>> 24) & 0xFF;                                                              // 1073
                this.view[offset+2] = (hi >>> 16) & 0xFF;                                                              // 1074
                this.view[offset+1] = (hi >>>  8) & 0xFF;                                                              // 1075
                this.view[offset  ] =  hi         & 0xFF;                                                              // 1076
            } else {                                                                                                   // 1077
                this.view[offset  ] = (hi >>> 24) & 0xFF;                                                              // 1078
                this.view[offset+1] = (hi >>> 16) & 0xFF;                                                              // 1079
                this.view[offset+2] = (hi >>>  8) & 0xFF;                                                              // 1080
                this.view[offset+3] =  hi         & 0xFF;                                                              // 1081
                offset += 4;                                                                                           // 1082
                this.view[offset  ] = (lo >>> 24) & 0xFF;                                                              // 1083
                this.view[offset+1] = (lo >>> 16) & 0xFF;                                                              // 1084
                this.view[offset+2] = (lo >>>  8) & 0xFF;                                                              // 1085
                this.view[offset+3] =  lo         & 0xFF;                                                              // 1086
            }                                                                                                          // 1087
            if (relative) this.offset += 8;                                                                            // 1088
            return this;                                                                                               // 1089
        };                                                                                                             // 1090
                                                                                                                       // 1091
        /**                                                                                                            // 1092
         * Writes a 64bit signed integer. This is an alias of {@link ByteBuffer#writeInt64}.                           // 1093
         * @param {number|!Long} value Value to write                                                                  // 1094
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this                                                                                 // 1096
         * @expose                                                                                                     // 1097
         */                                                                                                            // 1098
        ByteBufferPrototype.writeLong = ByteBufferPrototype.writeInt64;                                                // 1099
                                                                                                                       // 1100
        /**                                                                                                            // 1101
         * Reads a 64bit signed integer.                                                                               // 1102
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}                                                                                            // 1104
         * @expose                                                                                                     // 1105
         */                                                                                                            // 1106
        ByteBufferPrototype.readInt64 = function(offset) {                                                             // 1107
            var relative = typeof offset === 'undefined';                                                              // 1108
            if (relative) offset = this.offset;                                                                        // 1109
            if (!this.noAssert) {                                                                                      // 1110
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1111
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1112
                offset >>>= 0;                                                                                         // 1113
                if (offset < 0 || offset + 8 > this.buffer.byteLength)                                                 // 1114
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);           // 1115
            }                                                                                                          // 1116
            var lo = 0,                                                                                                // 1117
                hi = 0;                                                                                                // 1118
            if (this.littleEndian) {                                                                                   // 1119
                lo  = this.view[offset+2] << 16;                                                                       // 1120
                lo |= this.view[offset+1] <<  8;                                                                       // 1121
                lo |= this.view[offset  ];                                                                             // 1122
                lo += this.view[offset+3] << 24 >>> 0;                                                                 // 1123
                offset += 4;                                                                                           // 1124
                hi  = this.view[offset+2] << 16;                                                                       // 1125
                hi |= this.view[offset+1] <<  8;                                                                       // 1126
                hi |= this.view[offset  ];                                                                             // 1127
                hi += this.view[offset+3] << 24 >>> 0;                                                                 // 1128
            } else {                                                                                                   // 1129
                hi  = this.view[offset+1] << 16;                                                                       // 1130
                hi |= this.view[offset+2] <<  8;                                                                       // 1131
                hi |= this.view[offset+3];                                                                             // 1132
                hi += this.view[offset  ] << 24 >>> 0;                                                                 // 1133
                offset += 4;                                                                                           // 1134
                lo  = this.view[offset+1] << 16;                                                                       // 1135
                lo |= this.view[offset+2] <<  8;                                                                       // 1136
                lo |= this.view[offset+3];                                                                             // 1137
                lo += this.view[offset  ] << 24 >>> 0;                                                                 // 1138
            }                                                                                                          // 1139
            var value = new Long(lo, hi, false);                                                                       // 1140
            if (relative) this.offset += 8;                                                                            // 1141
            return value;                                                                                              // 1142
        };                                                                                                             // 1143
                                                                                                                       // 1144
        /**                                                                                                            // 1145
         * Reads a 64bit signed integer. This is an alias of {@link ByteBuffer#readInt64}.                             // 1146
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}                                                                                            // 1148
         * @expose                                                                                                     // 1149
         */                                                                                                            // 1150
        ByteBufferPrototype.readLong = ByteBufferPrototype.readInt64;                                                  // 1151
                                                                                                                       // 1152
        /**                                                                                                            // 1153
         * Writes a 64bit unsigned integer.                                                                            // 1154
         * @param {number|!Long} value Value to write                                                                  // 1155
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this                                                                                 // 1157
         * @expose                                                                                                     // 1158
         */                                                                                                            // 1159
        ByteBufferPrototype.writeUint64 = function(value, offset) {                                                    // 1160
            var relative = typeof offset === 'undefined';                                                              // 1161
            if (relative) offset = this.offset;                                                                        // 1162
            if (!this.noAssert) {                                                                                      // 1163
                if (typeof value === 'number')                                                                         // 1164
                    value = Long.fromNumber(value);                                                                    // 1165
                else if (typeof value === 'string')                                                                    // 1166
                    value = Long.fromString(value);                                                                    // 1167
                else if (!(value && value instanceof Long))                                                            // 1168
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");                              // 1169
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1170
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1171
                offset >>>= 0;                                                                                         // 1172
                if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                 // 1173
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);           // 1174
            }                                                                                                          // 1175
            if (typeof value === 'number')                                                                             // 1176
                value = Long.fromNumber(value);                                                                        // 1177
            else if (typeof value === 'string')                                                                        // 1178
                value = Long.fromString(value);                                                                        // 1179
            offset += 8;                                                                                               // 1180
            var capacity7 = this.buffer.byteLength;                                                                    // 1181
            if (offset > capacity7)                                                                                    // 1182
                this.resize((capacity7 *= 2) > offset ? capacity7 : offset);                                           // 1183
            offset -= 8;                                                                                               // 1184
            var lo = value.low,                                                                                        // 1185
                hi = value.high;                                                                                       // 1186
            if (this.littleEndian) {                                                                                   // 1187
                this.view[offset+3] = (lo >>> 24) & 0xFF;                                                              // 1188
                this.view[offset+2] = (lo >>> 16) & 0xFF;                                                              // 1189
                this.view[offset+1] = (lo >>>  8) & 0xFF;                                                              // 1190
                this.view[offset  ] =  lo         & 0xFF;                                                              // 1191
                offset += 4;                                                                                           // 1192
                this.view[offset+3] = (hi >>> 24) & 0xFF;                                                              // 1193
                this.view[offset+2] = (hi >>> 16) & 0xFF;                                                              // 1194
                this.view[offset+1] = (hi >>>  8) & 0xFF;                                                              // 1195
                this.view[offset  ] =  hi         & 0xFF;                                                              // 1196
            } else {                                                                                                   // 1197
                this.view[offset  ] = (hi >>> 24) & 0xFF;                                                              // 1198
                this.view[offset+1] = (hi >>> 16) & 0xFF;                                                              // 1199
                this.view[offset+2] = (hi >>>  8) & 0xFF;                                                              // 1200
                this.view[offset+3] =  hi         & 0xFF;                                                              // 1201
                offset += 4;                                                                                           // 1202
                this.view[offset  ] = (lo >>> 24) & 0xFF;                                                              // 1203
                this.view[offset+1] = (lo >>> 16) & 0xFF;                                                              // 1204
                this.view[offset+2] = (lo >>>  8) & 0xFF;                                                              // 1205
                this.view[offset+3] =  lo         & 0xFF;                                                              // 1206
            }                                                                                                          // 1207
            if (relative) this.offset += 8;                                                                            // 1208
            return this;                                                                                               // 1209
        };                                                                                                             // 1210
                                                                                                                       // 1211
        /**                                                                                                            // 1212
         * Writes a 64bit unsigned integer. This is an alias of {@link ByteBuffer#writeUint64}.                        // 1213
         * @function                                                                                                   // 1214
         * @param {number|!Long} value Value to write                                                                  // 1215
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!ByteBuffer} this                                                                                 // 1217
         * @expose                                                                                                     // 1218
         */                                                                                                            // 1219
        ByteBufferPrototype.writeUInt64 = ByteBufferPrototype.writeUint64;                                             // 1220
                                                                                                                       // 1221
        /**                                                                                                            // 1222
         * Reads a 64bit unsigned integer.                                                                             // 1223
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}                                                                                            // 1225
         * @expose                                                                                                     // 1226
         */                                                                                                            // 1227
        ByteBufferPrototype.readUint64 = function(offset) {                                                            // 1228
            var relative = typeof offset === 'undefined';                                                              // 1229
            if (relative) offset = this.offset;                                                                        // 1230
            if (!this.noAssert) {                                                                                      // 1231
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1232
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1233
                offset >>>= 0;                                                                                         // 1234
                if (offset < 0 || offset + 8 > this.buffer.byteLength)                                                 // 1235
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);           // 1236
            }                                                                                                          // 1237
            var lo = 0,                                                                                                // 1238
                hi = 0;                                                                                                // 1239
            if (this.littleEndian) {                                                                                   // 1240
                lo  = this.view[offset+2] << 16;                                                                       // 1241
                lo |= this.view[offset+1] <<  8;                                                                       // 1242
                lo |= this.view[offset  ];                                                                             // 1243
                lo += this.view[offset+3] << 24 >>> 0;                                                                 // 1244
                offset += 4;                                                                                           // 1245
                hi  = this.view[offset+2] << 16;                                                                       // 1246
                hi |= this.view[offset+1] <<  8;                                                                       // 1247
                hi |= this.view[offset  ];                                                                             // 1248
                hi += this.view[offset+3] << 24 >>> 0;                                                                 // 1249
            } else {                                                                                                   // 1250
                hi  = this.view[offset+1] << 16;                                                                       // 1251
                hi |= this.view[offset+2] <<  8;                                                                       // 1252
                hi |= this.view[offset+3];                                                                             // 1253
                hi += this.view[offset  ] << 24 >>> 0;                                                                 // 1254
                offset += 4;                                                                                           // 1255
                lo  = this.view[offset+1] << 16;                                                                       // 1256
                lo |= this.view[offset+2] <<  8;                                                                       // 1257
                lo |= this.view[offset+3];                                                                             // 1258
                lo += this.view[offset  ] << 24 >>> 0;                                                                 // 1259
            }                                                                                                          // 1260
            var value = new Long(lo, hi, true);                                                                        // 1261
            if (relative) this.offset += 8;                                                                            // 1262
            return value;                                                                                              // 1263
        };                                                                                                             // 1264
                                                                                                                       // 1265
        /**                                                                                                            // 1266
         * Reads a 64bit unsigned integer. This is an alias of {@link ByteBuffer#readUint64}.                          // 1267
         * @function                                                                                                   // 1268
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
         * @returns {!Long}                                                                                            // 1270
         * @expose                                                                                                     // 1271
         */                                                                                                            // 1272
        ByteBufferPrototype.readUInt64 = ByteBufferPrototype.readUint64;                                               // 1273
                                                                                                                       // 1274
    } // Long                                                                                                          // 1275
                                                                                                                       // 1276
                                                                                                                       // 1277
    // types/floats/float32                                                                                            // 1278
                                                                                                                       // 1279
    /*                                                                                                                 // 1280
     ieee754 - https://github.com/feross/ieee754                                                                       // 1281
                                                                                                                       // 1282
     The MIT License (MIT)                                                                                             // 1283
                                                                                                                       // 1284
     Copyright (c) Feross Aboukhadijeh                                                                                 // 1285
                                                                                                                       // 1286
     Permission is hereby granted, free of charge, to any person obtaining a copy                                      // 1287
     of this software and associated documentation files (the "Software"), to deal                                     // 1288
     in the Software without restriction, including without limitation the rights                                      // 1289
     to use, copy, modify, merge, publish, distribute, sublicense, and/or sell                                         // 1290
     copies of the Software, and to permit persons to whom the Software is                                             // 1291
     furnished to do so, subject to the following conditions:                                                          // 1292
                                                                                                                       // 1293
     The above copyright notice and this permission notice shall be included in                                        // 1294
     all copies or substantial portions of the Software.                                                               // 1295
                                                                                                                       // 1296
     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR                                        // 1297
     IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,                                          // 1298
     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE                                       // 1299
     AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER                                            // 1300
     LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,                                     // 1301
     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN                                         // 1302
     THE SOFTWARE.                                                                                                     // 1303
    */                                                                                                                 // 1304
                                                                                                                       // 1305
    /**                                                                                                                // 1306
     * Reads an IEEE754 float from a byte array.                                                                       // 1307
     * @param {!Array} buffer                                                                                          // 1308
     * @param {number} offset                                                                                          // 1309
     * @param {boolean} isLE                                                                                           // 1310
     * @param {number} mLen                                                                                            // 1311
     * @param {number} nBytes                                                                                          // 1312
     * @returns {number}                                                                                               // 1313
     * @inner                                                                                                          // 1314
     */                                                                                                                // 1315
    function ieee754_read(buffer, offset, isLE, mLen, nBytes) {                                                        // 1316
        var e, m,                                                                                                      // 1317
            eLen = nBytes * 8 - mLen - 1,                                                                              // 1318
            eMax = (1 << eLen) - 1,                                                                                    // 1319
            eBias = eMax >> 1,                                                                                         // 1320
            nBits = -7,                                                                                                // 1321
            i = isLE ? (nBytes - 1) : 0,                                                                               // 1322
            d = isLE ? -1 : 1,                                                                                         // 1323
            s = buffer[offset + i];                                                                                    // 1324
                                                                                                                       // 1325
        i += d;                                                                                                        // 1326
                                                                                                                       // 1327
        e = s & ((1 << (-nBits)) - 1);                                                                                 // 1328
        s >>= (-nBits);                                                                                                // 1329
        nBits += eLen;                                                                                                 // 1330
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                     // 1331
                                                                                                                       // 1332
        m = e & ((1 << (-nBits)) - 1);                                                                                 // 1333
        e >>= (-nBits);                                                                                                // 1334
        nBits += mLen;                                                                                                 // 1335
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}                                     // 1336
                                                                                                                       // 1337
        if (e === 0) {                                                                                                 // 1338
            e = 1 - eBias;                                                                                             // 1339
        } else if (e === eMax) {                                                                                       // 1340
            return m ? NaN : ((s ? -1 : 1) * Infinity);                                                                // 1341
        } else {                                                                                                       // 1342
            m = m + Math.pow(2, mLen);                                                                                 // 1343
            e = e - eBias;                                                                                             // 1344
        }                                                                                                              // 1345
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);                                                               // 1346
    }                                                                                                                  // 1347
                                                                                                                       // 1348
    /**                                                                                                                // 1349
     * Writes an IEEE754 float to a byte array.                                                                        // 1350
     * @param {!Array} buffer                                                                                          // 1351
     * @param {number} value                                                                                           // 1352
     * @param {number} offset                                                                                          // 1353
     * @param {boolean} isLE                                                                                           // 1354
     * @param {number} mLen                                                                                            // 1355
     * @param {number} nBytes                                                                                          // 1356
     * @inner                                                                                                          // 1357
     */                                                                                                                // 1358
    function ieee754_write(buffer, value, offset, isLE, mLen, nBytes) {                                                // 1359
        var e, m, c,                                                                                                   // 1360
            eLen = nBytes * 8 - mLen - 1,                                                                              // 1361
            eMax = (1 << eLen) - 1,                                                                                    // 1362
            eBias = eMax >> 1,                                                                                         // 1363
            rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),                                              // 1364
            i = isLE ? 0 : (nBytes - 1),                                                                               // 1365
            d = isLE ? 1 : -1,                                                                                         // 1366
            s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;                                                   // 1367
                                                                                                                       // 1368
        value = Math.abs(value);                                                                                       // 1369
                                                                                                                       // 1370
        if (isNaN(value) || value === Infinity) {                                                                      // 1371
            m = isNaN(value) ? 1 : 0;                                                                                  // 1372
            e = eMax;                                                                                                  // 1373
        } else {                                                                                                       // 1374
            e = Math.floor(Math.log(value) / Math.LN2);                                                                // 1375
            if (value * (c = Math.pow(2, -e)) < 1) {                                                                   // 1376
                e--;                                                                                                   // 1377
                c *= 2;                                                                                                // 1378
            }                                                                                                          // 1379
            if (e + eBias >= 1) {                                                                                      // 1380
                value += rt / c;                                                                                       // 1381
            } else {                                                                                                   // 1382
                value += rt * Math.pow(2, 1 - eBias);                                                                  // 1383
            }                                                                                                          // 1384
            if (value * c >= 2) {                                                                                      // 1385
                e++;                                                                                                   // 1386
                c /= 2;                                                                                                // 1387
            }                                                                                                          // 1388
                                                                                                                       // 1389
            if (e + eBias >= eMax) {                                                                                   // 1390
                m = 0;                                                                                                 // 1391
                e = eMax;                                                                                              // 1392
            } else if (e + eBias >= 1) {                                                                               // 1393
                m = (value * c - 1) * Math.pow(2, mLen);                                                               // 1394
                e = e + eBias;                                                                                         // 1395
            } else {                                                                                                   // 1396
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);                                                // 1397
                e = 0;                                                                                                 // 1398
            }                                                                                                          // 1399
        }                                                                                                              // 1400
                                                                                                                       // 1401
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}                               // 1402
                                                                                                                       // 1403
        e = (e << mLen) | m;                                                                                           // 1404
        eLen += mLen;                                                                                                  // 1405
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}                                // 1406
                                                                                                                       // 1407
        buffer[offset + i - d] |= s * 128;                                                                             // 1408
    }                                                                                                                  // 1409
                                                                                                                       // 1410
    /**                                                                                                                // 1411
     * Writes a 32bit float.                                                                                           // 1412
     * @param {number} value Value to write                                                                            // 1413
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 1414
     * @returns {!ByteBuffer} this                                                                                     // 1415
     * @expose                                                                                                         // 1416
     */                                                                                                                // 1417
    ByteBufferPrototype.writeFloat32 = function(value, offset) {                                                       // 1418
        var relative = typeof offset === 'undefined';                                                                  // 1419
        if (relative) offset = this.offset;                                                                            // 1420
        if (!this.noAssert) {                                                                                          // 1421
            if (typeof value !== 'number')                                                                             // 1422
                throw TypeError("Illegal value: "+value+" (not a number)");                                            // 1423
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1424
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1425
            offset >>>= 0;                                                                                             // 1426
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 1427
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 1428
        }                                                                                                              // 1429
        offset += 4;                                                                                                   // 1430
        var capacity8 = this.buffer.byteLength;                                                                        // 1431
        if (offset > capacity8)                                                                                        // 1432
            this.resize((capacity8 *= 2) > offset ? capacity8 : offset);                                               // 1433
        offset -= 4;                                                                                                   // 1434
        ieee754_write(this.view, value, offset, this.littleEndian, 23, 4);                                             // 1435
        if (relative) this.offset += 4;                                                                                // 1436
        return this;                                                                                                   // 1437
    };                                                                                                                 // 1438
                                                                                                                       // 1439
    /**                                                                                                                // 1440
     * Writes a 32bit float. This is an alias of {@link ByteBuffer#writeFloat32}.                                      // 1441
     * @function                                                                                                       // 1442
     * @param {number} value Value to write                                                                            // 1443
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.  // 1444
     * @returns {!ByteBuffer} this                                                                                     // 1445
     * @expose                                                                                                         // 1446
     */                                                                                                                // 1447
    ByteBufferPrototype.writeFloat = ByteBufferPrototype.writeFloat32;                                                 // 1448
                                                                                                                       // 1449
    /**                                                                                                                // 1450
     * Reads a 32bit float.                                                                                            // 1451
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}                                                                                               // 1453
     * @expose                                                                                                         // 1454
     */                                                                                                                // 1455
    ByteBufferPrototype.readFloat32 = function(offset) {                                                               // 1456
        var relative = typeof offset === 'undefined';                                                                  // 1457
        if (relative) offset = this.offset;                                                                            // 1458
        if (!this.noAssert) {                                                                                          // 1459
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1460
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1461
            offset >>>= 0;                                                                                             // 1462
            if (offset < 0 || offset + 4 > this.buffer.byteLength)                                                     // 1463
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);               // 1464
        }                                                                                                              // 1465
        var value = ieee754_read(this.view, offset, this.littleEndian, 23, 4);                                         // 1466
        if (relative) this.offset += 4;                                                                                // 1467
        return value;                                                                                                  // 1468
    };                                                                                                                 // 1469
                                                                                                                       // 1470
    /**                                                                                                                // 1471
     * Reads a 32bit float. This is an alias of {@link ByteBuffer#readFloat32}.                                        // 1472
     * @function                                                                                                       // 1473
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `4` if omitted.
     * @returns {number}                                                                                               // 1475
     * @expose                                                                                                         // 1476
     */                                                                                                                // 1477
    ByteBufferPrototype.readFloat = ByteBufferPrototype.readFloat32;                                                   // 1478
                                                                                                                       // 1479
    // types/floats/float64                                                                                            // 1480
                                                                                                                       // 1481
    /**                                                                                                                // 1482
     * Writes a 64bit float.                                                                                           // 1483
     * @param {number} value Value to write                                                                            // 1484
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.  // 1485
     * @returns {!ByteBuffer} this                                                                                     // 1486
     * @expose                                                                                                         // 1487
     */                                                                                                                // 1488
    ByteBufferPrototype.writeFloat64 = function(value, offset) {                                                       // 1489
        var relative = typeof offset === 'undefined';                                                                  // 1490
        if (relative) offset = this.offset;                                                                            // 1491
        if (!this.noAssert) {                                                                                          // 1492
            if (typeof value !== 'number')                                                                             // 1493
                throw TypeError("Illegal value: "+value+" (not a number)");                                            // 1494
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1495
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1496
            offset >>>= 0;                                                                                             // 1497
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 1498
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 1499
        }                                                                                                              // 1500
        offset += 8;                                                                                                   // 1501
        var capacity9 = this.buffer.byteLength;                                                                        // 1502
        if (offset > capacity9)                                                                                        // 1503
            this.resize((capacity9 *= 2) > offset ? capacity9 : offset);                                               // 1504
        offset -= 8;                                                                                                   // 1505
        ieee754_write(this.view, value, offset, this.littleEndian, 52, 8);                                             // 1506
        if (relative) this.offset += 8;                                                                                // 1507
        return this;                                                                                                   // 1508
    };                                                                                                                 // 1509
                                                                                                                       // 1510
    /**                                                                                                                // 1511
     * Writes a 64bit float. This is an alias of {@link ByteBuffer#writeFloat64}.                                      // 1512
     * @function                                                                                                       // 1513
     * @param {number} value Value to write                                                                            // 1514
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.  // 1515
     * @returns {!ByteBuffer} this                                                                                     // 1516
     * @expose                                                                                                         // 1517
     */                                                                                                                // 1518
    ByteBufferPrototype.writeDouble = ByteBufferPrototype.writeFloat64;                                                // 1519
                                                                                                                       // 1520
    /**                                                                                                                // 1521
     * Reads a 64bit float.                                                                                            // 1522
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}                                                                                               // 1524
     * @expose                                                                                                         // 1525
     */                                                                                                                // 1526
    ByteBufferPrototype.readFloat64 = function(offset) {                                                               // 1527
        var relative = typeof offset === 'undefined';                                                                  // 1528
        if (relative) offset = this.offset;                                                                            // 1529
        if (!this.noAssert) {                                                                                          // 1530
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1531
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1532
            offset >>>= 0;                                                                                             // 1533
            if (offset < 0 || offset + 8 > this.buffer.byteLength)                                                     // 1534
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+8+") <= "+this.buffer.byteLength);               // 1535
        }                                                                                                              // 1536
        var value = ieee754_read(this.view, offset, this.littleEndian, 52, 8);                                         // 1537
        if (relative) this.offset += 8;                                                                                // 1538
        return value;                                                                                                  // 1539
    };                                                                                                                 // 1540
                                                                                                                       // 1541
    /**                                                                                                                // 1542
     * Reads a 64bit float. This is an alias of {@link ByteBuffer#readFloat64}.                                        // 1543
     * @function                                                                                                       // 1544
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by `8` if omitted.
     * @returns {number}                                                                                               // 1546
     * @expose                                                                                                         // 1547
     */                                                                                                                // 1548
    ByteBufferPrototype.readDouble = ByteBufferPrototype.readFloat64;                                                  // 1549
                                                                                                                       // 1550
                                                                                                                       // 1551
    // types/varints/varint32                                                                                          // 1552
                                                                                                                       // 1553
    /**                                                                                                                // 1554
     * Maximum number of bytes required to store a 32bit base 128 variable-length integer.                             // 1555
     * @type {number}                                                                                                  // 1556
     * @const                                                                                                          // 1557
     * @expose                                                                                                         // 1558
     */                                                                                                                // 1559
    ByteBuffer.MAX_VARINT32_BYTES = 5;                                                                                 // 1560
                                                                                                                       // 1561
    /**                                                                                                                // 1562
     * Calculates the actual number of bytes required to store a 32bit base 128 variable-length integer.               // 1563
     * @param {number} value Value to encode                                                                           // 1564
     * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT32_BYTES}                     // 1565
     * @expose                                                                                                         // 1566
     */                                                                                                                // 1567
    ByteBuffer.calculateVarint32 = function(value) {                                                                   // 1568
        // ref: src/google/protobuf/io/coded_stream.cc                                                                 // 1569
        value = value >>> 0;                                                                                           // 1570
             if (value < 1 << 7 ) return 1;                                                                            // 1571
        else if (value < 1 << 14) return 2;                                                                            // 1572
        else if (value < 1 << 21) return 3;                                                                            // 1573
        else if (value < 1 << 28) return 4;                                                                            // 1574
        else                      return 5;                                                                            // 1575
    };                                                                                                                 // 1576
                                                                                                                       // 1577
    /**                                                                                                                // 1578
     * Zigzag encodes a signed 32bit integer so that it can be effectively used with varint encoding.                  // 1579
     * @param {number} n Signed 32bit integer                                                                          // 1580
     * @returns {number} Unsigned zigzag encoded 32bit integer                                                         // 1581
     * @expose                                                                                                         // 1582
     */                                                                                                                // 1583
    ByteBuffer.zigZagEncode32 = function(n) {                                                                          // 1584
        return (((n |= 0) << 1) ^ (n >> 31)) >>> 0; // ref: src/google/protobuf/wire_format_lite.h                     // 1585
    };                                                                                                                 // 1586
                                                                                                                       // 1587
    /**                                                                                                                // 1588
     * Decodes a zigzag encoded signed 32bit integer.                                                                  // 1589
     * @param {number} n Unsigned zigzag encoded 32bit integer                                                         // 1590
     * @returns {number} Signed 32bit integer                                                                          // 1591
     * @expose                                                                                                         // 1592
     */                                                                                                                // 1593
    ByteBuffer.zigZagDecode32 = function(n) {                                                                          // 1594
        return ((n >>> 1) ^ -(n & 1)) | 0; // // ref: src/google/protobuf/wire_format_lite.h                           // 1595
    };                                                                                                                 // 1596
                                                                                                                       // 1597
    /**                                                                                                                // 1598
     * Writes a 32bit base 128 variable-length integer.                                                                // 1599
     * @param {number} value Value to write                                                                            // 1600
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 1602
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written              // 1603
     * @expose                                                                                                         // 1604
     */                                                                                                                // 1605
    ByteBufferPrototype.writeVarint32 = function(value, offset) {                                                      // 1606
        var relative = typeof offset === 'undefined';                                                                  // 1607
        if (relative) offset = this.offset;                                                                            // 1608
        if (!this.noAssert) {                                                                                          // 1609
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 1610
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 1611
            value |= 0;                                                                                                // 1612
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1613
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1614
            offset >>>= 0;                                                                                             // 1615
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 1616
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 1617
        }                                                                                                              // 1618
        var size = ByteBuffer.calculateVarint32(value),                                                                // 1619
            b;                                                                                                         // 1620
        offset += size;                                                                                                // 1621
        var capacity10 = this.buffer.byteLength;                                                                       // 1622
        if (offset > capacity10)                                                                                       // 1623
            this.resize((capacity10 *= 2) > offset ? capacity10 : offset);                                             // 1624
        offset -= size;                                                                                                // 1625
        value >>>= 0;                                                                                                  // 1626
        while (value >= 0x80) {                                                                                        // 1627
            b = (value & 0x7f) | 0x80;                                                                                 // 1628
            this.view[offset++] = b;                                                                                   // 1629
            value >>>= 7;                                                                                              // 1630
        }                                                                                                              // 1631
        this.view[offset++] = value;                                                                                   // 1632
        if (relative) {                                                                                                // 1633
            this.offset = offset;                                                                                      // 1634
            return this;                                                                                               // 1635
        }                                                                                                              // 1636
        return size;                                                                                                   // 1637
    };                                                                                                                 // 1638
                                                                                                                       // 1639
    /**                                                                                                                // 1640
     * Writes a zig-zag encoded (signed) 32bit base 128 variable-length integer.                                       // 1641
     * @param {number} value Value to write                                                                            // 1642
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 1644
     * @returns {!ByteBuffer|number} this if `offset` is omitted, else the actual number of bytes written              // 1645
     * @expose                                                                                                         // 1646
     */                                                                                                                // 1647
    ByteBufferPrototype.writeVarint32ZigZag = function(value, offset) {                                                // 1648
        return this.writeVarint32(ByteBuffer.zigZagEncode32(value), offset);                                           // 1649
    };                                                                                                                 // 1650
                                                                                                                       // 1651
    /**                                                                                                                // 1652
     * Reads a 32bit base 128 variable-length integer.                                                                 // 1653
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 1655
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read     // 1656
     *  and the actual number of bytes read.                                                                           // 1657
     * @throws {Error} If it's not a valid varint. Has a property `truncated = true` if there is not enough data available
     *  to fully decode the varint.                                                                                    // 1659
     * @expose                                                                                                         // 1660
     */                                                                                                                // 1661
    ByteBufferPrototype.readVarint32 = function(offset) {                                                              // 1662
        var relative = typeof offset === 'undefined';                                                                  // 1663
        if (relative) offset = this.offset;                                                                            // 1664
        if (!this.noAssert) {                                                                                          // 1665
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1666
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1667
            offset >>>= 0;                                                                                             // 1668
            if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                     // 1669
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);               // 1670
        }                                                                                                              // 1671
        var c = 0,                                                                                                     // 1672
            value = 0 >>> 0,                                                                                           // 1673
            b;                                                                                                         // 1674
        do {                                                                                                           // 1675
            if (!this.noAssert && offset > this.limit) {                                                               // 1676
                var err = Error("Truncated");                                                                          // 1677
                err['truncated'] = true;                                                                               // 1678
                throw err;                                                                                             // 1679
            }                                                                                                          // 1680
            b = this.view[offset++];                                                                                   // 1681
            if (c < 5)                                                                                                 // 1682
                value |= (b & 0x7f) << (7*c);                                                                          // 1683
            ++c;                                                                                                       // 1684
        } while ((b & 0x80) !== 0);                                                                                    // 1685
        value |= 0;                                                                                                    // 1686
        if (relative) {                                                                                                // 1687
            this.offset = offset;                                                                                      // 1688
            return value;                                                                                              // 1689
        }                                                                                                              // 1690
        return {                                                                                                       // 1691
            "value": value,                                                                                            // 1692
            "length": c                                                                                                // 1693
        };                                                                                                             // 1694
    };                                                                                                                 // 1695
                                                                                                                       // 1696
    /**                                                                                                                // 1697
     * Reads a zig-zag encoded (signed) 32bit base 128 variable-length integer.                                        // 1698
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 1700
     * @returns {number|!{value: number, length: number}} The value read if offset is omitted, else the value read     // 1701
     *  and the actual number of bytes read.                                                                           // 1702
     * @throws {Error} If it's not a valid varint                                                                      // 1703
     * @expose                                                                                                         // 1704
     */                                                                                                                // 1705
    ByteBufferPrototype.readVarint32ZigZag = function(offset) {                                                        // 1706
        var val = this.readVarint32(offset);                                                                           // 1707
        if (typeof val === 'object')                                                                                   // 1708
            val["value"] = ByteBuffer.zigZagDecode32(val["value"]);                                                    // 1709
        else                                                                                                           // 1710
            val = ByteBuffer.zigZagDecode32(val);                                                                      // 1711
        return val;                                                                                                    // 1712
    };                                                                                                                 // 1713
                                                                                                                       // 1714
    // types/varints/varint64                                                                                          // 1715
                                                                                                                       // 1716
    if (Long) {                                                                                                        // 1717
                                                                                                                       // 1718
        /**                                                                                                            // 1719
         * Maximum number of bytes required to store a 64bit base 128 variable-length integer.                         // 1720
         * @type {number}                                                                                              // 1721
         * @const                                                                                                      // 1722
         * @expose                                                                                                     // 1723
         */                                                                                                            // 1724
        ByteBuffer.MAX_VARINT64_BYTES = 10;                                                                            // 1725
                                                                                                                       // 1726
        /**                                                                                                            // 1727
         * Calculates the actual number of bytes required to store a 64bit base 128 variable-length integer.           // 1728
         * @param {number|!Long} value Value to encode                                                                 // 1729
         * @returns {number} Number of bytes required. Capped to {@link ByteBuffer.MAX_VARINT64_BYTES}                 // 1730
         * @expose                                                                                                     // 1731
         */                                                                                                            // 1732
        ByteBuffer.calculateVarint64 = function(value) {                                                               // 1733
            if (typeof value === 'number')                                                                             // 1734
                value = Long.fromNumber(value);                                                                        // 1735
            else if (typeof value === 'string')                                                                        // 1736
                value = Long.fromString(value);                                                                        // 1737
            // ref: src/google/protobuf/io/coded_stream.cc                                                             // 1738
            var part0 = value.toInt() >>> 0,                                                                           // 1739
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,                                                    // 1740
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;                                                    // 1741
            if (part2 == 0) {                                                                                          // 1742
                if (part1 == 0) {                                                                                      // 1743
                    if (part0 < 1 << 14)                                                                               // 1744
                        return part0 < 1 << 7 ? 1 : 2;                                                                 // 1745
                    else                                                                                               // 1746
                        return part0 < 1 << 21 ? 3 : 4;                                                                // 1747
                } else {                                                                                               // 1748
                    if (part1 < 1 << 14)                                                                               // 1749
                        return part1 < 1 << 7 ? 5 : 6;                                                                 // 1750
                    else                                                                                               // 1751
                        return part1 < 1 << 21 ? 7 : 8;                                                                // 1752
                }                                                                                                      // 1753
            } else                                                                                                     // 1754
                return part2 < 1 << 7 ? 9 : 10;                                                                        // 1755
        };                                                                                                             // 1756
                                                                                                                       // 1757
        /**                                                                                                            // 1758
         * Zigzag encodes a signed 64bit integer so that it can be effectively used with varint encoding.              // 1759
         * @param {number|!Long} value Signed long                                                                     // 1760
         * @returns {!Long} Unsigned zigzag encoded long                                                               // 1761
         * @expose                                                                                                     // 1762
         */                                                                                                            // 1763
        ByteBuffer.zigZagEncode64 = function(value) {                                                                  // 1764
            if (typeof value === 'number')                                                                             // 1765
                value = Long.fromNumber(value, false);                                                                 // 1766
            else if (typeof value === 'string')                                                                        // 1767
                value = Long.fromString(value, false);                                                                 // 1768
            else if (value.unsigned !== false) value = value.toSigned();                                               // 1769
            // ref: src/google/protobuf/wire_format_lite.h                                                             // 1770
            return value.shiftLeft(1).xor(value.shiftRight(63)).toUnsigned();                                          // 1771
        };                                                                                                             // 1772
                                                                                                                       // 1773
        /**                                                                                                            // 1774
         * Decodes a zigzag encoded signed 64bit integer.                                                              // 1775
         * @param {!Long|number} value Unsigned zigzag encoded long or JavaScript number                               // 1776
         * @returns {!Long} Signed long                                                                                // 1777
         * @expose                                                                                                     // 1778
         */                                                                                                            // 1779
        ByteBuffer.zigZagDecode64 = function(value) {                                                                  // 1780
            if (typeof value === 'number')                                                                             // 1781
                value = Long.fromNumber(value, false);                                                                 // 1782
            else if (typeof value === 'string')                                                                        // 1783
                value = Long.fromString(value, false);                                                                 // 1784
            else if (value.unsigned !== false) value = value.toSigned();                                               // 1785
            // ref: src/google/protobuf/wire_format_lite.h                                                             // 1786
            return value.shiftRightUnsigned(1).xor(value.and(Long.ONE).toSigned().negate()).toSigned();                // 1787
        };                                                                                                             // 1788
                                                                                                                       // 1789
        /**                                                                                                            // 1790
         * Writes a 64bit base 128 variable-length integer.                                                            // 1791
         * @param {number|Long} value Value to write                                                                   // 1792
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.                                                                                        // 1794
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.         // 1795
         * @expose                                                                                                     // 1796
         */                                                                                                            // 1797
        ByteBufferPrototype.writeVarint64 = function(value, offset) {                                                  // 1798
            var relative = typeof offset === 'undefined';                                                              // 1799
            if (relative) offset = this.offset;                                                                        // 1800
            if (!this.noAssert) {                                                                                      // 1801
                if (typeof value === 'number')                                                                         // 1802
                    value = Long.fromNumber(value);                                                                    // 1803
                else if (typeof value === 'string')                                                                    // 1804
                    value = Long.fromString(value);                                                                    // 1805
                else if (!(value && value instanceof Long))                                                            // 1806
                    throw TypeError("Illegal value: "+value+" (not an integer or Long)");                              // 1807
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1808
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1809
                offset >>>= 0;                                                                                         // 1810
                if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                 // 1811
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);           // 1812
            }                                                                                                          // 1813
            if (typeof value === 'number')                                                                             // 1814
                value = Long.fromNumber(value, false);                                                                 // 1815
            else if (typeof value === 'string')                                                                        // 1816
                value = Long.fromString(value, false);                                                                 // 1817
            else if (value.unsigned !== false) value = value.toSigned();                                               // 1818
            var size = ByteBuffer.calculateVarint64(value),                                                            // 1819
                part0 = value.toInt() >>> 0,                                                                           // 1820
                part1 = value.shiftRightUnsigned(28).toInt() >>> 0,                                                    // 1821
                part2 = value.shiftRightUnsigned(56).toInt() >>> 0;                                                    // 1822
            offset += size;                                                                                            // 1823
            var capacity11 = this.buffer.byteLength;                                                                   // 1824
            if (offset > capacity11)                                                                                   // 1825
                this.resize((capacity11 *= 2) > offset ? capacity11 : offset);                                         // 1826
            offset -= size;                                                                                            // 1827
            switch (size) {                                                                                            // 1828
                case 10: this.view[offset+9] = (part2 >>>  7) & 0x01;                                                  // 1829
                case 9 : this.view[offset+8] = size !== 9 ? (part2       ) | 0x80 : (part2       ) & 0x7F;             // 1830
                case 8 : this.view[offset+7] = size !== 8 ? (part1 >>> 21) | 0x80 : (part1 >>> 21) & 0x7F;             // 1831
                case 7 : this.view[offset+6] = size !== 7 ? (part1 >>> 14) | 0x80 : (part1 >>> 14) & 0x7F;             // 1832
                case 6 : this.view[offset+5] = size !== 6 ? (part1 >>>  7) | 0x80 : (part1 >>>  7) & 0x7F;             // 1833
                case 5 : this.view[offset+4] = size !== 5 ? (part1       ) | 0x80 : (part1       ) & 0x7F;             // 1834
                case 4 : this.view[offset+3] = size !== 4 ? (part0 >>> 21) | 0x80 : (part0 >>> 21) & 0x7F;             // 1835
                case 3 : this.view[offset+2] = size !== 3 ? (part0 >>> 14) | 0x80 : (part0 >>> 14) & 0x7F;             // 1836
                case 2 : this.view[offset+1] = size !== 2 ? (part0 >>>  7) | 0x80 : (part0 >>>  7) & 0x7F;             // 1837
                case 1 : this.view[offset  ] = size !== 1 ? (part0       ) | 0x80 : (part0       ) & 0x7F;             // 1838
            }                                                                                                          // 1839
            if (relative) {                                                                                            // 1840
                this.offset += size;                                                                                   // 1841
                return this;                                                                                           // 1842
            } else {                                                                                                   // 1843
                return size;                                                                                           // 1844
            }                                                                                                          // 1845
        };                                                                                                             // 1846
                                                                                                                       // 1847
        /**                                                                                                            // 1848
         * Writes a zig-zag encoded 64bit base 128 variable-length integer.                                            // 1849
         * @param {number|Long} value Value to write                                                                   // 1850
         * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  written if omitted.                                                                                        // 1852
         * @returns {!ByteBuffer|number} `this` if offset is omitted, else the actual number of bytes written.         // 1853
         * @expose                                                                                                     // 1854
         */                                                                                                            // 1855
        ByteBufferPrototype.writeVarint64ZigZag = function(value, offset) {                                            // 1856
            return this.writeVarint64(ByteBuffer.zigZagEncode64(value), offset);                                       // 1857
        };                                                                                                             // 1858
                                                                                                                       // 1859
        /**                                                                                                            // 1860
         * Reads a 64bit base 128 variable-length integer. Requires Long.js.                                           // 1861
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.                                                                                           // 1863
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.                                                                           // 1865
         * @throws {Error} If it's not a valid varint                                                                  // 1866
         * @expose                                                                                                     // 1867
         */                                                                                                            // 1868
        ByteBufferPrototype.readVarint64 = function(offset) {                                                          // 1869
            var relative = typeof offset === 'undefined';                                                              // 1870
            if (relative) offset = this.offset;                                                                        // 1871
            if (!this.noAssert) {                                                                                      // 1872
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 1873
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 1874
                offset >>>= 0;                                                                                         // 1875
                if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                 // 1876
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);           // 1877
            }                                                                                                          // 1878
            // ref: src/google/protobuf/io/coded_stream.cc                                                             // 1879
            var start = offset,                                                                                        // 1880
                part0 = 0,                                                                                             // 1881
                part1 = 0,                                                                                             // 1882
                part2 = 0,                                                                                             // 1883
                b  = 0;                                                                                                // 1884
            b = this.view[offset++]; part0  = (b & 0x7F)      ; if ( b & 0x80                                                   ) {
            b = this.view[offset++]; part0 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part0 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 14; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part1 |= (b & 0x7F) << 21; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2  = (b & 0x7F)      ; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            b = this.view[offset++]; part2 |= (b & 0x7F) <<  7; if ((b & 0x80) || (this.noAssert && typeof b === 'undefined')) {
            throw Error("Buffer overrun"); }}}}}}}}}}                                                                  // 1895
            var value = Long.fromBits(part0 | (part1 << 28), (part1 >>> 4) | (part2) << 24, false);                    // 1896
            if (relative) {                                                                                            // 1897
                this.offset = offset;                                                                                  // 1898
                return value;                                                                                          // 1899
            } else {                                                                                                   // 1900
                return {                                                                                               // 1901
                    'value': value,                                                                                    // 1902
                    'length': offset-start                                                                             // 1903
                };                                                                                                     // 1904
            }                                                                                                          // 1905
        };                                                                                                             // 1906
                                                                                                                       // 1907
        /**                                                                                                            // 1908
         * Reads a zig-zag encoded 64bit base 128 variable-length integer. Requires Long.js.                           // 1909
         * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
         *  read if omitted.                                                                                           // 1911
         * @returns {!Long|!{value: Long, length: number}} The value read if offset is omitted, else the value read and
         *  the actual number of bytes read.                                                                           // 1913
         * @throws {Error} If it's not a valid varint                                                                  // 1914
         * @expose                                                                                                     // 1915
         */                                                                                                            // 1916
        ByteBufferPrototype.readVarint64ZigZag = function(offset) {                                                    // 1917
            var val = this.readVarint64(offset);                                                                       // 1918
            if (val && val['value'] instanceof Long)                                                                   // 1919
                val["value"] = ByteBuffer.zigZagDecode64(val["value"]);                                                // 1920
            else                                                                                                       // 1921
                val = ByteBuffer.zigZagDecode64(val);                                                                  // 1922
            return val;                                                                                                // 1923
        };                                                                                                             // 1924
                                                                                                                       // 1925
    } // Long                                                                                                          // 1926
                                                                                                                       // 1927
                                                                                                                       // 1928
    // types/strings/cstring                                                                                           // 1929
                                                                                                                       // 1930
    /**                                                                                                                // 1931
     * Writes a NULL-terminated UTF8 encoded string. For this to work the specified string must not contain any NULL   // 1932
     *  characters itself.                                                                                             // 1933
     * @param {string} str String to write                                                                             // 1934
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  contained in `str` + 1 if omitted.                                                                             // 1936
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written                // 1937
     * @expose                                                                                                         // 1938
     */                                                                                                                // 1939
    ByteBufferPrototype.writeCString = function(str, offset) {                                                         // 1940
        var relative = typeof offset === 'undefined';                                                                  // 1941
        if (relative) offset = this.offset;                                                                            // 1942
        var i,                                                                                                         // 1943
            k = str.length;                                                                                            // 1944
        if (!this.noAssert) {                                                                                          // 1945
            if (typeof str !== 'string')                                                                               // 1946
                throw TypeError("Illegal str: Not a string");                                                          // 1947
            for (i=0; i<k; ++i) {                                                                                      // 1948
                if (str.charCodeAt(i) === 0)                                                                           // 1949
                    throw RangeError("Illegal str: Contains NULL-characters");                                         // 1950
            }                                                                                                          // 1951
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1952
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1953
            offset >>>= 0;                                                                                             // 1954
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 1955
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 1956
        }                                                                                                              // 1957
        // UTF8 strings do not contain zero bytes in between except for the zero character, so:                        // 1958
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];                                                           // 1959
        offset += k+1;                                                                                                 // 1960
        var capacity12 = this.buffer.byteLength;                                                                       // 1961
        if (offset > capacity12)                                                                                       // 1962
            this.resize((capacity12 *= 2) > offset ? capacity12 : offset);                                             // 1963
        offset -= k+1;                                                                                                 // 1964
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {                                                        // 1965
            this.view[offset++] = b;                                                                                   // 1966
        }.bind(this));                                                                                                 // 1967
        this.view[offset++] = 0;                                                                                       // 1968
        if (relative) {                                                                                                // 1969
            this.offset = offset;                                                                                      // 1970
            return this;                                                                                               // 1971
        }                                                                                                              // 1972
        return k;                                                                                                      // 1973
    };                                                                                                                 // 1974
                                                                                                                       // 1975
    /**                                                                                                                // 1976
     * Reads a NULL-terminated UTF8 encoded string. For this to work the string read must not contain any NULL characters
     *  itself.                                                                                                        // 1978
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 1980
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string       // 1981
     *  read and the actual number of bytes read.                                                                      // 1982
     * @expose                                                                                                         // 1983
     */                                                                                                                // 1984
    ByteBufferPrototype.readCString = function(offset) {                                                               // 1985
        var relative = typeof offset === 'undefined';                                                                  // 1986
        if (relative) offset = this.offset;                                                                            // 1987
        if (!this.noAssert) {                                                                                          // 1988
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 1989
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 1990
            offset >>>= 0;                                                                                             // 1991
            if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                     // 1992
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);               // 1993
        }                                                                                                              // 1994
        var start = offset,                                                                                            // 1995
            temp;                                                                                                      // 1996
        // UTF8 strings do not contain zero bytes in between except for the zero character itself, so:                 // 1997
        var sd, b = -1;                                                                                                // 1998
        utfx.decodeUTF8toUTF16(function() {                                                                            // 1999
            if (b === 0) return null;                                                                                  // 2000
            if (offset >= this.limit)                                                                                  // 2001
                throw RangeError("Illegal range: Truncated data, "+offset+" < "+this.limit);                           // 2002
            b = this.view[offset++];                                                                                   // 2003
            return b === 0 ? null : b;                                                                                 // 2004
        }.bind(this), sd = stringDestination(), true);                                                                 // 2005
        if (relative) {                                                                                                // 2006
            this.offset = offset;                                                                                      // 2007
            return sd();                                                                                               // 2008
        } else {                                                                                                       // 2009
            return {                                                                                                   // 2010
                "string": sd(),                                                                                        // 2011
                "length": offset - start                                                                               // 2012
            };                                                                                                         // 2013
        }                                                                                                              // 2014
    };                                                                                                                 // 2015
                                                                                                                       // 2016
    // types/strings/istring                                                                                           // 2017
                                                                                                                       // 2018
    /**                                                                                                                // 2019
     * Writes a length as uint32 prefixed UTF8 encoded string.                                                         // 2020
     * @param {string} str String to write                                                                             // 2021
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 2023
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written            // 2024
     * @expose                                                                                                         // 2025
     * @see ByteBuffer#writeVarint32                                                                                   // 2026
     */                                                                                                                // 2027
    ByteBufferPrototype.writeIString = function(str, offset) {                                                         // 2028
        var relative = typeof offset === 'undefined';                                                                  // 2029
        if (relative) offset = this.offset;                                                                            // 2030
        if (!this.noAssert) {                                                                                          // 2031
            if (typeof str !== 'string')                                                                               // 2032
                throw TypeError("Illegal str: Not a string");                                                          // 2033
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2034
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2035
            offset >>>= 0;                                                                                             // 2036
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2037
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2038
        }                                                                                                              // 2039
        var start = offset,                                                                                            // 2040
            k;                                                                                                         // 2041
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];                                            // 2042
        offset += 4+k;                                                                                                 // 2043
        var capacity13 = this.buffer.byteLength;                                                                       // 2044
        if (offset > capacity13)                                                                                       // 2045
            this.resize((capacity13 *= 2) > offset ? capacity13 : offset);                                             // 2046
        offset -= 4+k;                                                                                                 // 2047
        if (this.littleEndian) {                                                                                       // 2048
            this.view[offset+3] = (k >>> 24) & 0xFF;                                                                   // 2049
            this.view[offset+2] = (k >>> 16) & 0xFF;                                                                   // 2050
            this.view[offset+1] = (k >>>  8) & 0xFF;                                                                   // 2051
            this.view[offset  ] =  k         & 0xFF;                                                                   // 2052
        } else {                                                                                                       // 2053
            this.view[offset  ] = (k >>> 24) & 0xFF;                                                                   // 2054
            this.view[offset+1] = (k >>> 16) & 0xFF;                                                                   // 2055
            this.view[offset+2] = (k >>>  8) & 0xFF;                                                                   // 2056
            this.view[offset+3] =  k         & 0xFF;                                                                   // 2057
        }                                                                                                              // 2058
        offset += 4;                                                                                                   // 2059
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {                                                        // 2060
            this.view[offset++] = b;                                                                                   // 2061
        }.bind(this));                                                                                                 // 2062
        if (offset !== start + 4 + k)                                                                                  // 2063
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+4+k));                            // 2064
        if (relative) {                                                                                                // 2065
            this.offset = offset;                                                                                      // 2066
            return this;                                                                                               // 2067
        }                                                                                                              // 2068
        return offset - start;                                                                                         // 2069
    };                                                                                                                 // 2070
                                                                                                                       // 2071
    /**                                                                                                                // 2072
     * Reads a length as uint32 prefixed UTF8 encoded string.                                                          // 2073
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 2075
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string       // 2076
     *  read and the actual number of bytes read.                                                                      // 2077
     * @expose                                                                                                         // 2078
     * @see ByteBuffer#readVarint32                                                                                    // 2079
     */                                                                                                                // 2080
    ByteBufferPrototype.readIString = function(offset) {                                                               // 2081
        var relative = typeof offset === 'undefined';                                                                  // 2082
        if (relative) offset = this.offset;                                                                            // 2083
        if (!this.noAssert) {                                                                                          // 2084
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2085
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2086
            offset >>>= 0;                                                                                             // 2087
            if (offset < 0 || offset + 4 > this.buffer.byteLength)                                                     // 2088
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+4+") <= "+this.buffer.byteLength);               // 2089
        }                                                                                                              // 2090
        var start = offset;                                                                                            // 2091
        var len = this.readUint32(offset);                                                                             // 2092
        var str = this.readUTF8String(len, ByteBuffer.METRICS_BYTES, offset += 4);                                     // 2093
        offset += str['length'];                                                                                       // 2094
        if (relative) {                                                                                                // 2095
            this.offset = offset;                                                                                      // 2096
            return str['string'];                                                                                      // 2097
        } else {                                                                                                       // 2098
            return {                                                                                                   // 2099
                'string': str['string'],                                                                               // 2100
                'length': offset - start                                                                               // 2101
            };                                                                                                         // 2102
        }                                                                                                              // 2103
    };                                                                                                                 // 2104
                                                                                                                       // 2105
    // types/strings/utf8string                                                                                        // 2106
                                                                                                                       // 2107
    /**                                                                                                                // 2108
     * Metrics representing number of UTF8 characters. Evaluates to `c`.                                               // 2109
     * @type {string}                                                                                                  // 2110
     * @const                                                                                                          // 2111
     * @expose                                                                                                         // 2112
     */                                                                                                                // 2113
    ByteBuffer.METRICS_CHARS = 'c';                                                                                    // 2114
                                                                                                                       // 2115
    /**                                                                                                                // 2116
     * Metrics representing number of bytes. Evaluates to `b`.                                                         // 2117
     * @type {string}                                                                                                  // 2118
     * @const                                                                                                          // 2119
     * @expose                                                                                                         // 2120
     */                                                                                                                // 2121
    ByteBuffer.METRICS_BYTES = 'b';                                                                                    // 2122
                                                                                                                       // 2123
    /**                                                                                                                // 2124
     * Writes an UTF8 encoded string.                                                                                  // 2125
     * @param {string} str String to write                                                                             // 2126
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.         // 2127
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.               // 2128
     * @expose                                                                                                         // 2129
     */                                                                                                                // 2130
    ByteBufferPrototype.writeUTF8String = function(str, offset) {                                                      // 2131
        var relative = typeof offset === 'undefined';                                                                  // 2132
        if (relative) offset = this.offset;                                                                            // 2133
        if (!this.noAssert) {                                                                                          // 2134
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2135
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2136
            offset >>>= 0;                                                                                             // 2137
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2138
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2139
        }                                                                                                              // 2140
        var k;                                                                                                         // 2141
        var start = offset;                                                                                            // 2142
        k = utfx.calculateUTF16asUTF8(stringSource(str))[1];                                                           // 2143
        offset += k;                                                                                                   // 2144
        var capacity14 = this.buffer.byteLength;                                                                       // 2145
        if (offset > capacity14)                                                                                       // 2146
            this.resize((capacity14 *= 2) > offset ? capacity14 : offset);                                             // 2147
        offset -= k;                                                                                                   // 2148
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {                                                        // 2149
            this.view[offset++] = b;                                                                                   // 2150
        }.bind(this));                                                                                                 // 2151
        if (relative) {                                                                                                // 2152
            this.offset = offset;                                                                                      // 2153
            return this;                                                                                               // 2154
        }                                                                                                              // 2155
        return offset - start;                                                                                         // 2156
    };                                                                                                                 // 2157
                                                                                                                       // 2158
    /**                                                                                                                // 2159
     * Writes an UTF8 encoded string. This is an alias of {@link ByteBuffer#writeUTF8String}.                          // 2160
     * @function                                                                                                       // 2161
     * @param {string} str String to write                                                                             // 2162
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} if omitted.         // 2163
     * @returns {!ByteBuffer|number} this if offset is omitted, else the actual number of bytes written.               // 2164
     * @expose                                                                                                         // 2165
     */                                                                                                                // 2166
    ByteBufferPrototype.writeString = ByteBufferPrototype.writeUTF8String;                                             // 2167
                                                                                                                       // 2168
    /**                                                                                                                // 2169
     * Calculates the number of UTF8 characters of a string. JavaScript itself uses UTF-16, so that a string's         // 2170
     *  `length` property does not reflect its actual UTF8 size if it contains code points larger than 0xFFFF.         // 2171
     * @param {string} str String to calculate                                                                         // 2172
     * @returns {number} Number of UTF8 characters                                                                     // 2173
     * @expose                                                                                                         // 2174
     */                                                                                                                // 2175
    ByteBuffer.calculateUTF8Chars = function(str) {                                                                    // 2176
        return utfx.calculateUTF16asUTF8(stringSource(str))[0];                                                        // 2177
    };                                                                                                                 // 2178
                                                                                                                       // 2179
    /**                                                                                                                // 2180
     * Calculates the number of UTF8 bytes of a string.                                                                // 2181
     * @param {string} str String to calculate                                                                         // 2182
     * @returns {number} Number of UTF8 bytes                                                                          // 2183
     * @expose                                                                                                         // 2184
     */                                                                                                                // 2185
    ByteBuffer.calculateUTF8Bytes = function(str) {                                                                    // 2186
        return utfx.calculateUTF16asUTF8(stringSource(str))[1];                                                        // 2187
    };                                                                                                                 // 2188
                                                                                                                       // 2189
    /**                                                                                                                // 2190
     * Calculates the number of UTF8 bytes of a string. This is an alias of {@link ByteBuffer.calculateUTF8Bytes}.     // 2191
     * @function                                                                                                       // 2192
     * @param {string} str String to calculate                                                                         // 2193
     * @returns {number} Number of UTF8 bytes                                                                          // 2194
     * @expose                                                                                                         // 2195
     */                                                                                                                // 2196
    ByteBuffer.calculateString = ByteBuffer.calculateUTF8Bytes;                                                        // 2197
                                                                                                                       // 2198
    /**                                                                                                                // 2199
     * Reads an UTF8 encoded string.                                                                                   // 2200
     * @param {number} length Number of characters or bytes to read.                                                   // 2201
     * @param {string=} metrics Metrics specifying what `length` is meant to count. Defaults to                        // 2202
     *  {@link ByteBuffer.METRICS_CHARS}.                                                                              // 2203
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 2205
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string       // 2206
     *  read and the actual number of bytes read.                                                                      // 2207
     * @expose                                                                                                         // 2208
     */                                                                                                                // 2209
    ByteBufferPrototype.readUTF8String = function(length, metrics, offset) {                                           // 2210
        if (typeof metrics === 'number') {                                                                             // 2211
            offset = metrics;                                                                                          // 2212
            metrics = undefined;                                                                                       // 2213
        }                                                                                                              // 2214
        var relative = typeof offset === 'undefined';                                                                  // 2215
        if (relative) offset = this.offset;                                                                            // 2216
        if (typeof metrics === 'undefined') metrics = ByteBuffer.METRICS_CHARS;                                        // 2217
        if (!this.noAssert) {                                                                                          // 2218
            if (typeof length !== 'number' || length % 1 !== 0)                                                        // 2219
                throw TypeError("Illegal length: "+length+" (not an integer)");                                        // 2220
            length |= 0;                                                                                               // 2221
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2222
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2223
            offset >>>= 0;                                                                                             // 2224
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2225
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2226
        }                                                                                                              // 2227
        var i = 0,                                                                                                     // 2228
            start = offset,                                                                                            // 2229
            sd;                                                                                                        // 2230
        if (metrics === ByteBuffer.METRICS_CHARS) { // The same for node and the browser                               // 2231
            sd = stringDestination();                                                                                  // 2232
            utfx.decodeUTF8(function() {                                                                               // 2233
                return i < length && offset < this.limit ? this.view[offset++] : null;                                 // 2234
            }.bind(this), function(cp) {                                                                               // 2235
                ++i; utfx.UTF8toUTF16(cp, sd);                                                                         // 2236
            });                                                                                                        // 2237
            if (i !== length)                                                                                          // 2238
                throw RangeError("Illegal range: Truncated data, "+i+" == "+length);                                   // 2239
            if (relative) {                                                                                            // 2240
                this.offset = offset;                                                                                  // 2241
                return sd();                                                                                           // 2242
            } else {                                                                                                   // 2243
                return {                                                                                               // 2244
                    "string": sd(),                                                                                    // 2245
                    "length": offset - start                                                                           // 2246
                };                                                                                                     // 2247
            }                                                                                                          // 2248
        } else if (metrics === ByteBuffer.METRICS_BYTES) {                                                             // 2249
            if (!this.noAssert) {                                                                                      // 2250
                if (typeof offset !== 'number' || offset % 1 !== 0)                                                    // 2251
                    throw TypeError("Illegal offset: "+offset+" (not an integer)");                                    // 2252
                offset >>>= 0;                                                                                         // 2253
                if (offset < 0 || offset + length > this.buffer.byteLength)                                            // 2254
                    throw RangeError("Illegal offset: 0 <= "+offset+" (+"+length+") <= "+this.buffer.byteLength);      // 2255
            }                                                                                                          // 2256
            var k = offset + length;                                                                                   // 2257
            utfx.decodeUTF8toUTF16(function() {                                                                        // 2258
                return offset < k ? this.view[offset++] : null;                                                        // 2259
            }.bind(this), sd = stringDestination(), this.noAssert);                                                    // 2260
            if (offset !== k)                                                                                          // 2261
                throw RangeError("Illegal range: Truncated data, "+offset+" == "+k);                                   // 2262
            if (relative) {                                                                                            // 2263
                this.offset = offset;                                                                                  // 2264
                return sd();                                                                                           // 2265
            } else {                                                                                                   // 2266
                return {                                                                                               // 2267
                    'string': sd(),                                                                                    // 2268
                    'length': offset - start                                                                           // 2269
                };                                                                                                     // 2270
            }                                                                                                          // 2271
        } else                                                                                                         // 2272
            throw TypeError("Unsupported metrics: "+metrics);                                                          // 2273
    };                                                                                                                 // 2274
                                                                                                                       // 2275
    /**                                                                                                                // 2276
     * Reads an UTF8 encoded string. This is an alias of {@link ByteBuffer#readUTF8String}.                            // 2277
     * @function                                                                                                       // 2278
     * @param {number} length Number of characters or bytes to read                                                    // 2279
     * @param {number=} metrics Metrics specifying what `n` is meant to count. Defaults to                             // 2280
     *  {@link ByteBuffer.METRICS_CHARS}.                                                                              // 2281
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 2283
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string       // 2284
     *  read and the actual number of bytes read.                                                                      // 2285
     * @expose                                                                                                         // 2286
     */                                                                                                                // 2287
    ByteBufferPrototype.readString = ByteBufferPrototype.readUTF8String;                                               // 2288
                                                                                                                       // 2289
    // types/strings/vstring                                                                                           // 2290
                                                                                                                       // 2291
    /**                                                                                                                // 2292
     * Writes a length as varint32 prefixed UTF8 encoded string.                                                       // 2293
     * @param {string} str String to write                                                                             // 2294
     * @param {number=} offset Offset to write to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 2296
     * @returns {!ByteBuffer|number} `this` if `offset` is omitted, else the actual number of bytes written            // 2297
     * @expose                                                                                                         // 2298
     * @see ByteBuffer#writeVarint32                                                                                   // 2299
     */                                                                                                                // 2300
    ByteBufferPrototype.writeVString = function(str, offset) {                                                         // 2301
        var relative = typeof offset === 'undefined';                                                                  // 2302
        if (relative) offset = this.offset;                                                                            // 2303
        if (!this.noAssert) {                                                                                          // 2304
            if (typeof str !== 'string')                                                                               // 2305
                throw TypeError("Illegal str: Not a string");                                                          // 2306
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2307
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2308
            offset >>>= 0;                                                                                             // 2309
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2310
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2311
        }                                                                                                              // 2312
        var start = offset,                                                                                            // 2313
            k, l;                                                                                                      // 2314
        k = utfx.calculateUTF16asUTF8(stringSource(str), this.noAssert)[1];                                            // 2315
        l = ByteBuffer.calculateVarint32(k);                                                                           // 2316
        offset += l+k;                                                                                                 // 2317
        var capacity15 = this.buffer.byteLength;                                                                       // 2318
        if (offset > capacity15)                                                                                       // 2319
            this.resize((capacity15 *= 2) > offset ? capacity15 : offset);                                             // 2320
        offset -= l+k;                                                                                                 // 2321
        offset += this.writeVarint32(k, offset);                                                                       // 2322
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {                                                        // 2323
            this.view[offset++] = b;                                                                                   // 2324
        }.bind(this));                                                                                                 // 2325
        if (offset !== start+k+l)                                                                                      // 2326
            throw RangeError("Illegal range: Truncated data, "+offset+" == "+(offset+k+l));                            // 2327
        if (relative) {                                                                                                // 2328
            this.offset = offset;                                                                                      // 2329
            return this;                                                                                               // 2330
        }                                                                                                              // 2331
        return offset - start;                                                                                         // 2332
    };                                                                                                                 // 2333
                                                                                                                       // 2334
    /**                                                                                                                // 2335
     * Reads a length as varint32 prefixed UTF8 encoded string.                                                        // 2336
     * @param {number=} offset Offset to read from. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 2338
     * @returns {string|!{string: string, length: number}} The string read if offset is omitted, else the string       // 2339
     *  read and the actual number of bytes read.                                                                      // 2340
     * @expose                                                                                                         // 2341
     * @see ByteBuffer#readVarint32                                                                                    // 2342
     */                                                                                                                // 2343
    ByteBufferPrototype.readVString = function(offset) {                                                               // 2344
        var relative = typeof offset === 'undefined';                                                                  // 2345
        if (relative) offset = this.offset;                                                                            // 2346
        if (!this.noAssert) {                                                                                          // 2347
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2348
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2349
            offset >>>= 0;                                                                                             // 2350
            if (offset < 0 || offset + 1 > this.buffer.byteLength)                                                     // 2351
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+1+") <= "+this.buffer.byteLength);               // 2352
        }                                                                                                              // 2353
        var start = offset;                                                                                            // 2354
        var len = this.readVarint32(offset);                                                                           // 2355
        var str = this.readUTF8String(len['value'], ByteBuffer.METRICS_BYTES, offset += len['length']);                // 2356
        offset += str['length'];                                                                                       // 2357
        if (relative) {                                                                                                // 2358
            this.offset = offset;                                                                                      // 2359
            return str['string'];                                                                                      // 2360
        } else {                                                                                                       // 2361
            return {                                                                                                   // 2362
                'string': str['string'],                                                                               // 2363
                'length': offset - start                                                                               // 2364
            };                                                                                                         // 2365
        }                                                                                                              // 2366
    };                                                                                                                 // 2367
                                                                                                                       // 2368
                                                                                                                       // 2369
    /**                                                                                                                // 2370
     * Appends some data to this ByteBuffer. This will overwrite any contents behind the specified offset up to the appended
     *  data's length.                                                                                                 // 2372
     * @param {!ByteBuffer|!ArrayBuffer|!Uint8Array|string} source Data to append. If `source` is a ByteBuffer, its offsets
     *  will be modified according to the performed read operation.                                                    // 2374
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to append at. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  written if omitted.                                                                                            // 2377
     * @returns {!ByteBuffer} this                                                                                     // 2378
     * @expose                                                                                                         // 2379
     * @example A relative `<01 02>03.append(<04 05>)` will result in `<01 02 04 05>, 04 05|`                          // 2380
     * @example An absolute `<01 02>03.append(04 05>, 1)` will result in `<01 04>05, 04 05|`                           // 2381
     */                                                                                                                // 2382
    ByteBufferPrototype.append = function(source, encoding, offset) {                                                  // 2383
        if (typeof encoding === 'number' || typeof encoding !== 'string') {                                            // 2384
            offset = encoding;                                                                                         // 2385
            encoding = undefined;                                                                                      // 2386
        }                                                                                                              // 2387
        var relative = typeof offset === 'undefined';                                                                  // 2388
        if (relative) offset = this.offset;                                                                            // 2389
        if (!this.noAssert) {                                                                                          // 2390
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2391
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2392
            offset >>>= 0;                                                                                             // 2393
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2394
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2395
        }                                                                                                              // 2396
        if (!(source instanceof ByteBuffer))                                                                           // 2397
            source = ByteBuffer.wrap(source, encoding);                                                                // 2398
        var length = source.limit - source.offset;                                                                     // 2399
        if (length <= 0) return this; // Nothing to append                                                             // 2400
        offset += length;                                                                                              // 2401
        var capacity16 = this.buffer.byteLength;                                                                       // 2402
        if (offset > capacity16)                                                                                       // 2403
            this.resize((capacity16 *= 2) > offset ? capacity16 : offset);                                             // 2404
        offset -= length;                                                                                              // 2405
        this.view.set(source.view.subarray(source.offset, source.limit), offset);                                      // 2406
        source.offset += length;                                                                                       // 2407
        if (relative) this.offset += length;                                                                           // 2408
        return this;                                                                                                   // 2409
    };                                                                                                                 // 2410
                                                                                                                       // 2411
    /**                                                                                                                // 2412
     * Appends this ByteBuffer's contents to another ByteBuffer. This will overwrite any contents at and after the     // 2413
        specified offset up to the length of this ByteBuffer's data.                                                   // 2414
     * @param {!ByteBuffer} target Target ByteBuffer                                                                   // 2415
     * @param {number=} offset Offset to append to. Will use and increase {@link ByteBuffer#offset} by the number of bytes
     *  read if omitted.                                                                                               // 2417
     * @returns {!ByteBuffer} this                                                                                     // 2418
     * @expose                                                                                                         // 2419
     * @see ByteBuffer#append                                                                                          // 2420
     */                                                                                                                // 2421
    ByteBufferPrototype.appendTo = function(target, offset) {                                                          // 2422
        target.append(this, offset);                                                                                   // 2423
        return this;                                                                                                   // 2424
    };                                                                                                                 // 2425
                                                                                                                       // 2426
    /**                                                                                                                // 2427
     * Enables or disables assertions of argument types and offsets. Assertions are enabled by default but you can opt to
     *  disable them if your code already makes sure that everything is valid.                                         // 2429
     * @param {boolean} assert `true` to enable assertions, otherwise `false`                                          // 2430
     * @returns {!ByteBuffer} this                                                                                     // 2431
     * @expose                                                                                                         // 2432
     */                                                                                                                // 2433
    ByteBufferPrototype.assert = function(assert) {                                                                    // 2434
        this.noAssert = !assert;                                                                                       // 2435
        return this;                                                                                                   // 2436
    };                                                                                                                 // 2437
                                                                                                                       // 2438
    /**                                                                                                                // 2439
     * Gets the capacity of this ByteBuffer's backing buffer.                                                          // 2440
     * @returns {number} Capacity of the backing buffer                                                                // 2441
     * @expose                                                                                                         // 2442
     */                                                                                                                // 2443
    ByteBufferPrototype.capacity = function() {                                                                        // 2444
        return this.buffer.byteLength;                                                                                 // 2445
    };                                                                                                                 // 2446
    /**                                                                                                                // 2447
     * Clears this ByteBuffer's offsets by setting {@link ByteBuffer#offset} to `0` and {@link ByteBuffer#limit} to the
     *  backing buffer's capacity. Discards {@link ByteBuffer#markedOffset}.                                           // 2449
     * @returns {!ByteBuffer} this                                                                                     // 2450
     * @expose                                                                                                         // 2451
     */                                                                                                                // 2452
    ByteBufferPrototype.clear = function() {                                                                           // 2453
        this.offset = 0;                                                                                               // 2454
        this.limit = this.buffer.byteLength;                                                                           // 2455
        this.markedOffset = -1;                                                                                        // 2456
        return this;                                                                                                   // 2457
    };                                                                                                                 // 2458
                                                                                                                       // 2459
    /**                                                                                                                // 2460
     * Creates a cloned instance of this ByteBuffer, preset with this ByteBuffer's values for {@link ByteBuffer#offset},
     *  {@link ByteBuffer#markedOffset} and {@link ByteBuffer#limit}.                                                  // 2462
     * @param {boolean=} copy Whether to copy the backing buffer or to return another view on the same, defaults to `false`
     * @returns {!ByteBuffer} Cloned instance                                                                          // 2464
     * @expose                                                                                                         // 2465
     */                                                                                                                // 2466
    ByteBufferPrototype.clone = function(copy) {                                                                       // 2467
        var bb = new ByteBuffer(0, this.littleEndian, this.noAssert);                                                  // 2468
        if (copy) {                                                                                                    // 2469
            bb.buffer = new ArrayBuffer(this.buffer.byteLength);                                                       // 2470
            bb.view = new Uint8Array(bb.buffer);                                                                       // 2471
        } else {                                                                                                       // 2472
            bb.buffer = this.buffer;                                                                                   // 2473
            bb.view = this.view;                                                                                       // 2474
        }                                                                                                              // 2475
        bb.offset = this.offset;                                                                                       // 2476
        bb.markedOffset = this.markedOffset;                                                                           // 2477
        bb.limit = this.limit;                                                                                         // 2478
        return bb;                                                                                                     // 2479
    };                                                                                                                 // 2480
                                                                                                                       // 2481
    /**                                                                                                                // 2482
     * Compacts this ByteBuffer to be backed by a {@link ByteBuffer#buffer} of its contents' length. Contents are the bytes
     *  between {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. Will set `offset = 0` and `limit = capacity` and
     *  adapt {@link ByteBuffer#markedOffset} to the same relative position if set.                                    // 2485
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}                                // 2486
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}                                     // 2487
     * @returns {!ByteBuffer} this                                                                                     // 2488
     * @expose                                                                                                         // 2489
     */                                                                                                                // 2490
    ByteBufferPrototype.compact = function(begin, end) {                                                               // 2491
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 2492
        if (typeof end === 'undefined') end = this.limit;                                                              // 2493
        if (!this.noAssert) {                                                                                          // 2494
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 2495
                throw TypeError("Illegal begin: Not an integer");                                                      // 2496
            begin >>>= 0;                                                                                              // 2497
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 2498
                throw TypeError("Illegal end: Not an integer");                                                        // 2499
            end >>>= 0;                                                                                                // 2500
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 2501
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 2502
        }                                                                                                              // 2503
        if (begin === 0 && end === this.buffer.byteLength)                                                             // 2504
            return this; // Already compacted                                                                          // 2505
        var len = end - begin;                                                                                         // 2506
        if (len === 0) {                                                                                               // 2507
            this.buffer = EMPTY_BUFFER;                                                                                // 2508
            this.view = null;                                                                                          // 2509
            if (this.markedOffset >= 0) this.markedOffset -= begin;                                                    // 2510
            this.offset = 0;                                                                                           // 2511
            this.limit = 0;                                                                                            // 2512
            return this;                                                                                               // 2513
        }                                                                                                              // 2514
        var buffer = new ArrayBuffer(len);                                                                             // 2515
        var view = new Uint8Array(buffer);                                                                             // 2516
        view.set(this.view.subarray(begin, end));                                                                      // 2517
        this.buffer = buffer;                                                                                          // 2518
        this.view = view;                                                                                              // 2519
        if (this.markedOffset >= 0) this.markedOffset -= begin;                                                        // 2520
        this.offset = 0;                                                                                               // 2521
        this.limit = len;                                                                                              // 2522
        return this;                                                                                                   // 2523
    };                                                                                                                 // 2524
                                                                                                                       // 2525
    /**                                                                                                                // 2526
     * Creates a copy of this ByteBuffer's contents. Contents are the bytes between {@link ByteBuffer#offset} and      // 2527
     *  {@link ByteBuffer#limit}.                                                                                      // 2528
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.                                     // 2529
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.                                          // 2530
     * @returns {!ByteBuffer} Copy                                                                                     // 2531
     * @expose                                                                                                         // 2532
     */                                                                                                                // 2533
    ByteBufferPrototype.copy = function(begin, end) {                                                                  // 2534
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 2535
        if (typeof end === 'undefined') end = this.limit;                                                              // 2536
        if (!this.noAssert) {                                                                                          // 2537
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 2538
                throw TypeError("Illegal begin: Not an integer");                                                      // 2539
            begin >>>= 0;                                                                                              // 2540
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 2541
                throw TypeError("Illegal end: Not an integer");                                                        // 2542
            end >>>= 0;                                                                                                // 2543
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 2544
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 2545
        }                                                                                                              // 2546
        if (begin === end)                                                                                             // 2547
            return new ByteBuffer(0, this.littleEndian, this.noAssert);                                                // 2548
        var capacity = end - begin,                                                                                    // 2549
            bb = new ByteBuffer(capacity, this.littleEndian, this.noAssert);                                           // 2550
        bb.offset = 0;                                                                                                 // 2551
        bb.limit = capacity;                                                                                           // 2552
        if (bb.markedOffset >= 0) bb.markedOffset -= begin;                                                            // 2553
        this.copyTo(bb, 0, begin, end);                                                                                // 2554
        return bb;                                                                                                     // 2555
    };                                                                                                                 // 2556
                                                                                                                       // 2557
    /**                                                                                                                // 2558
     * Copies this ByteBuffer's contents to another ByteBuffer. Contents are the bytes between {@link ByteBuffer#offset} and
     *  {@link ByteBuffer#limit}.                                                                                      // 2560
     * @param {!ByteBuffer} target Target ByteBuffer                                                                   // 2561
     * @param {number=} targetOffset Offset to copy to. Will use and increase the target's {@link ByteBuffer#offset}   // 2562
     *  by the number of bytes copied if omitted.                                                                      // 2563
     * @param {number=} sourceOffset Offset to start copying from. Will use and increase {@link ByteBuffer#offset} by the
     *  number of bytes copied if omitted.                                                                             // 2565
     * @param {number=} sourceLimit Offset to end copying from, defaults to {@link ByteBuffer#limit}                   // 2566
     * @returns {!ByteBuffer} this                                                                                     // 2567
     * @expose                                                                                                         // 2568
     */                                                                                                                // 2569
    ByteBufferPrototype.copyTo = function(target, targetOffset, sourceOffset, sourceLimit) {                           // 2570
        var relative,                                                                                                  // 2571
            targetRelative;                                                                                            // 2572
        if (!this.noAssert) {                                                                                          // 2573
            if (!ByteBuffer.isByteBuffer(target))                                                                      // 2574
                throw TypeError("Illegal target: Not a ByteBuffer");                                                   // 2575
        }                                                                                                              // 2576
        targetOffset = (targetRelative = typeof targetOffset === 'undefined') ? target.offset : targetOffset | 0;      // 2577
        sourceOffset = (relative = typeof sourceOffset === 'undefined') ? this.offset : sourceOffset | 0;              // 2578
        sourceLimit = typeof sourceLimit === 'undefined' ? this.limit : sourceLimit | 0;                               // 2579
                                                                                                                       // 2580
        if (targetOffset < 0 || targetOffset > target.buffer.byteLength)                                               // 2581
            throw RangeError("Illegal target range: 0 <= "+targetOffset+" <= "+target.buffer.byteLength);              // 2582
        if (sourceOffset < 0 || sourceLimit > this.buffer.byteLength)                                                  // 2583
            throw RangeError("Illegal source range: 0 <= "+sourceOffset+" <= "+this.buffer.byteLength);                // 2584
                                                                                                                       // 2585
        var len = sourceLimit - sourceOffset;                                                                          // 2586
        if (len === 0)                                                                                                 // 2587
            return target; // Nothing to copy                                                                          // 2588
                                                                                                                       // 2589
        target.ensureCapacity(targetOffset + len);                                                                     // 2590
                                                                                                                       // 2591
        target.view.set(this.view.subarray(sourceOffset, sourceLimit), targetOffset);                                  // 2592
                                                                                                                       // 2593
        if (relative) this.offset += len;                                                                              // 2594
        if (targetRelative) target.offset += len;                                                                      // 2595
                                                                                                                       // 2596
        return this;                                                                                                   // 2597
    };                                                                                                                 // 2598
                                                                                                                       // 2599
    /**                                                                                                                // 2600
     * Makes sure that this ByteBuffer is backed by a {@link ByteBuffer#buffer} of at least the specified capacity. If the
     *  current capacity is exceeded, it will be doubled. If double the current capacity is less than the required capacity,
     *  the required capacity will be used instead.                                                                    // 2603
     * @param {number} capacity Required capacity                                                                      // 2604
     * @returns {!ByteBuffer} this                                                                                     // 2605
     * @expose                                                                                                         // 2606
     */                                                                                                                // 2607
    ByteBufferPrototype.ensureCapacity = function(capacity) {                                                          // 2608
        var current = this.buffer.byteLength;                                                                          // 2609
        if (current < capacity)                                                                                        // 2610
            return this.resize((current *= 2) > capacity ? current : capacity);                                        // 2611
        return this;                                                                                                   // 2612
    };                                                                                                                 // 2613
                                                                                                                       // 2614
    /**                                                                                                                // 2615
     * Overwrites this ByteBuffer's contents with the specified value. Contents are the bytes between                  // 2616
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.                                                        // 2617
     * @param {number|string} value Byte value to fill with. If given as a string, the first character is used.        // 2618
     * @param {number=} begin Begin offset. Will use and increase {@link ByteBuffer#offset} by the number of bytes     // 2619
     *  written if omitted. defaults to {@link ByteBuffer#offset}.                                                     // 2620
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.                                          // 2621
     * @returns {!ByteBuffer} this                                                                                     // 2622
     * @expose                                                                                                         // 2623
     * @example `someByteBuffer.clear().fill(0)` fills the entire backing buffer with zeroes                           // 2624
     */                                                                                                                // 2625
    ByteBufferPrototype.fill = function(value, begin, end) {                                                           // 2626
        var relative = typeof begin === 'undefined';                                                                   // 2627
        if (relative) begin = this.offset;                                                                             // 2628
        if (typeof value === 'string' && value.length > 0)                                                             // 2629
            value = value.charCodeAt(0);                                                                               // 2630
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 2631
        if (typeof end === 'undefined') end = this.limit;                                                              // 2632
        if (!this.noAssert) {                                                                                          // 2633
            if (typeof value !== 'number' || value % 1 !== 0)                                                          // 2634
                throw TypeError("Illegal value: "+value+" (not an integer)");                                          // 2635
            value |= 0;                                                                                                // 2636
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 2637
                throw TypeError("Illegal begin: Not an integer");                                                      // 2638
            begin >>>= 0;                                                                                              // 2639
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 2640
                throw TypeError("Illegal end: Not an integer");                                                        // 2641
            end >>>= 0;                                                                                                // 2642
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 2643
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 2644
        }                                                                                                              // 2645
        if (begin >= end)                                                                                              // 2646
            return this; // Nothing to fill                                                                            // 2647
        while (begin < end) this.view[begin++] = value;                                                                // 2648
        if (relative) this.offset = begin;                                                                             // 2649
        return this;                                                                                                   // 2650
    };                                                                                                                 // 2651
                                                                                                                       // 2652
    /**                                                                                                                // 2653
     * Makes this ByteBuffer ready for a new sequence of write or relative read operations. Sets `limit = offset` and  // 2654
     *  `offset = 0`. Make sure always to flip a ByteBuffer when all relative read or write operations are complete.   // 2655
     * @returns {!ByteBuffer} this                                                                                     // 2656
     * @expose                                                                                                         // 2657
     */                                                                                                                // 2658
    ByteBufferPrototype.flip = function() {                                                                            // 2659
        this.limit = this.offset;                                                                                      // 2660
        this.offset = 0;                                                                                               // 2661
        return this;                                                                                                   // 2662
    };                                                                                                                 // 2663
    /**                                                                                                                // 2664
     * Marks an offset on this ByteBuffer to be used later.                                                            // 2665
     * @param {number=} offset Offset to mark. Defaults to {@link ByteBuffer#offset}.                                  // 2666
     * @returns {!ByteBuffer} this                                                                                     // 2667
     * @throws {TypeError} If `offset` is not a valid number                                                           // 2668
     * @throws {RangeError} If `offset` is out of bounds                                                               // 2669
     * @see ByteBuffer#reset                                                                                           // 2670
     * @expose                                                                                                         // 2671
     */                                                                                                                // 2672
    ByteBufferPrototype.mark = function(offset) {                                                                      // 2673
        offset = typeof offset === 'undefined' ? this.offset : offset;                                                 // 2674
        if (!this.noAssert) {                                                                                          // 2675
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2676
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2677
            offset >>>= 0;                                                                                             // 2678
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2679
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2680
        }                                                                                                              // 2681
        this.markedOffset = offset;                                                                                    // 2682
        return this;                                                                                                   // 2683
    };                                                                                                                 // 2684
    /**                                                                                                                // 2685
     * Sets the byte order.                                                                                            // 2686
     * @param {boolean} littleEndian `true` for little endian byte order, `false` for big endian                       // 2687
     * @returns {!ByteBuffer} this                                                                                     // 2688
     * @expose                                                                                                         // 2689
     */                                                                                                                // 2690
    ByteBufferPrototype.order = function(littleEndian) {                                                               // 2691
        if (!this.noAssert) {                                                                                          // 2692
            if (typeof littleEndian !== 'boolean')                                                                     // 2693
                throw TypeError("Illegal littleEndian: Not a boolean");                                                // 2694
        }                                                                                                              // 2695
        this.littleEndian = !!littleEndian;                                                                            // 2696
        return this;                                                                                                   // 2697
    };                                                                                                                 // 2698
                                                                                                                       // 2699
    /**                                                                                                                // 2700
     * Switches (to) little endian byte order.                                                                         // 2701
     * @param {boolean=} littleEndian Defaults to `true`, otherwise uses big endian                                    // 2702
     * @returns {!ByteBuffer} this                                                                                     // 2703
     * @expose                                                                                                         // 2704
     */                                                                                                                // 2705
    ByteBufferPrototype.LE = function(littleEndian) {                                                                  // 2706
        this.littleEndian = typeof littleEndian !== 'undefined' ? !!littleEndian : true;                               // 2707
        return this;                                                                                                   // 2708
    };                                                                                                                 // 2709
                                                                                                                       // 2710
    /**                                                                                                                // 2711
     * Switches (to) big endian byte order.                                                                            // 2712
     * @param {boolean=} bigEndian Defaults to `true`, otherwise uses little endian                                    // 2713
     * @returns {!ByteBuffer} this                                                                                     // 2714
     * @expose                                                                                                         // 2715
     */                                                                                                                // 2716
    ByteBufferPrototype.BE = function(bigEndian) {                                                                     // 2717
        this.littleEndian = typeof bigEndian !== 'undefined' ? !bigEndian : false;                                     // 2718
        return this;                                                                                                   // 2719
    };                                                                                                                 // 2720
    /**                                                                                                                // 2721
     * Prepends some data to this ByteBuffer. This will overwrite any contents before the specified offset up to the   // 2722
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.                                                            // 2724
     * @param {!ByteBuffer|string|!ArrayBuffer} source Data to prepend. If `source` is a ByteBuffer, its offset will be
     *  modified according to the performed read operation.                                                            // 2726
     * @param {(string|number)=} encoding Encoding if `data` is a string ("base64", "hex", "binary", defaults to "utf8")
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.                                                                                          // 2729
     * @returns {!ByteBuffer} this                                                                                     // 2730
     * @expose                                                                                                         // 2731
     * @example A relative `00<01 02 03>.prepend(<04 05>)` results in `<04 05 01 02 03>, 04 05|`                       // 2732
     * @example An absolute `00<01 02 03>.prepend(<04 05>, 2)` results in `04<05 02 03>, 04 05|`                       // 2733
     */                                                                                                                // 2734
    ByteBufferPrototype.prepend = function(source, encoding, offset) {                                                 // 2735
        if (typeof encoding === 'number' || typeof encoding !== 'string') {                                            // 2736
            offset = encoding;                                                                                         // 2737
            encoding = undefined;                                                                                      // 2738
        }                                                                                                              // 2739
        var relative = typeof offset === 'undefined';                                                                  // 2740
        if (relative) offset = this.offset;                                                                            // 2741
        if (!this.noAssert) {                                                                                          // 2742
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2743
                throw TypeError("Illegal offset: "+offset+" (not an integer)");                                        // 2744
            offset >>>= 0;                                                                                             // 2745
            if (offset < 0 || offset + 0 > this.buffer.byteLength)                                                     // 2746
                throw RangeError("Illegal offset: 0 <= "+offset+" (+"+0+") <= "+this.buffer.byteLength);               // 2747
        }                                                                                                              // 2748
        if (!(source instanceof ByteBuffer))                                                                           // 2749
            source = ByteBuffer.wrap(source, encoding);                                                                // 2750
        var len = source.limit - source.offset;                                                                        // 2751
        if (len <= 0) return this; // Nothing to prepend                                                               // 2752
        var diff = len - offset;                                                                                       // 2753
        if (diff > 0) { // Not enough space before offset, so resize + move                                            // 2754
            var buffer = new ArrayBuffer(this.buffer.byteLength + diff);                                               // 2755
            var view = new Uint8Array(buffer);                                                                         // 2756
            view.set(this.view.subarray(offset, this.buffer.byteLength), len);                                         // 2757
            this.buffer = buffer;                                                                                      // 2758
            this.view = view;                                                                                          // 2759
            this.offset += diff;                                                                                       // 2760
            if (this.markedOffset >= 0) this.markedOffset += diff;                                                     // 2761
            this.limit += diff;                                                                                        // 2762
            offset += diff;                                                                                            // 2763
        } else {                                                                                                       // 2764
            var arrayView = new Uint8Array(this.buffer);                                                               // 2765
        }                                                                                                              // 2766
        this.view.set(source.view.subarray(source.offset, source.limit), offset - len);                                // 2767
                                                                                                                       // 2768
        source.offset = source.limit;                                                                                  // 2769
        if (relative)                                                                                                  // 2770
            this.offset -= len;                                                                                        // 2771
        return this;                                                                                                   // 2772
    };                                                                                                                 // 2773
                                                                                                                       // 2774
    /**                                                                                                                // 2775
     * Prepends this ByteBuffer to another ByteBuffer. This will overwrite any contents before the specified offset up to the
     *  prepended data's length. If there is not enough space available before the specified `offset`, the backing buffer
     *  will be resized and its contents moved accordingly.                                                            // 2778
     * @param {!ByteBuffer} target Target ByteBuffer                                                                   // 2779
     * @param {number=} offset Offset to prepend at. Will use and decrease {@link ByteBuffer#offset} by the number of bytes
     *  prepended if omitted.                                                                                          // 2781
     * @returns {!ByteBuffer} this                                                                                     // 2782
     * @expose                                                                                                         // 2783
     * @see ByteBuffer#prepend                                                                                         // 2784
     */                                                                                                                // 2785
    ByteBufferPrototype.prependTo = function(target, offset) {                                                         // 2786
        target.prepend(this, offset);                                                                                  // 2787
        return this;                                                                                                   // 2788
    };                                                                                                                 // 2789
    /**                                                                                                                // 2790
     * Prints debug information about this ByteBuffer's contents.                                                      // 2791
     * @param {function(string)=} out Output function to call, defaults to console.log                                 // 2792
     * @expose                                                                                                         // 2793
     */                                                                                                                // 2794
    ByteBufferPrototype.printDebug = function(out) {                                                                   // 2795
        if (typeof out !== 'function') out = console.log.bind(console);                                                // 2796
        out(                                                                                                           // 2797
            this.toString()+"\n"+                                                                                      // 2798
            "-------------------------------------------------------------------\n"+                                   // 2799
            this.toDebug(/* columns */ true)                                                                           // 2800
        );                                                                                                             // 2801
    };                                                                                                                 // 2802
                                                                                                                       // 2803
    /**                                                                                                                // 2804
     * Gets the number of remaining readable bytes. Contents are the bytes between {@link ByteBuffer#offset} and       // 2805
     *  {@link ByteBuffer#limit}, so this returns `limit - offset`.                                                    // 2806
     * @returns {number} Remaining readable bytes. May be negative if `offset > limit`.                                // 2807
     * @expose                                                                                                         // 2808
     */                                                                                                                // 2809
    ByteBufferPrototype.remaining = function() {                                                                       // 2810
        return this.limit - this.offset;                                                                               // 2811
    };                                                                                                                 // 2812
    /**                                                                                                                // 2813
     * Resets this ByteBuffer's {@link ByteBuffer#offset}. If an offset has been marked through {@link ByteBuffer#mark}
     *  before, `offset` will be set to {@link ByteBuffer#markedOffset}, which will then be discarded. If no offset has been
     *  marked, sets `offset = 0`.                                                                                     // 2816
     * @returns {!ByteBuffer} this                                                                                     // 2817
     * @see ByteBuffer#mark                                                                                            // 2818
     * @expose                                                                                                         // 2819
     */                                                                                                                // 2820
    ByteBufferPrototype.reset = function() {                                                                           // 2821
        if (this.markedOffset >= 0) {                                                                                  // 2822
            this.offset = this.markedOffset;                                                                           // 2823
            this.markedOffset = -1;                                                                                    // 2824
        } else {                                                                                                       // 2825
            this.offset = 0;                                                                                           // 2826
        }                                                                                                              // 2827
        return this;                                                                                                   // 2828
    };                                                                                                                 // 2829
    /**                                                                                                                // 2830
     * Resizes this ByteBuffer to be backed by a buffer of at least the given capacity. Will do nothing if already that
     *  large or larger.                                                                                               // 2832
     * @param {number} capacity Capacity required                                                                      // 2833
     * @returns {!ByteBuffer} this                                                                                     // 2834
     * @throws {TypeError} If `capacity` is not a number                                                               // 2835
     * @throws {RangeError} If `capacity < 0`                                                                          // 2836
     * @expose                                                                                                         // 2837
     */                                                                                                                // 2838
    ByteBufferPrototype.resize = function(capacity) {                                                                  // 2839
        if (!this.noAssert) {                                                                                          // 2840
            if (typeof capacity !== 'number' || capacity % 1 !== 0)                                                    // 2841
                throw TypeError("Illegal capacity: "+capacity+" (not an integer)");                                    // 2842
            capacity |= 0;                                                                                             // 2843
            if (capacity < 0)                                                                                          // 2844
                throw RangeError("Illegal capacity: 0 <= "+capacity);                                                  // 2845
        }                                                                                                              // 2846
        if (this.buffer.byteLength < capacity) {                                                                       // 2847
            var buffer = new ArrayBuffer(capacity);                                                                    // 2848
            var view = new Uint8Array(buffer);                                                                         // 2849
            view.set(this.view);                                                                                       // 2850
            this.buffer = buffer;                                                                                      // 2851
            this.view = view;                                                                                          // 2852
        }                                                                                                              // 2853
        return this;                                                                                                   // 2854
    };                                                                                                                 // 2855
    /**                                                                                                                // 2856
     * Reverses this ByteBuffer's contents.                                                                            // 2857
     * @param {number=} begin Offset to start at, defaults to {@link ByteBuffer#offset}                                // 2858
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}                                     // 2859
     * @returns {!ByteBuffer} this                                                                                     // 2860
     * @expose                                                                                                         // 2861
     */                                                                                                                // 2862
    ByteBufferPrototype.reverse = function(begin, end) {                                                               // 2863
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 2864
        if (typeof end === 'undefined') end = this.limit;                                                              // 2865
        if (!this.noAssert) {                                                                                          // 2866
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 2867
                throw TypeError("Illegal begin: Not an integer");                                                      // 2868
            begin >>>= 0;                                                                                              // 2869
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 2870
                throw TypeError("Illegal end: Not an integer");                                                        // 2871
            end >>>= 0;                                                                                                // 2872
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 2873
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 2874
        }                                                                                                              // 2875
        if (begin === end)                                                                                             // 2876
            return this; // Nothing to reverse                                                                         // 2877
        Array.prototype.reverse.call(this.view.subarray(begin, end));                                                  // 2878
        return this;                                                                                                   // 2879
    };                                                                                                                 // 2880
    /**                                                                                                                // 2881
     * Skips the next `length` bytes. This will just advance                                                           // 2882
     * @param {number} length Number of bytes to skip. May also be negative to move the offset back.                   // 2883
     * @returns {!ByteBuffer} this                                                                                     // 2884
     * @expose                                                                                                         // 2885
     */                                                                                                                // 2886
    ByteBufferPrototype.skip = function(length) {                                                                      // 2887
        if (!this.noAssert) {                                                                                          // 2888
            if (typeof length !== 'number' || length % 1 !== 0)                                                        // 2889
                throw TypeError("Illegal length: "+length+" (not an integer)");                                        // 2890
            length |= 0;                                                                                               // 2891
        }                                                                                                              // 2892
        var offset = this.offset + length;                                                                             // 2893
        if (!this.noAssert) {                                                                                          // 2894
            if (offset < 0 || offset > this.buffer.byteLength)                                                         // 2895
                throw RangeError("Illegal length: 0 <= "+this.offset+" + "+length+" <= "+this.buffer.byteLength);      // 2896
        }                                                                                                              // 2897
        this.offset = offset;                                                                                          // 2898
        return this;                                                                                                   // 2899
    };                                                                                                                 // 2900
                                                                                                                       // 2901
    /**                                                                                                                // 2902
     * Slices this ByteBuffer by creating a cloned instance with `offset = begin` and `limit = end`.                   // 2903
     * @param {number=} begin Begin offset, defaults to {@link ByteBuffer#offset}.                                     // 2904
     * @param {number=} end End offset, defaults to {@link ByteBuffer#limit}.                                          // 2905
     * @returns {!ByteBuffer} Clone of this ByteBuffer with slicing applied, backed by the same {@link ByteBuffer#buffer}
     * @expose                                                                                                         // 2907
     */                                                                                                                // 2908
    ByteBufferPrototype.slice = function(begin, end) {                                                                 // 2909
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 2910
        if (typeof end === 'undefined') end = this.limit;                                                              // 2911
        if (!this.noAssert) {                                                                                          // 2912
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 2913
                throw TypeError("Illegal begin: Not an integer");                                                      // 2914
            begin >>>= 0;                                                                                              // 2915
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 2916
                throw TypeError("Illegal end: Not an integer");                                                        // 2917
            end >>>= 0;                                                                                                // 2918
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 2919
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 2920
        }                                                                                                              // 2921
        var bb = this.clone();                                                                                         // 2922
        bb.offset = begin;                                                                                             // 2923
        bb.limit = end;                                                                                                // 2924
        return bb;                                                                                                     // 2925
    };                                                                                                                 // 2926
    /**                                                                                                                // 2927
     * Returns a copy of the backing buffer that contains this ByteBuffer's contents. Contents are the bytes between   // 2928
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}.                                                        // 2929
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory if   // 2930
     *  possible. Defaults to `false`                                                                                  // 2931
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer                                                              // 2932
     * @expose                                                                                                         // 2933
     */                                                                                                                // 2934
    ByteBufferPrototype.toBuffer = function(forceCopy) {                                                               // 2935
        var offset = this.offset,                                                                                      // 2936
            limit = this.limit;                                                                                        // 2937
        if (!this.noAssert) {                                                                                          // 2938
            if (typeof offset !== 'number' || offset % 1 !== 0)                                                        // 2939
                throw TypeError("Illegal offset: Not an integer");                                                     // 2940
            offset >>>= 0;                                                                                             // 2941
            if (typeof limit !== 'number' || limit % 1 !== 0)                                                          // 2942
                throw TypeError("Illegal limit: Not an integer");                                                      // 2943
            limit >>>= 0;                                                                                              // 2944
            if (offset < 0 || offset > limit || limit > this.buffer.byteLength)                                        // 2945
                throw RangeError("Illegal range: 0 <= "+offset+" <= "+limit+" <= "+this.buffer.byteLength);            // 2946
        }                                                                                                              // 2947
        // NOTE: It's not possible to have another ArrayBuffer reference the same memory as the backing buffer. This is
        // possible with Uint8Array#subarray only, but we have to return an ArrayBuffer by contract. So:               // 2949
        if (!forceCopy && offset === 0 && limit === this.buffer.byteLength)                                            // 2950
            return this.buffer;                                                                                        // 2951
        if (offset === limit)                                                                                          // 2952
            return EMPTY_BUFFER;                                                                                       // 2953
        var buffer = new ArrayBuffer(limit - offset);                                                                  // 2954
        new Uint8Array(buffer).set(new Uint8Array(this.buffer).subarray(offset, limit), 0);                            // 2955
        return buffer;                                                                                                 // 2956
    };                                                                                                                 // 2957
                                                                                                                       // 2958
    /**                                                                                                                // 2959
     * Returns a raw buffer compacted to contain this ByteBuffer's contents. Contents are the bytes between            // 2960
     *  {@link ByteBuffer#offset} and {@link ByteBuffer#limit}. This is an alias of {@link ByteBuffer#toBuffer}.       // 2961
     * @function                                                                                                       // 2962
     * @param {boolean=} forceCopy If `true` returns a copy, otherwise returns a view referencing the same memory.     // 2963
     *  Defaults to `false`                                                                                            // 2964
     * @returns {!ArrayBuffer} Contents as an ArrayBuffer                                                              // 2965
     * @expose                                                                                                         // 2966
     */                                                                                                                // 2967
    ByteBufferPrototype.toArrayBuffer = ByteBufferPrototype.toBuffer;                                                  // 2968
                                                                                                                       // 2969
    /**                                                                                                                // 2970
     * Converts the ByteBuffer's contents to a string.                                                                 // 2971
     * @param {string=} encoding Output encoding. Returns an informative string representation if omitted but also allows
     *  direct conversion to "utf8", "hex", "base64" and "binary" encoding. "debug" returns a hex representation with  // 2973
     *  highlighted offsets.                                                                                           // 2974
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}                                // 2975
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}                                     // 2976
     * @returns {string} String representation                                                                         // 2977
     * @throws {Error} If `encoding` is invalid                                                                        // 2978
     * @expose                                                                                                         // 2979
     */                                                                                                                // 2980
    ByteBufferPrototype.toString = function(encoding, begin, end) {                                                    // 2981
        if (typeof encoding === 'undefined')                                                                           // 2982
            return "ByteBufferAB(offset="+this.offset+",markedOffset="+this.markedOffset+",limit="+this.limit+",capacity="+this.capacity()+")";
        if (typeof encoding === 'number')                                                                              // 2984
            encoding = "utf8",                                                                                         // 2985
            begin = encoding,                                                                                          // 2986
            end = begin;                                                                                               // 2987
        switch (encoding) {                                                                                            // 2988
            case "utf8":                                                                                               // 2989
                return this.toUTF8(begin, end);                                                                        // 2990
            case "base64":                                                                                             // 2991
                return this.toBase64(begin, end);                                                                      // 2992
            case "hex":                                                                                                // 2993
                return this.toHex(begin, end);                                                                         // 2994
            case "binary":                                                                                             // 2995
                return this.toBinary(begin, end);                                                                      // 2996
            case "debug":                                                                                              // 2997
                return this.toDebug();                                                                                 // 2998
            case "columns":                                                                                            // 2999
                return this.toColumns();                                                                               // 3000
            default:                                                                                                   // 3001
                throw Error("Unsupported encoding: "+encoding);                                                        // 3002
        }                                                                                                              // 3003
    };                                                                                                                 // 3004
                                                                                                                       // 3005
    // lxiv-embeddable                                                                                                 // 3006
                                                                                                                       // 3007
    /**                                                                                                                // 3008
     * lxiv-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>                                                          // 3009
     * Released under the Apache License, Version 2.0                                                                  // 3010
     * see: https://github.com/dcodeIO/lxiv for details                                                                // 3011
     */                                                                                                                // 3012
    var lxiv = function() {                                                                                            // 3013
        "use strict";                                                                                                  // 3014
                                                                                                                       // 3015
        /**                                                                                                            // 3016
         * lxiv namespace.                                                                                             // 3017
         * @type {!Object.<string,*>}                                                                                  // 3018
         * @exports lxiv                                                                                               // 3019
         */                                                                                                            // 3020
        var lxiv = {};                                                                                                 // 3021
                                                                                                                       // 3022
        /**                                                                                                            // 3023
         * Character codes for output.                                                                                 // 3024
         * @type {!Array.<number>}                                                                                     // 3025
         * @inner                                                                                                      // 3026
         */                                                                                                            // 3027
        var aout = [                                                                                                   // 3028
            65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,                                            // 3029
            81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 97, 98, 99, 100, 101, 102,                                         // 3030
            103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118,                            // 3031
            119, 120, 121, 122, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 43, 47                                         // 3032
        ];                                                                                                             // 3033
                                                                                                                       // 3034
        /**                                                                                                            // 3035
         * Character codes for input.                                                                                  // 3036
         * @type {!Array.<number>}                                                                                     // 3037
         * @inner                                                                                                      // 3038
         */                                                                                                            // 3039
        var ain = [];                                                                                                  // 3040
        for (var i=0, k=aout.length; i<k; ++i)                                                                         // 3041
            ain[aout[i]] = i;                                                                                          // 3042
                                                                                                                       // 3043
        /**                                                                                                            // 3044
         * Encodes bytes to base64 char codes.                                                                         // 3045
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if
         *  there are no more bytes left.                                                                              // 3047
         * @param {!function(number)} dst Characters destination as a function successively called with each encoded char
         *  code.                                                                                                      // 3049
         */                                                                                                            // 3050
        lxiv.encode = function(src, dst) {                                                                             // 3051
            var b, t;                                                                                                  // 3052
            while ((b = src()) !== null) {                                                                             // 3053
                dst(aout[(b>>2)&0x3f]);                                                                                // 3054
                t = (b&0x3)<<4;                                                                                        // 3055
                if ((b = src()) !== null) {                                                                            // 3056
                    t |= (b>>4)&0xf;                                                                                   // 3057
                    dst(aout[(t|((b>>4)&0xf))&0x3f]);                                                                  // 3058
                    t = (b&0xf)<<2;                                                                                    // 3059
                    if ((b = src()) !== null)                                                                          // 3060
                        dst(aout[(t|((b>>6)&0x3))&0x3f]),                                                              // 3061
                        dst(aout[b&0x3f]);                                                                             // 3062
                    else                                                                                               // 3063
                        dst(aout[t&0x3f]),                                                                             // 3064
                        dst(61);                                                                                       // 3065
                } else                                                                                                 // 3066
                    dst(aout[t&0x3f]),                                                                                 // 3067
                    dst(61),                                                                                           // 3068
                    dst(61);                                                                                           // 3069
            }                                                                                                          // 3070
        };                                                                                                             // 3071
                                                                                                                       // 3072
        /**                                                                                                            // 3073
         * Decodes base64 char codes to bytes.                                                                         // 3074
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.                                                               // 3076
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.      // 3077
         * @throws {Error} If a character code is invalid                                                              // 3078
         */                                                                                                            // 3079
        lxiv.decode = function(src, dst) {                                                                             // 3080
            var c, t1, t2;                                                                                             // 3081
            function fail(c) {                                                                                         // 3082
                throw Error("Illegal character code: "+c);                                                             // 3083
            }                                                                                                          // 3084
            while ((c = src()) !== null) {                                                                             // 3085
                t1 = ain[c];                                                                                           // 3086
                if (typeof t1 === 'undefined') fail(c);                                                                // 3087
                if ((c = src()) !== null) {                                                                            // 3088
                    t2 = ain[c];                                                                                       // 3089
                    if (typeof t2 === 'undefined') fail(c);                                                            // 3090
                    dst((t1<<2)>>>0|(t2&0x30)>>4);                                                                     // 3091
                    if ((c = src()) !== null) {                                                                        // 3092
                        t1 = ain[c];                                                                                   // 3093
                        if (typeof t1 === 'undefined')                                                                 // 3094
                            if (c === 61) break; else fail(c);                                                         // 3095
                        dst(((t2&0xf)<<4)>>>0|(t1&0x3c)>>2);                                                           // 3096
                        if ((c = src()) !== null) {                                                                    // 3097
                            t2 = ain[c];                                                                               // 3098
                            if (typeof t2 === 'undefined')                                                             // 3099
                                if (c === 61) break; else fail(c);                                                     // 3100
                            dst(((t1&0x3)<<6)>>>0|t2);                                                                 // 3101
                        }                                                                                              // 3102
                    }                                                                                                  // 3103
                }                                                                                                      // 3104
            }                                                                                                          // 3105
        };                                                                                                             // 3106
                                                                                                                       // 3107
        /**                                                                                                            // 3108
         * Tests if a string is valid base64.                                                                          // 3109
         * @param {string} str String to test                                                                          // 3110
         * @returns {boolean} `true` if valid, otherwise `false`                                                       // 3111
         */                                                                                                            // 3112
        lxiv.test = function(str) {                                                                                    // 3113
            return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(str);                       // 3114
        };                                                                                                             // 3115
                                                                                                                       // 3116
        return lxiv;                                                                                                   // 3117
    }();                                                                                                               // 3118
                                                                                                                       // 3119
    // encodings/base64                                                                                                // 3120
                                                                                                                       // 3121
    /**                                                                                                                // 3122
     * Encodes this ByteBuffer's contents to a base64 encoded string.                                                  // 3123
     * @param {number=} begin Offset to begin at, defaults to {@link ByteBuffer#offset}.                               // 3124
     * @param {number=} end Offset to end at, defaults to {@link ByteBuffer#limit}.                                    // 3125
     * @returns {string} Base64 encoded string                                                                         // 3126
     * @throws {RangeError} If `begin` or `end` is out of bounds                                                       // 3127
     * @expose                                                                                                         // 3128
     */                                                                                                                // 3129
    ByteBufferPrototype.toBase64 = function(begin, end) {                                                              // 3130
        if (typeof begin === 'undefined')                                                                              // 3131
            begin = this.offset;                                                                                       // 3132
        if (typeof end === 'undefined')                                                                                // 3133
            end = this.limit;                                                                                          // 3134
        begin = begin | 0; end = end | 0;                                                                              // 3135
        if (begin < 0 || end > this.capacity || begin > end)                                                           // 3136
            throw RangeError("begin, end");                                                                            // 3137
        var sd; lxiv.encode(function() {                                                                               // 3138
            return begin < end ? this.view[begin++] : null;                                                            // 3139
        }.bind(this), sd = stringDestination());                                                                       // 3140
        return sd();                                                                                                   // 3141
    };                                                                                                                 // 3142
                                                                                                                       // 3143
    /**                                                                                                                // 3144
     * Decodes a base64 encoded string to a ByteBuffer.                                                                // 3145
     * @param {string} str String to decode                                                                            // 3146
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 3147
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 3148
     * @returns {!ByteBuffer} ByteBuffer                                                                               // 3149
     * @expose                                                                                                         // 3150
     */                                                                                                                // 3151
    ByteBuffer.fromBase64 = function(str, littleEndian) {                                                              // 3152
        if (typeof str !== 'string')                                                                                   // 3153
            throw TypeError("str");                                                                                    // 3154
        var bb = new ByteBuffer(str.length/4*3, littleEndian),                                                         // 3155
            i = 0;                                                                                                     // 3156
        lxiv.decode(stringSource(str), function(b) {                                                                   // 3157
            bb.view[i++] = b;                                                                                          // 3158
        });                                                                                                            // 3159
        bb.limit = i;                                                                                                  // 3160
        return bb;                                                                                                     // 3161
    };                                                                                                                 // 3162
                                                                                                                       // 3163
    /**                                                                                                                // 3164
     * Encodes a binary string to base64 like `window.btoa` does.                                                      // 3165
     * @param {string} str Binary string                                                                               // 3166
     * @returns {string} Base64 encoded string                                                                         // 3167
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.btoa                                               // 3168
     * @expose                                                                                                         // 3169
     */                                                                                                                // 3170
    ByteBuffer.btoa = function(str) {                                                                                  // 3171
        return ByteBuffer.fromBinary(str).toBase64();                                                                  // 3172
    };                                                                                                                 // 3173
                                                                                                                       // 3174
    /**                                                                                                                // 3175
     * Decodes a base64 encoded string to binary like `window.atob` does.                                              // 3176
     * @param {string} b64 Base64 encoded string                                                                       // 3177
     * @returns {string} Binary string                                                                                 // 3178
     * @see https://developer.mozilla.org/en-US/docs/Web/API/Window.atob                                               // 3179
     * @expose                                                                                                         // 3180
     */                                                                                                                // 3181
    ByteBuffer.atob = function(b64) {                                                                                  // 3182
        return ByteBuffer.fromBase64(b64).toBinary();                                                                  // 3183
    };                                                                                                                 // 3184
                                                                                                                       // 3185
    // encodings/binary                                                                                                // 3186
                                                                                                                       // 3187
    /**                                                                                                                // 3188
     * Encodes this ByteBuffer to a binary encoded string, that is using only characters 0x00-0xFF as bytes.           // 3189
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.                               // 3190
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.                                    // 3191
     * @returns {string} Binary encoded string                                                                         // 3192
     * @throws {RangeError} If `offset > limit`                                                                        // 3193
     * @expose                                                                                                         // 3194
     */                                                                                                                // 3195
    ByteBufferPrototype.toBinary = function(begin, end) {                                                              // 3196
        if (typeof begin === 'undefined')                                                                              // 3197
            begin = this.offset;                                                                                       // 3198
        if (typeof end === 'undefined')                                                                                // 3199
            end = this.limit;                                                                                          // 3200
        begin |= 0; end |= 0;                                                                                          // 3201
        if (begin < 0 || end > this.capacity() || begin > end)                                                         // 3202
            throw RangeError("begin, end");                                                                            // 3203
        if (begin === end)                                                                                             // 3204
            return "";                                                                                                 // 3205
        var chars = [],                                                                                                // 3206
            parts = [];                                                                                                // 3207
        while (begin < end) {                                                                                          // 3208
            chars.push(this.view[begin++]);                                                                            // 3209
            if (chars.length >= 1024)                                                                                  // 3210
                parts.push(String.fromCharCode.apply(String, chars)),                                                  // 3211
                chars = [];                                                                                            // 3212
        }                                                                                                              // 3213
        return parts.join('') + String.fromCharCode.apply(String, chars);                                              // 3214
    };                                                                                                                 // 3215
                                                                                                                       // 3216
    /**                                                                                                                // 3217
     * Decodes a binary encoded string, that is using only characters 0x00-0xFF as bytes, to a ByteBuffer.             // 3218
     * @param {string} str String to decode                                                                            // 3219
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 3220
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 3221
     * @returns {!ByteBuffer} ByteBuffer                                                                               // 3222
     * @expose                                                                                                         // 3223
     */                                                                                                                // 3224
    ByteBuffer.fromBinary = function(str, littleEndian) {                                                              // 3225
        if (typeof str !== 'string')                                                                                   // 3226
            throw TypeError("str");                                                                                    // 3227
        var i = 0,                                                                                                     // 3228
            k = str.length,                                                                                            // 3229
            charCode,                                                                                                  // 3230
            bb = new ByteBuffer(k, littleEndian);                                                                      // 3231
        while (i<k) {                                                                                                  // 3232
            charCode = str.charCodeAt(i);                                                                              // 3233
            if (charCode > 0xff)                                                                                       // 3234
                throw RangeError("illegal char code: "+charCode);                                                      // 3235
            bb.view[i++] = charCode;                                                                                   // 3236
        }                                                                                                              // 3237
        bb.limit = k;                                                                                                  // 3238
        return bb;                                                                                                     // 3239
    };                                                                                                                 // 3240
                                                                                                                       // 3241
    // encodings/debug                                                                                                 // 3242
                                                                                                                       // 3243
    /**                                                                                                                // 3244
     * Encodes this ByteBuffer to a hex encoded string with marked offsets. Offset symbols are:                        // 3245
     * * `<` : offset,                                                                                                 // 3246
     * * `'` : markedOffset,                                                                                           // 3247
     * * `>` : limit,                                                                                                  // 3248
     * * `|` : offset and limit,                                                                                       // 3249
     * * `[` : offset and markedOffset,                                                                                // 3250
     * * `]` : markedOffset and limit,                                                                                 // 3251
     * * `!` : offset, markedOffset and limit                                                                          // 3252
     * @param {boolean=} columns If `true` returns two columns hex + ascii, defaults to `false`                        // 3253
     * @returns {string|!Array.<string>} Debug string or array of lines if `asArray = true`                            // 3254
     * @expose                                                                                                         // 3255
     * @example `>00'01 02<03` contains four bytes with `limit=0, markedOffset=1, offset=3`                            // 3256
     * @example `00[01 02 03>` contains four bytes with `offset=markedOffset=1, limit=4`                               // 3257
     * @example `00|01 02 03` contains four bytes with `offset=limit=1, markedOffset=-1`                               // 3258
     * @example `|` contains zero bytes with `offset=limit=0, markedOffset=-1`                                         // 3259
     */                                                                                                                // 3260
    ByteBufferPrototype.toDebug = function(columns) {                                                                  // 3261
        var i = -1,                                                                                                    // 3262
            k = this.buffer.byteLength,                                                                                // 3263
            b,                                                                                                         // 3264
            hex = "",                                                                                                  // 3265
            asc = "",                                                                                                  // 3266
            out = "";                                                                                                  // 3267
        while (i<k) {                                                                                                  // 3268
            if (i !== -1) {                                                                                            // 3269
                b = this.view[i];                                                                                      // 3270
                if (b < 0x10) hex += "0"+b.toString(16).toUpperCase();                                                 // 3271
                else hex += b.toString(16).toUpperCase();                                                              // 3272
                if (columns)                                                                                           // 3273
                    asc += b > 32 && b < 127 ? String.fromCharCode(b) : '.';                                           // 3274
            }                                                                                                          // 3275
            ++i;                                                                                                       // 3276
            if (columns) {                                                                                             // 3277
                if (i > 0 && i % 16 === 0 && i !== k) {                                                                // 3278
                    while (hex.length < 3*16+3) hex += " ";                                                            // 3279
                    out += hex+asc+"\n";                                                                               // 3280
                    hex = asc = "";                                                                                    // 3281
                }                                                                                                      // 3282
            }                                                                                                          // 3283
            if (i === this.offset && i === this.limit)                                                                 // 3284
                hex += i === this.markedOffset ? "!" : "|";                                                            // 3285
            else if (i === this.offset)                                                                                // 3286
                hex += i === this.markedOffset ? "[" : "<";                                                            // 3287
            else if (i === this.limit)                                                                                 // 3288
                hex += i === this.markedOffset ? "]" : ">";                                                            // 3289
            else                                                                                                       // 3290
                hex += i === this.markedOffset ? "'" : (columns || (i !== 0 && i !== k) ? " " : "");                   // 3291
        }                                                                                                              // 3292
        if (columns && hex !== " ") {                                                                                  // 3293
            while (hex.length < 3*16+3)                                                                                // 3294
                hex += " ";                                                                                            // 3295
            out += hex + asc + "\n";                                                                                   // 3296
        }                                                                                                              // 3297
        return columns ? out : hex;                                                                                    // 3298
    };                                                                                                                 // 3299
                                                                                                                       // 3300
    /**                                                                                                                // 3301
     * Decodes a hex encoded string with marked offsets to a ByteBuffer.                                               // 3302
     * @param {string} str Debug string to decode (not be generated with `columns = true`)                             // 3303
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 3304
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 3305
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 3306
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 3307
     * @returns {!ByteBuffer} ByteBuffer                                                                               // 3308
     * @expose                                                                                                         // 3309
     * @see ByteBuffer#toDebug                                                                                         // 3310
     */                                                                                                                // 3311
    ByteBuffer.fromDebug = function(str, littleEndian, noAssert) {                                                     // 3312
        var k = str.length,                                                                                            // 3313
            bb = new ByteBuffer(((k+1)/3)|0, littleEndian, noAssert);                                                  // 3314
        var i = 0, j = 0, ch, b,                                                                                       // 3315
            rs = false, // Require symbol next                                                                         // 3316
            ho = false, hm = false, hl = false, // Already has offset (ho), markedOffset (hm), limit (hl)?             // 3317
            fail = false;                                                                                              // 3318
        while (i<k) {                                                                                                  // 3319
            switch (ch = str.charAt(i++)) {                                                                            // 3320
                case '!':                                                                                              // 3321
                    if (!noAssert) {                                                                                   // 3322
                        if (ho || hm || hl) {                                                                          // 3323
                            fail = true;                                                                               // 3324
                            break;                                                                                     // 3325
                        }                                                                                              // 3326
                        ho = hm = hl = true;                                                                           // 3327
                    }                                                                                                  // 3328
                    bb.offset = bb.markedOffset = bb.limit = j;                                                        // 3329
                    rs = false;                                                                                        // 3330
                    break;                                                                                             // 3331
                case '|':                                                                                              // 3332
                    if (!noAssert) {                                                                                   // 3333
                        if (ho || hl) {                                                                                // 3334
                            fail = true;                                                                               // 3335
                            break;                                                                                     // 3336
                        }                                                                                              // 3337
                        ho = hl = true;                                                                                // 3338
                    }                                                                                                  // 3339
                    bb.offset = bb.limit = j;                                                                          // 3340
                    rs = false;                                                                                        // 3341
                    break;                                                                                             // 3342
                case '[':                                                                                              // 3343
                    if (!noAssert) {                                                                                   // 3344
                        if (ho || hm) {                                                                                // 3345
                            fail = true;                                                                               // 3346
                            break;                                                                                     // 3347
                        }                                                                                              // 3348
                        ho = hm = true;                                                                                // 3349
                    }                                                                                                  // 3350
                    bb.offset = bb.markedOffset = j;                                                                   // 3351
                    rs = false;                                                                                        // 3352
                    break;                                                                                             // 3353
                case '<':                                                                                              // 3354
                    if (!noAssert) {                                                                                   // 3355
                        if (ho) {                                                                                      // 3356
                            fail = true;                                                                               // 3357
                            break;                                                                                     // 3358
                        }                                                                                              // 3359
                        ho = true;                                                                                     // 3360
                    }                                                                                                  // 3361
                    bb.offset = j;                                                                                     // 3362
                    rs = false;                                                                                        // 3363
                    break;                                                                                             // 3364
                case ']':                                                                                              // 3365
                    if (!noAssert) {                                                                                   // 3366
                        if (hl || hm) {                                                                                // 3367
                            fail = true;                                                                               // 3368
                            break;                                                                                     // 3369
                        }                                                                                              // 3370
                        hl = hm = true;                                                                                // 3371
                    }                                                                                                  // 3372
                    bb.limit = bb.markedOffset = j;                                                                    // 3373
                    rs = false;                                                                                        // 3374
                    break;                                                                                             // 3375
                case '>':                                                                                              // 3376
                    if (!noAssert) {                                                                                   // 3377
                        if (hl) {                                                                                      // 3378
                            fail = true;                                                                               // 3379
                            break;                                                                                     // 3380
                        }                                                                                              // 3381
                        hl = true;                                                                                     // 3382
                    }                                                                                                  // 3383
                    bb.limit = j;                                                                                      // 3384
                    rs = false;                                                                                        // 3385
                    break;                                                                                             // 3386
                case "'":                                                                                              // 3387
                    if (!noAssert) {                                                                                   // 3388
                        if (hm) {                                                                                      // 3389
                            fail = true;                                                                               // 3390
                            break;                                                                                     // 3391
                        }                                                                                              // 3392
                        hm = true;                                                                                     // 3393
                    }                                                                                                  // 3394
                    bb.markedOffset = j;                                                                               // 3395
                    rs = false;                                                                                        // 3396
                    break;                                                                                             // 3397
                case ' ':                                                                                              // 3398
                    rs = false;                                                                                        // 3399
                    break;                                                                                             // 3400
                default:                                                                                               // 3401
                    if (!noAssert) {                                                                                   // 3402
                        if (rs) {                                                                                      // 3403
                            fail = true;                                                                               // 3404
                            break;                                                                                     // 3405
                        }                                                                                              // 3406
                    }                                                                                                  // 3407
                    b = parseInt(ch+str.charAt(i++), 16);                                                              // 3408
                    if (!noAssert) {                                                                                   // 3409
                        if (isNaN(b) || b < 0 || b > 255)                                                              // 3410
                            throw TypeError("Illegal str: Not a debug encoded string");                                // 3411
                    }                                                                                                  // 3412
                    bb.view[j++] = b;                                                                                  // 3413
                    rs = true;                                                                                         // 3414
            }                                                                                                          // 3415
            if (fail)                                                                                                  // 3416
                throw TypeError("Illegal str: Invalid symbol at "+i);                                                  // 3417
        }                                                                                                              // 3418
        if (!noAssert) {                                                                                               // 3419
            if (!ho || !hl)                                                                                            // 3420
                throw TypeError("Illegal str: Missing offset or limit");                                               // 3421
            if (j<bb.buffer.byteLength)                                                                                // 3422
                throw TypeError("Illegal str: Not a debug encoded string (is it hex?) "+j+" < "+k);                    // 3423
        }                                                                                                              // 3424
        return bb;                                                                                                     // 3425
    };                                                                                                                 // 3426
                                                                                                                       // 3427
    // encodings/hex                                                                                                   // 3428
                                                                                                                       // 3429
    /**                                                                                                                // 3430
     * Encodes this ByteBuffer's contents to a hex encoded string.                                                     // 3431
     * @param {number=} begin Offset to begin at. Defaults to {@link ByteBuffer#offset}.                               // 3432
     * @param {number=} end Offset to end at. Defaults to {@link ByteBuffer#limit}.                                    // 3433
     * @returns {string} Hex encoded string                                                                            // 3434
     * @expose                                                                                                         // 3435
     */                                                                                                                // 3436
    ByteBufferPrototype.toHex = function(begin, end) {                                                                 // 3437
        begin = typeof begin === 'undefined' ? this.offset : begin;                                                    // 3438
        end = typeof end === 'undefined' ? this.limit : end;                                                           // 3439
        if (!this.noAssert) {                                                                                          // 3440
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 3441
                throw TypeError("Illegal begin: Not an integer");                                                      // 3442
            begin >>>= 0;                                                                                              // 3443
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 3444
                throw TypeError("Illegal end: Not an integer");                                                        // 3445
            end >>>= 0;                                                                                                // 3446
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 3447
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 3448
        }                                                                                                              // 3449
        var out = new Array(end - begin),                                                                              // 3450
            b;                                                                                                         // 3451
        while (begin < end) {                                                                                          // 3452
            b = this.view[begin++];                                                                                    // 3453
            if (b < 0x10)                                                                                              // 3454
                out.push("0", b.toString(16));                                                                         // 3455
            else out.push(b.toString(16));                                                                             // 3456
        }                                                                                                              // 3457
        return out.join('');                                                                                           // 3458
    };                                                                                                                 // 3459
                                                                                                                       // 3460
    /**                                                                                                                // 3461
     * Decodes a hex encoded string to a ByteBuffer.                                                                   // 3462
     * @param {string} str String to decode                                                                            // 3463
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 3464
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 3465
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 3466
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 3467
     * @returns {!ByteBuffer} ByteBuffer                                                                               // 3468
     * @expose                                                                                                         // 3469
     */                                                                                                                // 3470
    ByteBuffer.fromHex = function(str, littleEndian, noAssert) {                                                       // 3471
        if (!noAssert) {                                                                                               // 3472
            if (typeof str !== 'string')                                                                               // 3473
                throw TypeError("Illegal str: Not a string");                                                          // 3474
            if (str.length % 2 !== 0)                                                                                  // 3475
                throw TypeError("Illegal str: Length not a multiple of 2");                                            // 3476
        }                                                                                                              // 3477
        var k = str.length,                                                                                            // 3478
            bb = new ByteBuffer((k / 2) | 0, littleEndian),                                                            // 3479
            b;                                                                                                         // 3480
        for (var i=0, j=0; i<k; i+=2) {                                                                                // 3481
            b = parseInt(str.substring(i, i+2), 16);                                                                   // 3482
            if (!noAssert)                                                                                             // 3483
                if (!isFinite(b) || b < 0 || b > 255)                                                                  // 3484
                    throw TypeError("Illegal str: Contains non-hex characters");                                       // 3485
            bb.view[j++] = b;                                                                                          // 3486
        }                                                                                                              // 3487
        bb.limit = j;                                                                                                  // 3488
        return bb;                                                                                                     // 3489
    };                                                                                                                 // 3490
                                                                                                                       // 3491
    // utfx-embeddable                                                                                                 // 3492
                                                                                                                       // 3493
    /**                                                                                                                // 3494
     * utfx-embeddable (c) 2014 Daniel Wirtz <dcode@dcode.io>                                                          // 3495
     * Released under the Apache License, Version 2.0                                                                  // 3496
     * see: https://github.com/dcodeIO/utfx for details                                                                // 3497
     */                                                                                                                // 3498
    var utfx = function() {                                                                                            // 3499
        "use strict";                                                                                                  // 3500
                                                                                                                       // 3501
        /**                                                                                                            // 3502
         * utfx namespace.                                                                                             // 3503
         * @inner                                                                                                      // 3504
         * @type {!Object.<string,*>}                                                                                  // 3505
         */                                                                                                            // 3506
        var utfx = {};                                                                                                 // 3507
                                                                                                                       // 3508
        /**                                                                                                            // 3509
         * Maximum valid code point.                                                                                   // 3510
         * @type {number}                                                                                              // 3511
         * @const                                                                                                      // 3512
         */                                                                                                            // 3513
        utfx.MAX_CODEPOINT = 0x10FFFF;                                                                                 // 3514
                                                                                                                       // 3515
        /**                                                                                                            // 3516
         * Encodes UTF8 code points to UTF8 bytes.                                                                     // 3517
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.                  // 3519
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte       // 3520
         */                                                                                                            // 3521
        utfx.encodeUTF8 = function(src, dst) {                                                                         // 3522
            var cp = null;                                                                                             // 3523
            if (typeof src === 'number')                                                                               // 3524
                cp = src,                                                                                              // 3525
                src = function() { return null; };                                                                     // 3526
            while (cp !== null || (cp = src()) !== null) {                                                             // 3527
                if (cp < 0x80)                                                                                         // 3528
                    dst(cp&0x7F);                                                                                      // 3529
                else if (cp < 0x800)                                                                                   // 3530
                    dst(((cp>>6)&0x1F)|0xC0),                                                                          // 3531
                    dst((cp&0x3F)|0x80);                                                                               // 3532
                else if (cp < 0x10000)                                                                                 // 3533
                    dst(((cp>>12)&0x0F)|0xE0),                                                                         // 3534
                    dst(((cp>>6)&0x3F)|0x80),                                                                          // 3535
                    dst((cp&0x3F)|0x80);                                                                               // 3536
                else                                                                                                   // 3537
                    dst(((cp>>18)&0x07)|0xF0),                                                                         // 3538
                    dst(((cp>>12)&0x3F)|0x80),                                                                         // 3539
                    dst(((cp>>6)&0x3F)|0x80),                                                                          // 3540
                    dst((cp&0x3F)|0x80);                                                                               // 3541
                cp = null;                                                                                             // 3542
            }                                                                                                          // 3543
        };                                                                                                             // 3544
                                                                                                                       // 3545
        /**                                                                                                            // 3546
         * Decodes UTF8 bytes to UTF8 code points.                                                                     // 3547
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.                                                                                    // 3549
         * @param {!function(number)} dst Code points destination as a function successively called with each decoded code point.
         * @throws {RangeError} If a starting byte is invalid in UTF8                                                  // 3551
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the                // 3552
         *  remaining bytes.                                                                                           // 3553
         */                                                                                                            // 3554
        utfx.decodeUTF8 = function(src, dst) {                                                                         // 3555
            var a, b, c, d, fail = function(b) {                                                                       // 3556
                b = b.slice(0, b.indexOf(null));                                                                       // 3557
                var err = Error(b.toString());                                                                         // 3558
                err.name = "TruncatedError";                                                                           // 3559
                err['bytes'] = b;                                                                                      // 3560
                throw err;                                                                                             // 3561
            };                                                                                                         // 3562
            while ((a = src()) !== null) {                                                                             // 3563
                if ((a&0x80) === 0)                                                                                    // 3564
                    dst(a);                                                                                            // 3565
                else if ((a&0xE0) === 0xC0)                                                                            // 3566
                    ((b = src()) === null) && fail([a, b]),                                                            // 3567
                    dst(((a&0x1F)<<6) | (b&0x3F));                                                                     // 3568
                else if ((a&0xF0) === 0xE0)                                                                            // 3569
                    ((b=src()) === null || (c=src()) === null) && fail([a, b, c]),                                     // 3570
                    dst(((a&0x0F)<<12) | ((b&0x3F)<<6) | (c&0x3F));                                                    // 3571
                else if ((a&0xF8) === 0xF0)                                                                            // 3572
                    ((b=src()) === null || (c=src()) === null || (d=src()) === null) && fail([a, b, c ,d]),            // 3573
                    dst(((a&0x07)<<18) | ((b&0x3F)<<12) | ((c&0x3F)<<6) | (d&0x3F));                                   // 3574
                else throw RangeError("Illegal starting byte: "+a);                                                    // 3575
            }                                                                                                          // 3576
        };                                                                                                             // 3577
                                                                                                                       // 3578
        /**                                                                                                            // 3579
         * Converts UTF16 characters to UTF8 code points.                                                              // 3580
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.                                                               // 3582
         * @param {!function(number)} dst Code points destination as a function successively called with each converted code
         *  point.                                                                                                     // 3584
         */                                                                                                            // 3585
        utfx.UTF16toUTF8 = function(src, dst) {                                                                        // 3586
            var c1, c2 = null;                                                                                         // 3587
            while (true) {                                                                                             // 3588
                if ((c1 = c2 !== null ? c2 : src()) === null)                                                          // 3589
                    break;                                                                                             // 3590
                if (c1 >= 0xD800 && c1 <= 0xDFFF) {                                                                    // 3591
                    if ((c2 = src()) !== null) {                                                                       // 3592
                        if (c2 >= 0xDC00 && c2 <= 0xDFFF) {                                                            // 3593
                            dst((c1-0xD800)*0x400+c2-0xDC00+0x10000);                                                  // 3594
                            c2 = null; continue;                                                                       // 3595
                        }                                                                                              // 3596
                    }                                                                                                  // 3597
                }                                                                                                      // 3598
                dst(c1);                                                                                               // 3599
            }                                                                                                          // 3600
            if (c2 !== null) dst(c2);                                                                                  // 3601
        };                                                                                                             // 3602
                                                                                                                       // 3603
        /**                                                                                                            // 3604
         * Converts UTF8 code points to UTF16 characters.                                                              // 3605
         * @param {(!function():number|null) | number} src Code points source, either as a function returning the next code point
         *  respectively `null` if there are no more code points left or a single numeric code point.                  // 3607
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a code point is out of range                                                        // 3609
         */                                                                                                            // 3610
        utfx.UTF8toUTF16 = function(src, dst) {                                                                        // 3611
            var cp = null;                                                                                             // 3612
            if (typeof src === 'number')                                                                               // 3613
                cp = src, src = function() { return null; };                                                           // 3614
            while (cp !== null || (cp = src()) !== null) {                                                             // 3615
                if (cp <= 0xFFFF)                                                                                      // 3616
                    dst(cp);                                                                                           // 3617
                else                                                                                                   // 3618
                    cp -= 0x10000,                                                                                     // 3619
                    dst((cp>>10)+0xD800),                                                                              // 3620
                    dst((cp%0x400)+0xDC00);                                                                            // 3621
                cp = null;                                                                                             // 3622
            }                                                                                                          // 3623
        };                                                                                                             // 3624
                                                                                                                       // 3625
        /**                                                                                                            // 3626
         * Converts and encodes UTF16 characters to UTF8 bytes.                                                        // 3627
         * @param {!function():number|null} src Characters source as a function returning the next char code respectively `null`
         *  if there are no more characters left.                                                                      // 3629
         * @param {!function(number)} dst Bytes destination as a function successively called with the next byte.      // 3630
         */                                                                                                            // 3631
        utfx.encodeUTF16toUTF8 = function(src, dst) {                                                                  // 3632
            utfx.UTF16toUTF8(src, function(cp) {                                                                       // 3633
                utfx.encodeUTF8(cp, dst);                                                                              // 3634
            });                                                                                                        // 3635
        };                                                                                                             // 3636
                                                                                                                       // 3637
        /**                                                                                                            // 3638
         * Decodes and converts UTF8 bytes to UTF16 characters.                                                        // 3639
         * @param {!function():number|null} src Bytes source as a function returning the next byte respectively `null` if there
         *  are no more bytes left.                                                                                    // 3641
         * @param {!function(number)} dst Characters destination as a function successively called with each converted char code.
         * @throws {RangeError} If a starting byte is invalid in UTF8                                                  // 3643
         * @throws {Error} If the last sequence is truncated. Has an array property `bytes` holding the remaining bytes.
         */                                                                                                            // 3645
        utfx.decodeUTF8toUTF16 = function(src, dst) {                                                                  // 3646
            utfx.decodeUTF8(src, function(cp) {                                                                        // 3647
                utfx.UTF8toUTF16(cp, dst);                                                                             // 3648
            });                                                                                                        // 3649
        };                                                                                                             // 3650
                                                                                                                       // 3651
        /**                                                                                                            // 3652
         * Calculates the byte length of an UTF8 code point.                                                           // 3653
         * @param {number} cp UTF8 code point                                                                          // 3654
         * @returns {number} Byte length                                                                               // 3655
         */                                                                                                            // 3656
        utfx.calculateCodePoint = function(cp) {                                                                       // 3657
            return (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;                                        // 3658
        };                                                                                                             // 3659
                                                                                                                       // 3660
        /**                                                                                                            // 3661
         * Calculates the number of UTF8 bytes required to store UTF8 code points.                                     // 3662
         * @param {(!function():number|null)} src Code points source as a function returning the next code point respectively
         *  `null` if there are no more code points left.                                                              // 3664
         * @returns {number} The number of UTF8 bytes required                                                         // 3665
         */                                                                                                            // 3666
        utfx.calculateUTF8 = function(src) {                                                                           // 3667
            var cp, l=0;                                                                                               // 3668
            while ((cp = src()) !== null)                                                                              // 3669
                l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;                                      // 3670
            return l;                                                                                                  // 3671
        };                                                                                                             // 3672
                                                                                                                       // 3673
        /**                                                                                                            // 3674
         * Calculates the number of UTF8 code points respectively UTF8 bytes required to store UTF16 char codes.       // 3675
         * @param {(!function():number|null)} src Characters source as a function returning the next char code respectively
         *  `null` if there are no more characters left.                                                               // 3677
         * @returns {!Array.<number>} The number of UTF8 code points at index 0 and the number of UTF8 bytes required at index 1.
         */                                                                                                            // 3679
        utfx.calculateUTF16asUTF8 = function(src) {                                                                    // 3680
            var n=0, l=0;                                                                                              // 3681
            utfx.UTF16toUTF8(src, function(cp) {                                                                       // 3682
                ++n; l += (cp < 0x80) ? 1 : (cp < 0x800) ? 2 : (cp < 0x10000) ? 3 : 4;                                 // 3683
            });                                                                                                        // 3684
            return [n,l];                                                                                              // 3685
        };                                                                                                             // 3686
                                                                                                                       // 3687
        return utfx;                                                                                                   // 3688
    }();                                                                                                               // 3689
                                                                                                                       // 3690
    // encodings/utf8                                                                                                  // 3691
                                                                                                                       // 3692
    /**                                                                                                                // 3693
     * Encodes this ByteBuffer's contents between {@link ByteBuffer#offset} and {@link ByteBuffer#limit} to an UTF8 encoded
     *  string.                                                                                                        // 3695
     * @returns {string} Hex encoded string                                                                            // 3696
     * @throws {RangeError} If `offset > limit`                                                                        // 3697
     * @expose                                                                                                         // 3698
     */                                                                                                                // 3699
    ByteBufferPrototype.toUTF8 = function(begin, end) {                                                                // 3700
        if (typeof begin === 'undefined') begin = this.offset;                                                         // 3701
        if (typeof end === 'undefined') end = this.limit;                                                              // 3702
        if (!this.noAssert) {                                                                                          // 3703
            if (typeof begin !== 'number' || begin % 1 !== 0)                                                          // 3704
                throw TypeError("Illegal begin: Not an integer");                                                      // 3705
            begin >>>= 0;                                                                                              // 3706
            if (typeof end !== 'number' || end % 1 !== 0)                                                              // 3707
                throw TypeError("Illegal end: Not an integer");                                                        // 3708
            end >>>= 0;                                                                                                // 3709
            if (begin < 0 || begin > end || end > this.buffer.byteLength)                                              // 3710
                throw RangeError("Illegal range: 0 <= "+begin+" <= "+end+" <= "+this.buffer.byteLength);               // 3711
        }                                                                                                              // 3712
        var sd; try {                                                                                                  // 3713
            utfx.decodeUTF8toUTF16(function() {                                                                        // 3714
                return begin < end ? this.view[begin++] : null;                                                        // 3715
            }.bind(this), sd = stringDestination());                                                                   // 3716
        } catch (e) {                                                                                                  // 3717
            if (begin !== end)                                                                                         // 3718
                throw RangeError("Illegal range: Truncated data, "+begin+" != "+end);                                  // 3719
        }                                                                                                              // 3720
        return sd();                                                                                                   // 3721
    };                                                                                                                 // 3722
                                                                                                                       // 3723
    /**                                                                                                                // 3724
     * Decodes an UTF8 encoded string to a ByteBuffer.                                                                 // 3725
     * @param {string} str String to decode                                                                            // 3726
     * @param {boolean=} littleEndian Whether to use little or big endian byte order. Defaults to                      // 3727
     *  {@link ByteBuffer.DEFAULT_ENDIAN}.                                                                             // 3728
     * @param {boolean=} noAssert Whether to skip assertions of offsets and values. Defaults to                        // 3729
     *  {@link ByteBuffer.DEFAULT_NOASSERT}.                                                                           // 3730
     * @returns {!ByteBuffer} ByteBuffer                                                                               // 3731
     * @expose                                                                                                         // 3732
     */                                                                                                                // 3733
    ByteBuffer.fromUTF8 = function(str, littleEndian, noAssert) {                                                      // 3734
        if (!noAssert)                                                                                                 // 3735
            if (typeof str !== 'string')                                                                               // 3736
                throw TypeError("Illegal str: Not a string");                                                          // 3737
        var bb = new ByteBuffer(utfx.calculateUTF16asUTF8(stringSource(str), true)[1], littleEndian, noAssert),        // 3738
            i = 0;                                                                                                     // 3739
        utfx.encodeUTF16toUTF8(stringSource(str), function(b) {                                                        // 3740
            bb.view[i++] = b;                                                                                          // 3741
        });                                                                                                            // 3742
        bb.limit = i;                                                                                                  // 3743
        return bb;                                                                                                     // 3744
    };                                                                                                                 // 3745
                                                                                                                       // 3746
//     return ByteBuffer;                                                                                              // 3747
// });                                                                                                                 // 3748
                                                                                                                       // 3749
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/protobuf.js                                                                                     //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
/*                                                                                                                     // 1
 Copyright 2013 Daniel Wirtz <dcode@dcode.io>                                                                          // 2
                                                                                                                       // 3
 Licensed under the Apache License, Version 2.0 (the "License");                                                       // 4
 you may not use this file except in compliance with the License.                                                      // 5
 You may obtain a copy of the License at                                                                               // 6
                                                                                                                       // 7
 http://www.apache.org/licenses/LICENSE-2.0                                                                            // 8
                                                                                                                       // 9
 Unless required by applicable law or agreed to in writing, software                                                   // 10
 distributed under the License is distributed on an "AS IS" BASIS,                                                     // 11
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.                                              // 12
 See the License for the specific language governing permissions and                                                   // 13
 limitations under the License.                                                                                        // 14
 */                                                                                                                    // 15
                                                                                                                       // 16
/**                                                                                                                    // 17
 * @license protobuf.js (c) 2013 Daniel Wirtz <dcode@dcode.io>                                                         // 18
 * Released under the Apache License, Version 2.0                                                                      // 19
 * see: https://github.com/dcodeIO/protobuf.js for details                                                             // 20
 */                                                                                                                    // 21
// (function(global, factory) {                                                                                        // 22
//                                                                                                                     // 23
//     /* AMD */ if (typeof define === 'function' && define["amd"])                                                    // 24
//         define(["bytebuffer"], factory);                                                                            // 25
//     /* CommonJS */ else if (typeof require === "function" && typeof module === "object" && module && module["exports"])
//         module["exports"] = factory(require("bytebuffer"), true);                                                   // 27
//     /* Global */ else                                                                                               // 28
//         (global["dcodeIO"] = global["dcodeIO"] || {})["ProtoBuf"] = factory(global["dcodeIO"]["ByteBuffer"]);       // 29
//                                                                                                                     // 30
// })(this, function(ByteBuffer, isCommonJS) {                                                                         // 31
//     "use strict";                                                                                                   // 32
                                                                                                                       // 33
    /**                                                                                                                // 34
     * The ProtoBuf namespace.                                                                                         // 35
     * @exports ProtoBuf                                                                                               // 36
     * @namespace                                                                                                      // 37
     * @expose                                                                                                         // 38
     */                                                                                                                // 39
    // var ProtoBuf = {};                                                                                              // 40
                                                                                                                       // 41
    /**                                                                                                                // 42
     * @type {!function(new: ByteBuffer, ...[*])}                                                                      // 43
     * @expose                                                                                                         // 44
     */                                                                                                                // 45
    ProtoBuf.ByteBuffer = ByteBuffer;                                                                                  // 46
                                                                                                                       // 47
    /**                                                                                                                // 48
     * @type {?function(new: Long, ...[*])}                                                                            // 49
     * @expose                                                                                                         // 50
     */                                                                                                                // 51
    ProtoBuf.Long = ByteBuffer.Long || null;                                                                           // 52
                                                                                                                       // 53
    /**                                                                                                                // 54
     * ProtoBuf.js version.                                                                                            // 55
     * @type {string}                                                                                                  // 56
     * @const                                                                                                          // 57
     * @expose                                                                                                         // 58
     */                                                                                                                // 59
    ProtoBuf.VERSION = "5.0.1";                                                                                        // 60
                                                                                                                       // 61
    /**                                                                                                                // 62
     * Wire types.                                                                                                     // 63
     * @type {Object.<string,number>}                                                                                  // 64
     * @const                                                                                                          // 65
     * @expose                                                                                                         // 66
     */                                                                                                                // 67
    ProtoBuf.WIRE_TYPES = {};                                                                                          // 68
                                                                                                                       // 69
    /**                                                                                                                // 70
     * Varint wire type.                                                                                               // 71
     * @type {number}                                                                                                  // 72
     * @expose                                                                                                         // 73
     */                                                                                                                // 74
    ProtoBuf.WIRE_TYPES.VARINT = 0;                                                                                    // 75
                                                                                                                       // 76
    /**                                                                                                                // 77
     * Fixed 64 bits wire type.                                                                                        // 78
     * @type {number}                                                                                                  // 79
     * @const                                                                                                          // 80
     * @expose                                                                                                         // 81
     */                                                                                                                // 82
    ProtoBuf.WIRE_TYPES.BITS64 = 1;                                                                                    // 83
                                                                                                                       // 84
    /**                                                                                                                // 85
     * Length delimited wire type.                                                                                     // 86
     * @type {number}                                                                                                  // 87
     * @const                                                                                                          // 88
     * @expose                                                                                                         // 89
     */                                                                                                                // 90
    ProtoBuf.WIRE_TYPES.LDELIM = 2;                                                                                    // 91
                                                                                                                       // 92
    /**                                                                                                                // 93
     * Start group wire type.                                                                                          // 94
     * @type {number}                                                                                                  // 95
     * @const                                                                                                          // 96
     * @expose                                                                                                         // 97
     */                                                                                                                // 98
    ProtoBuf.WIRE_TYPES.STARTGROUP = 3;                                                                                // 99
                                                                                                                       // 100
    /**                                                                                                                // 101
     * End group wire type.                                                                                            // 102
     * @type {number}                                                                                                  // 103
     * @const                                                                                                          // 104
     * @expose                                                                                                         // 105
     */                                                                                                                // 106
    ProtoBuf.WIRE_TYPES.ENDGROUP = 4;                                                                                  // 107
                                                                                                                       // 108
    /**                                                                                                                // 109
     * Fixed 32 bits wire type.                                                                                        // 110
     * @type {number}                                                                                                  // 111
     * @const                                                                                                          // 112
     * @expose                                                                                                         // 113
     */                                                                                                                // 114
    ProtoBuf.WIRE_TYPES.BITS32 = 5;                                                                                    // 115
                                                                                                                       // 116
    /**                                                                                                                // 117
     * Packable wire types.                                                                                            // 118
     * @type {!Array.<number>}                                                                                         // 119
     * @const                                                                                                          // 120
     * @expose                                                                                                         // 121
     */                                                                                                                // 122
    ProtoBuf.PACKABLE_WIRE_TYPES = [                                                                                   // 123
        ProtoBuf.WIRE_TYPES.VARINT,                                                                                    // 124
        ProtoBuf.WIRE_TYPES.BITS64,                                                                                    // 125
        ProtoBuf.WIRE_TYPES.BITS32                                                                                     // 126
    ];                                                                                                                 // 127
                                                                                                                       // 128
    /**                                                                                                                // 129
     * Types.                                                                                                          // 130
     * @dict                                                                                                           // 131
     * @type {!Object.<string,{name: string, wireType: number, defaultValue: *}>}                                      // 132
     * @const                                                                                                          // 133
     * @expose                                                                                                         // 134
     */                                                                                                                // 135
    ProtoBuf.TYPES = {                                                                                                 // 136
        // According to the protobuf spec.                                                                             // 137
        "int32": {                                                                                                     // 138
            name: "int32",                                                                                             // 139
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 140
            defaultValue: 0                                                                                            // 141
        },                                                                                                             // 142
        "uint32": {                                                                                                    // 143
            name: "uint32",                                                                                            // 144
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 145
            defaultValue: 0                                                                                            // 146
        },                                                                                                             // 147
        "sint32": {                                                                                                    // 148
            name: "sint32",                                                                                            // 149
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 150
            defaultValue: 0                                                                                            // 151
        },                                                                                                             // 152
        "int64": {                                                                                                     // 153
            name: "int64",                                                                                             // 154
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 155
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined                                               // 156
        },                                                                                                             // 157
        "uint64": {                                                                                                    // 158
            name: "uint64",                                                                                            // 159
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 160
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined                                              // 161
        },                                                                                                             // 162
        "sint64": {                                                                                                    // 163
            name: "sint64",                                                                                            // 164
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 165
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined                                               // 166
        },                                                                                                             // 167
        "bool": {                                                                                                      // 168
            name: "bool",                                                                                              // 169
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 170
            defaultValue: false                                                                                        // 171
        },                                                                                                             // 172
        "double": {                                                                                                    // 173
            name: "double",                                                                                            // 174
            wireType: ProtoBuf.WIRE_TYPES.BITS64,                                                                      // 175
            defaultValue: 0                                                                                            // 176
        },                                                                                                             // 177
        "string": {                                                                                                    // 178
            name: "string",                                                                                            // 179
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,                                                                      // 180
            defaultValue: ""                                                                                           // 181
        },                                                                                                             // 182
        "bytes": {                                                                                                     // 183
            name: "bytes",                                                                                             // 184
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,                                                                      // 185
            defaultValue: null // overridden in the code, must be a unique instance                                    // 186
        },                                                                                                             // 187
        "fixed32": {                                                                                                   // 188
            name: "fixed32",                                                                                           // 189
            wireType: ProtoBuf.WIRE_TYPES.BITS32,                                                                      // 190
            defaultValue: 0                                                                                            // 191
        },                                                                                                             // 192
        "sfixed32": {                                                                                                  // 193
            name: "sfixed32",                                                                                          // 194
            wireType: ProtoBuf.WIRE_TYPES.BITS32,                                                                      // 195
            defaultValue: 0                                                                                            // 196
        },                                                                                                             // 197
        "fixed64": {                                                                                                   // 198
            name: "fixed64",                                                                                           // 199
            wireType: ProtoBuf.WIRE_TYPES.BITS64,                                                                      // 200
            defaultValue:  ProtoBuf.Long ? ProtoBuf.Long.UZERO : undefined                                             // 201
        },                                                                                                             // 202
        "sfixed64": {                                                                                                  // 203
            name: "sfixed64",                                                                                          // 204
            wireType: ProtoBuf.WIRE_TYPES.BITS64,                                                                      // 205
            defaultValue: ProtoBuf.Long ? ProtoBuf.Long.ZERO : undefined                                               // 206
        },                                                                                                             // 207
        "float": {                                                                                                     // 208
            name: "float",                                                                                             // 209
            wireType: ProtoBuf.WIRE_TYPES.BITS32,                                                                      // 210
            defaultValue: 0                                                                                            // 211
        },                                                                                                             // 212
        "enum": {                                                                                                      // 213
            name: "enum",                                                                                              // 214
            wireType: ProtoBuf.WIRE_TYPES.VARINT,                                                                      // 215
            defaultValue: 0                                                                                            // 216
        },                                                                                                             // 217
        "message": {                                                                                                   // 218
            name: "message",                                                                                           // 219
            wireType: ProtoBuf.WIRE_TYPES.LDELIM,                                                                      // 220
            defaultValue: null                                                                                         // 221
        },                                                                                                             // 222
        "group": {                                                                                                     // 223
            name: "group",                                                                                             // 224
            wireType: ProtoBuf.WIRE_TYPES.STARTGROUP,                                                                  // 225
            defaultValue: null                                                                                         // 226
        }                                                                                                              // 227
    };                                                                                                                 // 228
                                                                                                                       // 229
    /**                                                                                                                // 230
     * Valid map key types.                                                                                            // 231
     * @type {!Array.<!Object.<string,{name: string, wireType: number, defaultValue: *}>>}                             // 232
     * @const                                                                                                          // 233
     * @expose                                                                                                         // 234
     */                                                                                                                // 235
    ProtoBuf.MAP_KEY_TYPES = [                                                                                         // 236
        ProtoBuf.TYPES["int32"],                                                                                       // 237
        ProtoBuf.TYPES["sint32"],                                                                                      // 238
        ProtoBuf.TYPES["sfixed32"],                                                                                    // 239
        ProtoBuf.TYPES["uint32"],                                                                                      // 240
        ProtoBuf.TYPES["fixed32"],                                                                                     // 241
        ProtoBuf.TYPES["int64"],                                                                                       // 242
        ProtoBuf.TYPES["sint64"],                                                                                      // 243
        ProtoBuf.TYPES["sfixed64"],                                                                                    // 244
        ProtoBuf.TYPES["uint64"],                                                                                      // 245
        ProtoBuf.TYPES["fixed64"],                                                                                     // 246
        ProtoBuf.TYPES["bool"],                                                                                        // 247
        ProtoBuf.TYPES["string"],                                                                                      // 248
        ProtoBuf.TYPES["bytes"]                                                                                        // 249
    ];                                                                                                                 // 250
                                                                                                                       // 251
    /**                                                                                                                // 252
     * Minimum field id.                                                                                               // 253
     * @type {number}                                                                                                  // 254
     * @const                                                                                                          // 255
     * @expose                                                                                                         // 256
     */                                                                                                                // 257
    ProtoBuf.ID_MIN = 1;                                                                                               // 258
                                                                                                                       // 259
    /**                                                                                                                // 260
     * Maximum field id.                                                                                               // 261
     * @type {number}                                                                                                  // 262
     * @const                                                                                                          // 263
     * @expose                                                                                                         // 264
     */                                                                                                                // 265
    ProtoBuf.ID_MAX = 0x1FFFFFFF;                                                                                      // 266
                                                                                                                       // 267
    /**                                                                                                                // 268
     * If set to `true`, field names will be converted from underscore notation to camel case. Defaults to `false`.    // 269
     *  Must be set prior to parsing.                                                                                  // 270
     * @type {boolean}                                                                                                 // 271
     * @expose                                                                                                         // 272
     */                                                                                                                // 273
    ProtoBuf.convertFieldsToCamelCase = false;                                                                         // 274
                                                                                                                       // 275
    /**                                                                                                                // 276
     * By default, messages are populated with (setX, set_x) accessors for each field. This can be disabled by         // 277
     *  setting this to `false` prior to building messages.                                                            // 278
     * @type {boolean}                                                                                                 // 279
     * @expose                                                                                                         // 280
     */                                                                                                                // 281
    ProtoBuf.populateAccessors = true;                                                                                 // 282
                                                                                                                       // 283
    /**                                                                                                                // 284
     * By default, messages are populated with default values if a field is not present on the wire. To disable        // 285
     *  this behavior, set this setting to `false`.                                                                    // 286
     * @type {boolean}                                                                                                 // 287
     * @expose                                                                                                         // 288
     */                                                                                                                // 289
    ProtoBuf.populateDefaults = true;                                                                                  // 290
                                                                                                                       // 291
    /**                                                                                                                // 292
     * @alias ProtoBuf.Util                                                                                            // 293
     * @expose                                                                                                         // 294
     */                                                                                                                // 295
    ProtoBuf.Util = (function() {                                                                                      // 296
        "use strict";                                                                                                  // 297
                                                                                                                       // 298
        /**                                                                                                            // 299
         * ProtoBuf utilities.                                                                                         // 300
         * @exports ProtoBuf.Util                                                                                      // 301
         * @namespace                                                                                                  // 302
         */                                                                                                            // 303
        var Util = {};                                                                                                 // 304
                                                                                                                       // 305
        /**                                                                                                            // 306
         * Flag if running in node or not.                                                                             // 307
         * @type {boolean}                                                                                             // 308
         * @const                                                                                                      // 309
         * @expose                                                                                                     // 310
         */                                                                                                            // 311
        Util.IS_NODE = !!(                                                                                             // 312
            typeof process === 'object' && process+'' === '[object process]' && !process['browser']                    // 313
        );                                                                                                             // 314
                                                                                                                       // 315
        /**                                                                                                            // 316
         * Constructs a XMLHttpRequest object.                                                                         // 317
         * @return {XMLHttpRequest}                                                                                    // 318
         * @throws {Error} If XMLHttpRequest is not supported                                                          // 319
         * @expose                                                                                                     // 320
         */                                                                                                            // 321
        Util.XHR = function() {                                                                                        // 322
            // No dependencies please, ref: http://www.quirksmode.org/js/xmlhttp.html                                  // 323
            var XMLHttpFactories = [                                                                                   // 324
                function () {return new XMLHttpRequest()},                                                             // 325
                function () {return new ActiveXObject("Msxml2.XMLHTTP")},                                              // 326
                function () {return new ActiveXObject("Msxml3.XMLHTTP")},                                              // 327
                function () {return new ActiveXObject("Microsoft.XMLHTTP")}                                            // 328
            ];                                                                                                         // 329
            /** @type {?XMLHttpRequest} */                                                                             // 330
            var xhr = null;                                                                                            // 331
            for (var i=0;i<XMLHttpFactories.length;i++) {                                                              // 332
                try { xhr = XMLHttpFactories[i](); }                                                                   // 333
                catch (e) { continue; }                                                                                // 334
                break;                                                                                                 // 335
            }                                                                                                          // 336
            if (!xhr)                                                                                                  // 337
                throw Error("XMLHttpRequest is not supported");                                                        // 338
            return xhr;                                                                                                // 339
        };                                                                                                             // 340
                                                                                                                       // 341
        /**                                                                                                            // 342
         * Fetches a resource.                                                                                         // 343
         * @param {string} path Resource path                                                                          // 344
         * @param {function(?string)=} callback Callback receiving the resource's contents. If omitted the resource will
         *   be fetched synchronously. If the request failed, contents will be null.                                   // 346
         * @return {?string|undefined} Resource contents if callback is omitted (null if the request failed), else undefined.
         * @expose                                                                                                     // 348
         */                                                                                                            // 349
        Util.fetch = function(path, callback) {                                                                        // 350
            if (callback && typeof callback != 'function')                                                             // 351
                callback = null;                                                                                       // 352
            if (Util.IS_NODE) {                                                                                        // 353
                var fs = require("fs");                                                                                // 354
                if (callback) {                                                                                        // 355
                    fs.readFile(path, function(err, data) {                                                            // 356
                        if (err)                                                                                       // 357
                            callback(null);                                                                            // 358
                        else                                                                                           // 359
                            callback(""+data);                                                                         // 360
                    });                                                                                                // 361
                } else                                                                                                 // 362
                    try {                                                                                              // 363
                        return fs.readFileSync(path);                                                                  // 364
                    } catch (e) {                                                                                      // 365
                        return null;                                                                                   // 366
                    }                                                                                                  // 367
            } else {                                                                                                   // 368
                var xhr = Util.XHR();                                                                                  // 369
                xhr.open('GET', path, callback ? true : false);                                                        // 370
                // xhr.setRequestHeader('User-Agent', 'XMLHTTP/1.0');                                                  // 371
                xhr.setRequestHeader('Accept', 'text/plain');                                                          // 372
                if (typeof xhr.overrideMimeType === 'function') xhr.overrideMimeType('text/plain');                    // 373
                if (callback) {                                                                                        // 374
                    xhr.onreadystatechange = function() {                                                              // 375
                        if (xhr.readyState != 4) return;                                                               // 376
                        if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                            callback(xhr.responseText);                                                                // 378
                        else                                                                                           // 379
                            callback(null);                                                                            // 380
                    };                                                                                                 // 381
                    if (xhr.readyState == 4)                                                                           // 382
                        return;                                                                                        // 383
                    xhr.send(null);                                                                                    // 384
                } else {                                                                                               // 385
                    xhr.send(null);                                                                                    // 386
                    if (/* remote */ xhr.status == 200 || /* local */ (xhr.status == 0 && typeof xhr.responseText === 'string'))
                        return xhr.responseText;                                                                       // 388
                    return null;                                                                                       // 389
                }                                                                                                      // 390
            }                                                                                                          // 391
        };                                                                                                             // 392
                                                                                                                       // 393
        /**                                                                                                            // 394
         * Converts a string to camel case.                                                                            // 395
         * @param {string} str                                                                                         // 396
         * @returns {string}                                                                                           // 397
         * @expose                                                                                                     // 398
         */                                                                                                            // 399
        Util.toCamelCase = function(str) {                                                                             // 400
            return str.replace(/_([a-zA-Z])/g, function ($0, $1) {                                                     // 401
                return $1.toUpperCase();                                                                               // 402
            });                                                                                                        // 403
        };                                                                                                             // 404
                                                                                                                       // 405
        return Util;                                                                                                   // 406
    })();                                                                                                              // 407
                                                                                                                       // 408
    /**                                                                                                                // 409
     * Language expressions.                                                                                           // 410
     * @type {!Object.<string,!RegExp>}                                                                                // 411
     * @expose                                                                                                         // 412
     */                                                                                                                // 413
    ProtoBuf.Lang = {                                                                                                  // 414
                                                                                                                       // 415
        // Characters always ending a statement                                                                        // 416
        DELIM: /[\s\{\}=;:\[\],'"\(\)<>]/g,                                                                            // 417
                                                                                                                       // 418
        // Field rules                                                                                                 // 419
        RULE: /^(?:required|optional|repeated|map)$/,                                                                  // 420
                                                                                                                       // 421
        // Field types                                                                                                 // 422
        TYPE: /^(?:double|float|int32|uint32|sint32|int64|uint64|sint64|fixed32|sfixed32|fixed64|sfixed64|bool|string|bytes)$/,
                                                                                                                       // 424
        // Names                                                                                                       // 425
        NAME: /^[a-zA-Z_][a-zA-Z_0-9]*$/,                                                                              // 426
                                                                                                                       // 427
        // Type definitions                                                                                            // 428
        TYPEDEF: /^[a-zA-Z][a-zA-Z_0-9]*$/,                                                                            // 429
                                                                                                                       // 430
        // Type references                                                                                             // 431
        TYPEREF: /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)+$/,                                                                   // 432
                                                                                                                       // 433
        // Fully qualified type references                                                                             // 434
        FQTYPEREF: /^(?:\.[a-zA-Z][a-zA-Z_0-9]*)+$/,                                                                   // 435
                                                                                                                       // 436
        // All numbers                                                                                                 // 437
        NUMBER: /^-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+|([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?)|inf|nan)$/,       // 438
                                                                                                                       // 439
        // Decimal numbers                                                                                             // 440
        NUMBER_DEC: /^(?:[1-9][0-9]*|0)$/,                                                                             // 441
                                                                                                                       // 442
        // Hexadecimal numbers                                                                                         // 443
        NUMBER_HEX: /^0[xX][0-9a-fA-F]+$/,                                                                             // 444
                                                                                                                       // 445
        // Octal numbers                                                                                               // 446
        NUMBER_OCT: /^0[0-7]+$/,                                                                                       // 447
                                                                                                                       // 448
        // Floating point numbers                                                                                      // 449
        NUMBER_FLT: /^([0-9]*(\.[0-9]*)?([Ee][+-]?[0-9]+)?|inf|nan)$/,                                                 // 450
                                                                                                                       // 451
        // Booleans                                                                                                    // 452
        BOOL: /^(?:true|false)$/i,                                                                                     // 453
                                                                                                                       // 454
        // Id numbers                                                                                                  // 455
        ID: /^(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,                                                           // 456
                                                                                                                       // 457
        // Negative id numbers (enum values)                                                                           // 458
        NEGID: /^\-?(?:[1-9][0-9]*|0|0[xX][0-9a-fA-F]+|0[0-7]+)$/,                                                     // 459
                                                                                                                       // 460
        // Whitespaces                                                                                                 // 461
        WHITESPACE: /\s/,                                                                                              // 462
                                                                                                                       // 463
        // All strings                                                                                                 // 464
        STRING: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")|(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g,                                      // 465
                                                                                                                       // 466
        // Double quoted strings                                                                                       // 467
        STRING_DQ: /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g,                                                                  // 468
                                                                                                                       // 469
        // Single quoted strings                                                                                       // 470
        STRING_SQ: /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g                                                                   // 471
    };                                                                                                                 // 472
                                                                                                                       // 473
    /**                                                                                                                // 474
     * @alias ProtoBuf.DotProto                                                                                        // 475
     * @expose                                                                                                         // 476
     */                                                                                                                // 477
    ProtoBuf.DotProto = (function(ProtoBuf, Lang) {                                                                    // 478
        "use strict";                                                                                                  // 479
                                                                                                                       // 480
        /**                                                                                                            // 481
         * Utilities to parse .proto files.                                                                            // 482
         * @exports ProtoBuf.DotProto                                                                                  // 483
         * @namespace                                                                                                  // 484
         */                                                                                                            // 485
        var DotProto = {};                                                                                             // 486
                                                                                                                       // 487
        /**                                                                                                            // 488
         * Constructs a new Tokenizer.                                                                                 // 489
         * @exports ProtoBuf.DotProto.Tokenizer                                                                        // 490
         * @class prototype tokenizer                                                                                  // 491
         * @param {string} proto Proto to tokenize                                                                     // 492
         * @constructor                                                                                                // 493
         */                                                                                                            // 494
        var Tokenizer = function(proto) {                                                                              // 495
                                                                                                                       // 496
            /**                                                                                                        // 497
             * Source to parse.                                                                                        // 498
             * @type {string}                                                                                          // 499
             * @expose                                                                                                 // 500
             */                                                                                                        // 501
            this.source = proto+"";                                                                                    // 502
                                                                                                                       // 503
            /**                                                                                                        // 504
             * Current index.                                                                                          // 505
             * @type {number}                                                                                          // 506
             * @expose                                                                                                 // 507
             */                                                                                                        // 508
            this.index = 0;                                                                                            // 509
                                                                                                                       // 510
            /**                                                                                                        // 511
             * Current line.                                                                                           // 512
             * @type {number}                                                                                          // 513
             * @expose                                                                                                 // 514
             */                                                                                                        // 515
            this.line = 1;                                                                                             // 516
                                                                                                                       // 517
            /**                                                                                                        // 518
             * Token stack.                                                                                            // 519
             * @type {!Array.<string>}                                                                                 // 520
             * @expose                                                                                                 // 521
             */                                                                                                        // 522
            this.stack = [];                                                                                           // 523
                                                                                                                       // 524
            /**                                                                                                        // 525
             * Opening character of the current string read, if any.                                                   // 526
             * @type {?string}                                                                                         // 527
             * @private                                                                                                // 528
             */                                                                                                        // 529
            this._stringOpen = null;                                                                                   // 530
        };                                                                                                             // 531
                                                                                                                       // 532
        /**                                                                                                            // 533
         * @alias ProtoBuf.DotProto.Tokenizer.prototype                                                                // 534
         * @inner                                                                                                      // 535
         */                                                                                                            // 536
        var TokenizerPrototype = Tokenizer.prototype;                                                                  // 537
                                                                                                                       // 538
        /**                                                                                                            // 539
         * Reads a string beginning at the current index.                                                              // 540
         * @return {string}                                                                                            // 541
         * @private                                                                                                    // 542
         */                                                                                                            // 543
        TokenizerPrototype._readString = function() {                                                                  // 544
            var re = this._stringOpen === '"'                                                                          // 545
                ? Lang.STRING_DQ                                                                                       // 546
                : Lang.STRING_SQ;                                                                                      // 547
            re.lastIndex = this.index - 1; // Include the open quote                                                   // 548
            var match = re.exec(this.source);                                                                          // 549
            if (!match)                                                                                                // 550
                throw Error("unterminated string");                                                                    // 551
            this.index = re.lastIndex;                                                                                 // 552
            this.stack.push(this._stringOpen);                                                                         // 553
            this._stringOpen = null;                                                                                   // 554
            return match[1];                                                                                           // 555
        };                                                                                                             // 556
                                                                                                                       // 557
        /**                                                                                                            // 558
         * Gets the next token and advances by one.                                                                    // 559
         * @return {?string} Token or `null` on EOF                                                                    // 560
         * @expose                                                                                                     // 561
         */                                                                                                            // 562
        TokenizerPrototype.next = function() {                                                                         // 563
            if (this.stack.length > 0)                                                                                 // 564
                return this.stack.shift();                                                                             // 565
            if (this.index >= this.source.length)                                                                      // 566
                return null;                                                                                           // 567
            if (this._stringOpen !== null)                                                                             // 568
                return this._readString();                                                                             // 569
                                                                                                                       // 570
            var repeat,                                                                                                // 571
                prev,                                                                                                  // 572
                next;                                                                                                  // 573
            do {                                                                                                       // 574
                repeat = false;                                                                                        // 575
                                                                                                                       // 576
                // Strip white spaces                                                                                  // 577
                while (Lang.WHITESPACE.test(next = this.source.charAt(this.index))) {                                  // 578
                    if (next === '\n')                                                                                 // 579
                        ++this.line;                                                                                   // 580
                    if (++this.index === this.source.length)                                                           // 581
                        return null;                                                                                   // 582
                }                                                                                                      // 583
                                                                                                                       // 584
                // Strip comments                                                                                      // 585
                if (this.source.charAt(this.index) === '/') {                                                          // 586
                    ++this.index;                                                                                      // 587
                    if (this.source.charAt(this.index) === '/') { // Line                                              // 588
                        while (this.source.charAt(++this.index) !== '\n')                                              // 589
                            if (this.index == this.source.length)                                                      // 590
                                return null;                                                                           // 591
                        ++this.index;                                                                                  // 592
                        ++this.line;                                                                                   // 593
                        repeat = true;                                                                                 // 594
                    } else if ((next = this.source.charAt(this.index)) === '*') { /* Block */                          // 595
                        do {                                                                                           // 596
                            if (next === '\n')                                                                         // 597
                                ++this.line;                                                                           // 598
                            if (++this.index === this.source.length)                                                   // 599
                                return null;                                                                           // 600
                            prev = next;                                                                               // 601
                            next = this.source.charAt(this.index);                                                     // 602
                        } while (prev !== '*' || next !== '/');                                                        // 603
                        ++this.index;                                                                                  // 604
                        repeat = true;                                                                                 // 605
                    } else                                                                                             // 606
                        return '/';                                                                                    // 607
                }                                                                                                      // 608
            } while (repeat);                                                                                          // 609
                                                                                                                       // 610
            if (this.index === this.source.length)                                                                     // 611
                return null;                                                                                           // 612
                                                                                                                       // 613
            // Read the next token                                                                                     // 614
            var end = this.index;                                                                                      // 615
            Lang.DELIM.lastIndex = 0;                                                                                  // 616
            var delim = Lang.DELIM.test(this.source.charAt(end++));                                                    // 617
            if (!delim)                                                                                                // 618
                while(end < this.source.length && !Lang.DELIM.test(this.source.charAt(end)))                           // 619
                    ++end;                                                                                             // 620
            var token = this.source.substring(this.index, this.index = end);                                           // 621
            if (token === '"' || token === "'")                                                                        // 622
                this._stringOpen = token;                                                                              // 623
            return token;                                                                                              // 624
        };                                                                                                             // 625
                                                                                                                       // 626
        /**                                                                                                            // 627
         * Peeks for the next token.                                                                                   // 628
         * @return {?string} Token or `null` on EOF                                                                    // 629
         * @expose                                                                                                     // 630
         */                                                                                                            // 631
        TokenizerPrototype.peek = function() {                                                                         // 632
            if (this.stack.length === 0) {                                                                             // 633
                var token = this.next();                                                                               // 634
                if (token === null)                                                                                    // 635
                    return null;                                                                                       // 636
                this.stack.push(token);                                                                                // 637
            }                                                                                                          // 638
            return this.stack[0];                                                                                      // 639
        };                                                                                                             // 640
                                                                                                                       // 641
        /**                                                                                                            // 642
         * Skips a specific token and throws if it differs.                                                            // 643
         * @param {string} expected Expected token                                                                     // 644
         * @throws {Error} If the actual token differs                                                                 // 645
         */                                                                                                            // 646
        TokenizerPrototype.skip = function(expected) {                                                                 // 647
            var actual = this.next();                                                                                  // 648
            if (actual !== expected)                                                                                   // 649
                throw Error("illegal '"+actual+"', '"+expected+"' expected");                                          // 650
        };                                                                                                             // 651
                                                                                                                       // 652
        /**                                                                                                            // 653
         * Omits an optional token.                                                                                    // 654
         * @param {string} expected Expected optional token                                                            // 655
         * @returns {boolean} `true` if the token exists                                                               // 656
         */                                                                                                            // 657
        TokenizerPrototype.omit = function(expected) {                                                                 // 658
            if (this.peek() === expected) {                                                                            // 659
                this.next();                                                                                           // 660
                return true;                                                                                           // 661
            }                                                                                                          // 662
            return false;                                                                                              // 663
        };                                                                                                             // 664
                                                                                                                       // 665
        /**                                                                                                            // 666
         * Returns a string representation of this object.                                                             // 667
         * @return {string} String representation as of "Tokenizer(index/length)"                                      // 668
         * @expose                                                                                                     // 669
         */                                                                                                            // 670
        TokenizerPrototype.toString = function() {                                                                     // 671
            return "Tokenizer ("+this.index+"/"+this.source.length+" at line "+this.line+")";                          // 672
        };                                                                                                             // 673
                                                                                                                       // 674
        /**                                                                                                            // 675
         * @alias ProtoBuf.DotProto.Tokenizer                                                                          // 676
         * @expose                                                                                                     // 677
         */                                                                                                            // 678
        DotProto.Tokenizer = Tokenizer;                                                                                // 679
                                                                                                                       // 680
        /**                                                                                                            // 681
         * Constructs a new Parser.                                                                                    // 682
         * @exports ProtoBuf.DotProto.Parser                                                                           // 683
         * @class prototype parser                                                                                     // 684
         * @param {string} source Source                                                                               // 685
         * @constructor                                                                                                // 686
         */                                                                                                            // 687
        var Parser = function(source) {                                                                                // 688
                                                                                                                       // 689
            /**                                                                                                        // 690
             * Tokenizer.                                                                                              // 691
             * @type {!ProtoBuf.DotProto.Tokenizer}                                                                    // 692
             * @expose                                                                                                 // 693
             */                                                                                                        // 694
            this.tn = new Tokenizer(source);                                                                           // 695
                                                                                                                       // 696
            /**                                                                                                        // 697
             * Whether parsing proto3 or not.                                                                          // 698
             * @type {boolean}                                                                                         // 699
             */                                                                                                        // 700
            this.proto3 = false;                                                                                       // 701
        };                                                                                                             // 702
                                                                                                                       // 703
        /**                                                                                                            // 704
         * @alias ProtoBuf.DotProto.Parser.prototype                                                                   // 705
         * @inner                                                                                                      // 706
         */                                                                                                            // 707
        var ParserPrototype = Parser.prototype;                                                                        // 708
                                                                                                                       // 709
        /**                                                                                                            // 710
         * Parses the source.                                                                                          // 711
         * @returns {!Object}                                                                                          // 712
         * @throws {Error} If the source cannot be parsed                                                              // 713
         * @expose                                                                                                     // 714
         */                                                                                                            // 715
        ParserPrototype.parse = function() {                                                                           // 716
            var topLevel = {                                                                                           // 717
                "name": "[ROOT]", // temporary                                                                         // 718
                "package": null,                                                                                       // 719
                "messages": [],                                                                                        // 720
                "enums": [],                                                                                           // 721
                "imports": [],                                                                                         // 722
                "options": {},                                                                                         // 723
                "services": []                                                                                         // 724
                // "syntax": undefined                                                                                 // 725
            };                                                                                                         // 726
            var token,                                                                                                 // 727
                head = true,                                                                                           // 728
                weak;                                                                                                  // 729
            try {                                                                                                      // 730
                while (token = this.tn.next()) {                                                                       // 731
                    switch (token) {                                                                                   // 732
                        case 'package':                                                                                // 733
                            if (!head || topLevel["package"] !== null)                                                 // 734
                                throw Error("unexpected 'package'");                                                   // 735
                            token = this.tn.next();                                                                    // 736
                            if (!Lang.TYPEREF.test(token))                                                             // 737
                                throw Error("illegal package name: " + token);                                         // 738
                            this.tn.skip(";");                                                                         // 739
                            topLevel["package"] = token;                                                               // 740
                            break;                                                                                     // 741
                        case 'import':                                                                                 // 742
                            if (!head)                                                                                 // 743
                                throw Error("unexpected 'import'");                                                    // 744
                            token = this.tn.peek();                                                                    // 745
                            if (token === "public" || (weak = token === "weak")) // token ignored                      // 746
                                this.tn.next();                                                                        // 747
                            token = this._readString();                                                                // 748
                            this.tn.skip(";");                                                                         // 749
                            if (!weak) // import ignored                                                               // 750
                                topLevel["imports"].push(token);                                                       // 751
                            break;                                                                                     // 752
                        case 'syntax':                                                                                 // 753
                            if (!head)                                                                                 // 754
                                throw Error("unexpected 'syntax'");                                                    // 755
                            this.tn.skip("=");                                                                         // 756
                            if ((topLevel["syntax"] = this._readString()) === "proto3")                                // 757
                                this.proto3 = true;                                                                    // 758
                            this.tn.skip(";");                                                                         // 759
                            break;                                                                                     // 760
                        case 'message':                                                                                // 761
                            this._parseMessage(topLevel, null);                                                        // 762
                            head = false;                                                                              // 763
                            break;                                                                                     // 764
                        case 'enum':                                                                                   // 765
                            this._parseEnum(topLevel);                                                                 // 766
                            head = false;                                                                              // 767
                            break;                                                                                     // 768
                        case 'option':                                                                                 // 769
                            this._parseOption(topLevel);                                                               // 770
                            break;                                                                                     // 771
                        case 'service':                                                                                // 772
                            this._parseService(topLevel);                                                              // 773
                            break;                                                                                     // 774
                        case 'extend':                                                                                 // 775
                            this._parseExtend(topLevel);                                                               // 776
                            break;                                                                                     // 777
                        default:                                                                                       // 778
                            throw Error("unexpected '" + token + "'");                                                 // 779
                    }                                                                                                  // 780
                }                                                                                                      // 781
            } catch (e) {                                                                                              // 782
                e.message = "Parse error at line "+this.tn.line+": " + e.message;                                      // 783
                throw e;                                                                                               // 784
            }                                                                                                          // 785
            delete topLevel["name"];                                                                                   // 786
            return topLevel;                                                                                           // 787
        };                                                                                                             // 788
                                                                                                                       // 789
        /**                                                                                                            // 790
         * Parses the specified source.                                                                                // 791
         * @returns {!Object}                                                                                          // 792
         * @throws {Error} If the source cannot be parsed                                                              // 793
         * @expose                                                                                                     // 794
         */                                                                                                            // 795
        Parser.parse = function(source) {                                                                              // 796
            return new Parser(source).parse();                                                                         // 797
        };                                                                                                             // 798
                                                                                                                       // 799
        // ----- Conversion ------                                                                                     // 800
                                                                                                                       // 801
        /**                                                                                                            // 802
         * Converts a numerical string to an id.                                                                       // 803
         * @param {string} value                                                                                       // 804
         * @param {boolean=} mayBeNegative                                                                             // 805
         * @returns {number}                                                                                           // 806
         * @inner                                                                                                      // 807
         */                                                                                                            // 808
        function mkId(value, mayBeNegative) {                                                                          // 809
            var id = -1,                                                                                               // 810
                sign = 1;                                                                                              // 811
            if (value.charAt(0) == '-') {                                                                              // 812
                sign = -1;                                                                                             // 813
                value = value.substring(1);                                                                            // 814
            }                                                                                                          // 815
            if (Lang.NUMBER_DEC.test(value))                                                                           // 816
                id = parseInt(value);                                                                                  // 817
            else if (Lang.NUMBER_HEX.test(value))                                                                      // 818
                id = parseInt(value.substring(2), 16);                                                                 // 819
            else if (Lang.NUMBER_OCT.test(value))                                                                      // 820
                id = parseInt(value.substring(1), 8);                                                                  // 821
            else                                                                                                       // 822
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);                                     // 823
            id = (sign*id)|0; // Force to 32bit                                                                        // 824
            if (!mayBeNegative && id < 0)                                                                              // 825
                throw Error("illegal id value: " + (sign < 0 ? '-' : '') + value);                                     // 826
            return id;                                                                                                 // 827
        }                                                                                                              // 828
                                                                                                                       // 829
        /**                                                                                                            // 830
         * Converts a numerical string to a number.                                                                    // 831
         * @param {string} val                                                                                         // 832
         * @returns {number}                                                                                           // 833
         * @inner                                                                                                      // 834
         */                                                                                                            // 835
        function mkNumber(val) {                                                                                       // 836
            var sign = 1;                                                                                              // 837
            if (val.charAt(0) == '-') {                                                                                // 838
                sign = -1;                                                                                             // 839
                val = val.substring(1);                                                                                // 840
            }                                                                                                          // 841
            if (Lang.NUMBER_DEC.test(val))                                                                             // 842
                return sign * parseInt(val, 10);                                                                       // 843
            else if (Lang.NUMBER_HEX.test(val))                                                                        // 844
                return sign * parseInt(val.substring(2), 16);                                                          // 845
            else if (Lang.NUMBER_OCT.test(val))                                                                        // 846
                return sign * parseInt(val.substring(1), 8);                                                           // 847
            else if (val === 'inf')                                                                                    // 848
                return sign * Infinity;                                                                                // 849
            else if (val === 'nan')                                                                                    // 850
                return NaN;                                                                                            // 851
            else if (Lang.NUMBER_FLT.test(val))                                                                        // 852
                return sign * parseFloat(val);                                                                         // 853
            throw Error("illegal number value: " + (sign < 0 ? '-' : '') + val);                                       // 854
        }                                                                                                              // 855
                                                                                                                       // 856
        // ----- Reading ------                                                                                        // 857
                                                                                                                       // 858
        /**                                                                                                            // 859
         * Reads a string.                                                                                             // 860
         * @returns {string}                                                                                           // 861
         * @private                                                                                                    // 862
         */                                                                                                            // 863
        ParserPrototype._readString = function() {                                                                     // 864
            var value = "",                                                                                            // 865
                token,                                                                                                 // 866
                delim;                                                                                                 // 867
            do {                                                                                                       // 868
                delim = this.tn.next();                                                                                // 869
                if (delim !== "'" && delim !== '"')                                                                    // 870
                    throw Error("illegal string delimiter: "+delim);                                                   // 871
                value += this.tn.next();                                                                               // 872
                this.tn.skip(delim);                                                                                   // 873
                token = this.tn.peek();                                                                                // 874
            } while (token === '"' || token === '"'); // multi line?                                                   // 875
            return value;                                                                                              // 876
        };                                                                                                             // 877
                                                                                                                       // 878
        /**                                                                                                            // 879
         * Reads a value.                                                                                              // 880
         * @param {boolean=} mayBeTypeRef                                                                              // 881
         * @returns {number|boolean|string}                                                                            // 882
         * @private                                                                                                    // 883
         */                                                                                                            // 884
        ParserPrototype._readValue = function(mayBeTypeRef) {                                                          // 885
            var token = this.tn.peek(),                                                                                // 886
                value;                                                                                                 // 887
            if (token === '"' || token === "'")                                                                        // 888
                return this._readString();                                                                             // 889
            this.tn.next();                                                                                            // 890
            if (Lang.NUMBER.test(token))                                                                               // 891
                return mkNumber(token);                                                                                // 892
            if (Lang.BOOL.test(token))                                                                                 // 893
                return (token.toLowerCase() === 'true');                                                               // 894
            if (mayBeTypeRef && Lang.TYPEREF.test(token))                                                              // 895
                return token;                                                                                          // 896
            throw Error("illegal value: "+token);                                                                      // 897
                                                                                                                       // 898
        };                                                                                                             // 899
                                                                                                                       // 900
        // ----- Parsing constructs -----                                                                              // 901
                                                                                                                       // 902
        /**                                                                                                            // 903
         * Parses a namespace option.                                                                                  // 904
         * @param {!Object} parent Parent definition                                                                   // 905
         * @param {boolean=} isList                                                                                    // 906
         * @private                                                                                                    // 907
         */                                                                                                            // 908
        ParserPrototype._parseOption = function(parent, isList) {                                                      // 909
            var token = this.tn.next(),                                                                                // 910
                custom = false;                                                                                        // 911
            if (token === '(') {                                                                                       // 912
                custom = true;                                                                                         // 913
                token = this.tn.next();                                                                                // 914
            }                                                                                                          // 915
            if (!Lang.TYPEREF.test(token))                                                                             // 916
                // we can allow options of the form google.protobuf.* since they will just get ignored anyways         // 917
                // if (!/google\.protobuf\./.test(token)) // FIXME: Why should that not be a valid typeref?            // 918
                    throw Error("illegal option name: "+token);                                                        // 919
            var name = token;                                                                                          // 920
            if (custom) { // (my_method_option).foo, (my_method_option), some_method_option, (foo.my_option).bar       // 921
                this.tn.skip(')');                                                                                     // 922
                name = '('+name+')';                                                                                   // 923
                token = this.tn.peek();                                                                                // 924
                if (Lang.FQTYPEREF.test(token)) {                                                                      // 925
                    name += token;                                                                                     // 926
                    this.tn.next();                                                                                    // 927
                }                                                                                                      // 928
            }                                                                                                          // 929
            this.tn.skip('=');                                                                                         // 930
            this._parseOptionValue(parent, name);                                                                      // 931
            if (!isList)                                                                                               // 932
                this.tn.skip(";");                                                                                     // 933
        };                                                                                                             // 934
                                                                                                                       // 935
        /**                                                                                                            // 936
         * Sets an option on the specified options object.                                                             // 937
         * @param {!Object.<string,*>} options                                                                         // 938
         * @param {string} name                                                                                        // 939
         * @param {string|number|boolean} value                                                                        // 940
         * @inner                                                                                                      // 941
         */                                                                                                            // 942
        function setOption(options, name, value) {                                                                     // 943
            if (typeof options[name] === 'undefined')                                                                  // 944
                options[name] = value;                                                                                 // 945
            else {                                                                                                     // 946
                if (!Array.isArray(options[name]))                                                                     // 947
                    options[name] = [ options[name] ];                                                                 // 948
                options[name].push(value);                                                                             // 949
            }                                                                                                          // 950
        }                                                                                                              // 951
                                                                                                                       // 952
        /**                                                                                                            // 953
         * Parses an option value.                                                                                     // 954
         * @param {!Object} parent                                                                                     // 955
         * @param {string} name                                                                                        // 956
         * @private                                                                                                    // 957
         */                                                                                                            // 958
        ParserPrototype._parseOptionValue = function(parent, name) {                                                   // 959
            var token = this.tn.peek();                                                                                // 960
            if (token !== '{') { // Plain value                                                                        // 961
                setOption(parent["options"], name, this._readValue(true));                                             // 962
            } else { // Aggregate options                                                                              // 963
                this.tn.skip("{");                                                                                     // 964
                while ((token = this.tn.next()) !== '}') {                                                             // 965
                    if (!Lang.NAME.test(token))                                                                        // 966
                        throw Error("illegal option name: " + name + "." + token);                                     // 967
                    if (this.tn.omit(":"))                                                                             // 968
                        setOption(parent["options"], name + "." + token, this._readValue(true));                       // 969
                    else                                                                                               // 970
                        this._parseOptionValue(parent, name + "." + token);                                            // 971
                }                                                                                                      // 972
            }                                                                                                          // 973
        };                                                                                                             // 974
                                                                                                                       // 975
        /**                                                                                                            // 976
         * Parses a service definition.                                                                                // 977
         * @param {!Object} parent Parent definition                                                                   // 978
         * @private                                                                                                    // 979
         */                                                                                                            // 980
        ParserPrototype._parseService = function(parent) {                                                             // 981
            var token = this.tn.next();                                                                                // 982
            if (!Lang.NAME.test(token))                                                                                // 983
                throw Error("illegal service name at line "+this.tn.line+": "+token);                                  // 984
            var name = token;                                                                                          // 985
            var svc = {                                                                                                // 986
                "name": name,                                                                                          // 987
                "rpc": {},                                                                                             // 988
                "options": {}                                                                                          // 989
            };                                                                                                         // 990
            this.tn.skip("{");                                                                                         // 991
            while ((token = this.tn.next()) !== '}') {                                                                 // 992
                if (token === "option")                                                                                // 993
                    this._parseOption(svc);                                                                            // 994
                else if (token === 'rpc')                                                                              // 995
                    this._parseServiceRPC(svc);                                                                        // 996
                else                                                                                                   // 997
                    throw Error("illegal service token: "+token);                                                      // 998
            }                                                                                                          // 999
            this.tn.omit(";");                                                                                         // 1000
            parent["services"].push(svc);                                                                              // 1001
        };                                                                                                             // 1002
                                                                                                                       // 1003
        /**                                                                                                            // 1004
         * Parses a RPC service definition of the form ['rpc', name, (request), 'returns', (response)].                // 1005
         * @param {!Object} svc Service definition                                                                     // 1006
         * @private                                                                                                    // 1007
         */                                                                                                            // 1008
        ParserPrototype._parseServiceRPC = function(svc) {                                                             // 1009
            var type = "rpc",                                                                                          // 1010
                token = this.tn.next();                                                                                // 1011
            if (!Lang.NAME.test(token))                                                                                // 1012
                throw Error("illegal rpc service method name: "+token);                                                // 1013
            var name = token;                                                                                          // 1014
            var method = {                                                                                             // 1015
                "request": null,                                                                                       // 1016
                "response": null,                                                                                      // 1017
                "request_stream": false,                                                                               // 1018
                "response_stream": false,                                                                              // 1019
                "options": {}                                                                                          // 1020
            };                                                                                                         // 1021
            this.tn.skip("(");                                                                                         // 1022
            token = this.tn.next();                                                                                    // 1023
            if (token.toLowerCase() === "stream") {                                                                    // 1024
              method["request_stream"] = true;                                                                         // 1025
              token = this.tn.next();                                                                                  // 1026
            }                                                                                                          // 1027
            if (!Lang.TYPEREF.test(token))                                                                             // 1028
                throw Error("illegal rpc service request type: "+token);                                               // 1029
            method["request"] = token;                                                                                 // 1030
            this.tn.skip(")");                                                                                         // 1031
            token = this.tn.next();                                                                                    // 1032
            if (token.toLowerCase() !== "returns")                                                                     // 1033
                throw Error("illegal rpc service request type delimiter: "+token);                                     // 1034
            this.tn.skip("(");                                                                                         // 1035
            token = this.tn.next();                                                                                    // 1036
            if (token.toLowerCase() === "stream") {                                                                    // 1037
              method["response_stream"] = true;                                                                        // 1038
              token = this.tn.next();                                                                                  // 1039
            }                                                                                                          // 1040
            method["response"] = token;                                                                                // 1041
            this.tn.skip(")");                                                                                         // 1042
            token = this.tn.peek();                                                                                    // 1043
            if (token === '{') {                                                                                       // 1044
                this.tn.next();                                                                                        // 1045
                while ((token = this.tn.next()) !== '}') {                                                             // 1046
                    if (token === 'option')                                                                            // 1047
                        this._parseOption(method);                                                                     // 1048
                    else                                                                                               // 1049
                        throw Error("illegal rpc service token: " + token);                                            // 1050
                }                                                                                                      // 1051
                this.tn.omit(";");                                                                                     // 1052
            } else                                                                                                     // 1053
                this.tn.skip(";");                                                                                     // 1054
            if (typeof svc[type] === 'undefined')                                                                      // 1055
                svc[type] = {};                                                                                        // 1056
            svc[type][name] = method;                                                                                  // 1057
        };                                                                                                             // 1058
                                                                                                                       // 1059
        /**                                                                                                            // 1060
         * Parses a message definition.                                                                                // 1061
         * @param {!Object} parent Parent definition                                                                   // 1062
         * @param {!Object=} fld Field definition if this is a group                                                   // 1063
         * @returns {!Object}                                                                                          // 1064
         * @private                                                                                                    // 1065
         */                                                                                                            // 1066
        ParserPrototype._parseMessage = function(parent, fld) {                                                        // 1067
            var isGroup = !!fld,                                                                                       // 1068
                token = this.tn.next();                                                                                // 1069
            var msg = {                                                                                                // 1070
                "name": "",                                                                                            // 1071
                "fields": [],                                                                                          // 1072
                "enums": [],                                                                                           // 1073
                "messages": [],                                                                                        // 1074
                "options": {},                                                                                         // 1075
                "services": [],                                                                                        // 1076
                "oneofs": {}                                                                                           // 1077
                // "extensions": undefined                                                                             // 1078
            };                                                                                                         // 1079
            if (!Lang.NAME.test(token))                                                                                // 1080
                throw Error("illegal "+(isGroup ? "group" : "message")+" name: "+token);                               // 1081
            msg["name"] = token;                                                                                       // 1082
            if (isGroup) {                                                                                             // 1083
                this.tn.skip("=");                                                                                     // 1084
                fld["id"] = mkId(this.tn.next());                                                                      // 1085
                msg["isGroup"] = true;                                                                                 // 1086
            }                                                                                                          // 1087
            token = this.tn.peek();                                                                                    // 1088
            if (token === '[' && fld)                                                                                  // 1089
                this._parseFieldOptions(fld);                                                                          // 1090
            this.tn.skip("{");                                                                                         // 1091
            while ((token = this.tn.next()) !== '}') {                                                                 // 1092
                if (Lang.RULE.test(token))                                                                             // 1093
                    this._parseMessageField(msg, token);                                                               // 1094
                else if (token === "oneof")                                                                            // 1095
                    this._parseMessageOneOf(msg);                                                                      // 1096
                else if (token === "enum")                                                                             // 1097
                    this._parseEnum(msg);                                                                              // 1098
                else if (token === "message")                                                                          // 1099
                    this._parseMessage(msg);                                                                           // 1100
                else if (token === "option")                                                                           // 1101
                    this._parseOption(msg);                                                                            // 1102
                else if (token === "service")                                                                          // 1103
                    this._parseService(msg);                                                                           // 1104
                else if (token === "extensions")                                                                       // 1105
                    msg["extensions"] = this._parseExtensionRanges();                                                  // 1106
                else if (token === "reserved")                                                                         // 1107
                    this._parseIgnored(); // TODO                                                                      // 1108
                else if (token === "extend")                                                                           // 1109
                    this._parseExtend(msg);                                                                            // 1110
                else if (Lang.TYPEREF.test(token)) {                                                                   // 1111
                    if (!this.proto3)                                                                                  // 1112
                        throw Error("illegal field rule: "+token);                                                     // 1113
                    this._parseMessageField(msg, "optional", token);                                                   // 1114
                } else                                                                                                 // 1115
                    throw Error("illegal message token: "+token);                                                      // 1116
            }                                                                                                          // 1117
            this.tn.omit(";");                                                                                         // 1118
            parent["messages"].push(msg);                                                                              // 1119
            return msg;                                                                                                // 1120
        };                                                                                                             // 1121
                                                                                                                       // 1122
        /**                                                                                                            // 1123
         * Parses an ignored statement.                                                                                // 1124
         * @private                                                                                                    // 1125
         */                                                                                                            // 1126
        ParserPrototype._parseIgnored = function() {                                                                   // 1127
            while (this.tn.peek() !== ';')                                                                             // 1128
                this.tn.next();                                                                                        // 1129
            this.tn.skip(";");                                                                                         // 1130
        };                                                                                                             // 1131
                                                                                                                       // 1132
        /**                                                                                                            // 1133
         * Parses a message field.                                                                                     // 1134
         * @param {!Object} msg Message definition                                                                     // 1135
         * @param {string} rule Field rule                                                                             // 1136
         * @param {string=} type Field type if already known (never known for maps)                                    // 1137
         * @returns {!Object} Field descriptor                                                                         // 1138
         * @private                                                                                                    // 1139
         */                                                                                                            // 1140
        ParserPrototype._parseMessageField = function(msg, rule, type) {                                               // 1141
            if (!Lang.RULE.test(rule))                                                                                 // 1142
                throw Error("illegal message field rule: "+rule);                                                      // 1143
            var fld = {                                                                                                // 1144
                "rule": rule,                                                                                          // 1145
                "type": "",                                                                                            // 1146
                "name": "",                                                                                            // 1147
                "options": {},                                                                                         // 1148
                "id": 0                                                                                                // 1149
            };                                                                                                         // 1150
            var token;                                                                                                 // 1151
            if (rule === "map") {                                                                                      // 1152
                                                                                                                       // 1153
                if (type)                                                                                              // 1154
                    throw Error("illegal type: " + type);                                                              // 1155
                this.tn.skip('<');                                                                                     // 1156
                token = this.tn.next();                                                                                // 1157
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))                                               // 1158
                    throw Error("illegal message field type: " + token);                                               // 1159
                fld["keytype"] = token;                                                                                // 1160
                this.tn.skip(',');                                                                                     // 1161
                token = this.tn.next();                                                                                // 1162
                if (!Lang.TYPE.test(token) && !Lang.TYPEREF.test(token))                                               // 1163
                    throw Error("illegal message field: " + token);                                                    // 1164
                fld["type"] = token;                                                                                   // 1165
                this.tn.skip('>');                                                                                     // 1166
                token = this.tn.next();                                                                                // 1167
                if (!Lang.NAME.test(token))                                                                            // 1168
                    throw Error("illegal message field name: " + token);                                               // 1169
                fld["name"] = token;                                                                                   // 1170
                this.tn.skip("=");                                                                                     // 1171
                fld["id"] = mkId(this.tn.next());                                                                      // 1172
                token = this.tn.peek();                                                                                // 1173
                if (token === '[')                                                                                     // 1174
                    this._parseFieldOptions(fld);                                                                      // 1175
                this.tn.skip(";");                                                                                     // 1176
                                                                                                                       // 1177
            } else {                                                                                                   // 1178
                                                                                                                       // 1179
                type = typeof type !== 'undefined' ? type : this.tn.next();                                            // 1180
                                                                                                                       // 1181
                if (type === "group") {                                                                                // 1182
                                                                                                                       // 1183
                    // "A [legacy] group simply combines a nested message type and a field into a single declaration. In your
                    // code, you can treat this message just as if it had a Result type field called result (the latter name is
                    // converted to lower-case so that it does not conflict with the former)."                         // 1186
                    var grp = this._parseMessage(msg, fld);                                                            // 1187
                    if (!/^[A-Z]/.test(grp["name"]))                                                                   // 1188
                        throw Error('illegal group name: '+grp["name"]);                                               // 1189
                    fld["type"] = grp["name"];                                                                         // 1190
                    fld["name"] = grp["name"].toLowerCase();                                                           // 1191
                    this.tn.omit(";");                                                                                 // 1192
                                                                                                                       // 1193
                } else {                                                                                               // 1194
                                                                                                                       // 1195
                    if (!Lang.TYPE.test(type) && !Lang.TYPEREF.test(type))                                             // 1196
                        throw Error("illegal message field type: " + type);                                            // 1197
                    fld["type"] = type;                                                                                // 1198
                    token = this.tn.next();                                                                            // 1199
                    if (!Lang.NAME.test(token))                                                                        // 1200
                        throw Error("illegal message field name: " + token);                                           // 1201
                    fld["name"] = token;                                                                               // 1202
                    this.tn.skip("=");                                                                                 // 1203
                    fld["id"] = mkId(this.tn.next());                                                                  // 1204
                    token = this.tn.peek();                                                                            // 1205
                    if (token === "[")                                                                                 // 1206
                        this._parseFieldOptions(fld);                                                                  // 1207
                    this.tn.skip(";");                                                                                 // 1208
                                                                                                                       // 1209
                }                                                                                                      // 1210
            }                                                                                                          // 1211
            msg["fields"].push(fld);                                                                                   // 1212
            return fld;                                                                                                // 1213
        };                                                                                                             // 1214
                                                                                                                       // 1215
        /**                                                                                                            // 1216
         * Parses a message oneof.                                                                                     // 1217
         * @param {!Object} msg Message definition                                                                     // 1218
         * @private                                                                                                    // 1219
         */                                                                                                            // 1220
        ParserPrototype._parseMessageOneOf = function(msg) {                                                           // 1221
            var token = this.tn.next();                                                                                // 1222
            if (!Lang.NAME.test(token))                                                                                // 1223
                throw Error("illegal oneof name: "+token);                                                             // 1224
            var name = token,                                                                                          // 1225
                fld;                                                                                                   // 1226
            var fields = [];                                                                                           // 1227
            this.tn.skip("{");                                                                                         // 1228
            while ((token = this.tn.next()) !== "}") {                                                                 // 1229
                fld = this._parseMessageField(msg, "optional", token);                                                 // 1230
                fld["oneof"] = name;                                                                                   // 1231
                fields.push(fld["id"]);                                                                                // 1232
            }                                                                                                          // 1233
            this.tn.omit(";");                                                                                         // 1234
            msg["oneofs"][name] = fields;                                                                              // 1235
        };                                                                                                             // 1236
                                                                                                                       // 1237
        /**                                                                                                            // 1238
         * Parses a set of field option definitions.                                                                   // 1239
         * @param {!Object} fld Field definition                                                                       // 1240
         * @private                                                                                                    // 1241
         */                                                                                                            // 1242
        ParserPrototype._parseFieldOptions = function(fld) {                                                           // 1243
            this.tn.skip("[");                                                                                         // 1244
            var token,                                                                                                 // 1245
                first = true;                                                                                          // 1246
            while ((token = this.tn.peek()) !== ']') {                                                                 // 1247
                if (!first)                                                                                            // 1248
                    this.tn.skip(",");                                                                                 // 1249
                this._parseOption(fld, true);                                                                          // 1250
                first = false;                                                                                         // 1251
            }                                                                                                          // 1252
            this.tn.next();                                                                                            // 1253
        };                                                                                                             // 1254
                                                                                                                       // 1255
        /**                                                                                                            // 1256
         * Parses an enum.                                                                                             // 1257
         * @param {!Object} msg Message definition                                                                     // 1258
         * @private                                                                                                    // 1259
         */                                                                                                            // 1260
        ParserPrototype._parseEnum = function(msg) {                                                                   // 1261
            var enm = {                                                                                                // 1262
                "name": "",                                                                                            // 1263
                "values": [],                                                                                          // 1264
                "options": {}                                                                                          // 1265
            };                                                                                                         // 1266
            var token = this.tn.next();                                                                                // 1267
            if (!Lang.NAME.test(token))                                                                                // 1268
                throw Error("illegal name: "+token);                                                                   // 1269
            enm["name"] = token;                                                                                       // 1270
            this.tn.skip("{");                                                                                         // 1271
            while ((token = this.tn.next()) !== '}') {                                                                 // 1272
                if (token === "option")                                                                                // 1273
                    this._parseOption(enm);                                                                            // 1274
                else {                                                                                                 // 1275
                    if (!Lang.NAME.test(token))                                                                        // 1276
                        throw Error("illegal name: "+token);                                                           // 1277
                    this.tn.skip("=");                                                                                 // 1278
                    var val = {                                                                                        // 1279
                        "name": token,                                                                                 // 1280
                        "id": mkId(this.tn.next(), true)                                                               // 1281
                    };                                                                                                 // 1282
                    token = this.tn.peek();                                                                            // 1283
                    if (token === "[")                                                                                 // 1284
                        this._parseFieldOptions({ "options": {} });                                                    // 1285
                    this.tn.skip(";");                                                                                 // 1286
                    enm["values"].push(val);                                                                           // 1287
                }                                                                                                      // 1288
            }                                                                                                          // 1289
            this.tn.omit(";");                                                                                         // 1290
            msg["enums"].push(enm);                                                                                    // 1291
        };                                                                                                             // 1292
                                                                                                                       // 1293
        /**                                                                                                            // 1294
         * Parses extension / reserved ranges.                                                                         // 1295
         * @returns {!Array.<!Array.<number>>}                                                                         // 1296
         * @private                                                                                                    // 1297
         */                                                                                                            // 1298
        ParserPrototype._parseExtensionRanges = function() {                                                           // 1299
            var ranges = [];                                                                                           // 1300
            var token,                                                                                                 // 1301
                range,                                                                                                 // 1302
                value;                                                                                                 // 1303
            do {                                                                                                       // 1304
                range = [];                                                                                            // 1305
                while (true) {                                                                                         // 1306
                    token = this.tn.next();                                                                            // 1307
                    switch (token) {                                                                                   // 1308
                        case "min":                                                                                    // 1309
                            value = ProtoBuf.ID_MIN;                                                                   // 1310
                            break;                                                                                     // 1311
                        case "max":                                                                                    // 1312
                            value = ProtoBuf.ID_MAX;                                                                   // 1313
                            break;                                                                                     // 1314
                        default:                                                                                       // 1315
                            value = mkNumber(token);                                                                   // 1316
                            break;                                                                                     // 1317
                    }                                                                                                  // 1318
                    range.push(value);                                                                                 // 1319
                    if (range.length === 2)                                                                            // 1320
                        break;                                                                                         // 1321
                    if (this.tn.peek() !== "to") {                                                                     // 1322
                        range.push(value);                                                                             // 1323
                        break;                                                                                         // 1324
                    }                                                                                                  // 1325
                    this.tn.next();                                                                                    // 1326
                }                                                                                                      // 1327
                ranges.push(range);                                                                                    // 1328
            } while (this.tn.omit(","));                                                                               // 1329
            this.tn.skip(";");                                                                                         // 1330
            return ranges;                                                                                             // 1331
        };                                                                                                             // 1332
                                                                                                                       // 1333
        /**                                                                                                            // 1334
         * Parses an extend block.                                                                                     // 1335
         * @param {!Object} parent Parent object                                                                       // 1336
         * @private                                                                                                    // 1337
         */                                                                                                            // 1338
        ParserPrototype._parseExtend = function(parent) {                                                              // 1339
            var token = this.tn.next();                                                                                // 1340
            if (!Lang.TYPEREF.test(token))                                                                             // 1341
                throw Error("illegal extend reference: "+token);                                                       // 1342
            var ext = {                                                                                                // 1343
                "ref": token,                                                                                          // 1344
                "fields": []                                                                                           // 1345
            };                                                                                                         // 1346
            this.tn.skip("{");                                                                                         // 1347
            while ((token = this.tn.next()) !== '}') {                                                                 // 1348
                if (Lang.RULE.test(token))                                                                             // 1349
                    this._parseMessageField(ext, token);                                                               // 1350
                else if (Lang.TYPEREF.test(token)) {                                                                   // 1351
                    if (!this.proto3)                                                                                  // 1352
                        throw Error("illegal field rule: "+token);                                                     // 1353
                    this._parseMessageField(ext, "optional", token);                                                   // 1354
                } else                                                                                                 // 1355
                    throw Error("illegal extend token: "+token);                                                       // 1356
            }                                                                                                          // 1357
            this.tn.omit(";");                                                                                         // 1358
            parent["messages"].push(ext);                                                                              // 1359
            return ext;                                                                                                // 1360
        };                                                                                                             // 1361
                                                                                                                       // 1362
        // ----- General -----                                                                                         // 1363
                                                                                                                       // 1364
        /**                                                                                                            // 1365
         * Returns a string representation of this parser.                                                             // 1366
         * @returns {string}                                                                                           // 1367
         */                                                                                                            // 1368
        ParserPrototype.toString = function() {                                                                        // 1369
            return "Parser at line "+this.tn.line;                                                                     // 1370
        };                                                                                                             // 1371
                                                                                                                       // 1372
        /**                                                                                                            // 1373
         * @alias ProtoBuf.DotProto.Parser                                                                             // 1374
         * @expose                                                                                                     // 1375
         */                                                                                                            // 1376
        DotProto.Parser = Parser;                                                                                      // 1377
                                                                                                                       // 1378
        return DotProto;                                                                                               // 1379
                                                                                                                       // 1380
    })(ProtoBuf, ProtoBuf.Lang);                                                                                       // 1381
                                                                                                                       // 1382
    /**                                                                                                                // 1383
     * @alias ProtoBuf.Reflect                                                                                         // 1384
     * @expose                                                                                                         // 1385
     */                                                                                                                // 1386
    ProtoBuf.Reflect = (function(ProtoBuf) {                                                                           // 1387
        "use strict";                                                                                                  // 1388
                                                                                                                       // 1389
        /**                                                                                                            // 1390
         * Reflection types.                                                                                           // 1391
         * @exports ProtoBuf.Reflect                                                                                   // 1392
         * @namespace                                                                                                  // 1393
         */                                                                                                            // 1394
        var Reflect = {};                                                                                              // 1395
                                                                                                                       // 1396
        /**                                                                                                            // 1397
         * Constructs a Reflect base class.                                                                            // 1398
         * @exports ProtoBuf.Reflect.T                                                                                 // 1399
         * @constructor                                                                                                // 1400
         * @abstract                                                                                                   // 1401
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 1402
         * @param {?ProtoBuf.Reflect.T} parent Parent object                                                           // 1403
         * @param {string} name Object name                                                                            // 1404
         */                                                                                                            // 1405
        var T = function(builder, parent, name) {                                                                      // 1406
                                                                                                                       // 1407
            /**                                                                                                        // 1408
             * Builder reference.                                                                                      // 1409
             * @type {!ProtoBuf.Builder}                                                                               // 1410
             * @expose                                                                                                 // 1411
             */                                                                                                        // 1412
            this.builder = builder;                                                                                    // 1413
                                                                                                                       // 1414
            /**                                                                                                        // 1415
             * Parent object.                                                                                          // 1416
             * @type {?ProtoBuf.Reflect.T}                                                                             // 1417
             * @expose                                                                                                 // 1418
             */                                                                                                        // 1419
            this.parent = parent;                                                                                      // 1420
                                                                                                                       // 1421
            /**                                                                                                        // 1422
             * Object name in namespace.                                                                               // 1423
             * @type {string}                                                                                          // 1424
             * @expose                                                                                                 // 1425
             */                                                                                                        // 1426
            this.name = name;                                                                                          // 1427
                                                                                                                       // 1428
            /**                                                                                                        // 1429
             * Fully qualified class name                                                                              // 1430
             * @type {string}                                                                                          // 1431
             * @expose                                                                                                 // 1432
             */                                                                                                        // 1433
            this.className;                                                                                            // 1434
        };                                                                                                             // 1435
                                                                                                                       // 1436
        /**                                                                                                            // 1437
         * @alias ProtoBuf.Reflect.T.prototype                                                                         // 1438
         * @inner                                                                                                      // 1439
         */                                                                                                            // 1440
        var TPrototype = T.prototype;                                                                                  // 1441
                                                                                                                       // 1442
        /**                                                                                                            // 1443
         * Returns the fully qualified name of this object.                                                            // 1444
         * @returns {string} Fully qualified name as of ".PATH.TO.THIS"                                                // 1445
         * @expose                                                                                                     // 1446
         */                                                                                                            // 1447
        TPrototype.fqn = function() {                                                                                  // 1448
            var name = this.name,                                                                                      // 1449
                ptr = this;                                                                                            // 1450
            do {                                                                                                       // 1451
                ptr = ptr.parent;                                                                                      // 1452
                if (ptr == null)                                                                                       // 1453
                    break;                                                                                             // 1454
                name = ptr.name+"."+name;                                                                              // 1455
            } while (true);                                                                                            // 1456
            return name;                                                                                               // 1457
        };                                                                                                             // 1458
                                                                                                                       // 1459
        /**                                                                                                            // 1460
         * Returns a string representation of this Reflect object (its fully qualified name).                          // 1461
         * @param {boolean=} includeClass Set to true to include the class name. Defaults to false.                    // 1462
         * @return String representation                                                                               // 1463
         * @expose                                                                                                     // 1464
         */                                                                                                            // 1465
        TPrototype.toString = function(includeClass) {                                                                 // 1466
            return (includeClass ? this.className + " " : "") + this.fqn();                                            // 1467
        };                                                                                                             // 1468
                                                                                                                       // 1469
        /**                                                                                                            // 1470
         * Builds this type.                                                                                           // 1471
         * @throws {Error} If this type cannot be built directly                                                       // 1472
         * @expose                                                                                                     // 1473
         */                                                                                                            // 1474
        TPrototype.build = function() {                                                                                // 1475
            throw Error(this.toString(true)+" cannot be built directly");                                              // 1476
        };                                                                                                             // 1477
                                                                                                                       // 1478
        /**                                                                                                            // 1479
         * @alias ProtoBuf.Reflect.T                                                                                   // 1480
         * @expose                                                                                                     // 1481
         */                                                                                                            // 1482
        Reflect.T = T;                                                                                                 // 1483
                                                                                                                       // 1484
        /**                                                                                                            // 1485
         * Constructs a new Namespace.                                                                                 // 1486
         * @exports ProtoBuf.Reflect.Namespace                                                                         // 1487
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 1488
         * @param {?ProtoBuf.Reflect.Namespace} parent Namespace parent                                                // 1489
         * @param {string} name Namespace name                                                                         // 1490
         * @param {Object.<string,*>=} options Namespace options                                                       // 1491
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)                                  // 1492
         * @constructor                                                                                                // 1493
         * @extends ProtoBuf.Reflect.T                                                                                 // 1494
         */                                                                                                            // 1495
        var Namespace = function(builder, parent, name, options, syntax) {                                             // 1496
            T.call(this, builder, parent, name);                                                                       // 1497
                                                                                                                       // 1498
            /**                                                                                                        // 1499
             * @override                                                                                               // 1500
             */                                                                                                        // 1501
            this.className = "Namespace";                                                                              // 1502
                                                                                                                       // 1503
            /**                                                                                                        // 1504
             * Children inside the namespace.                                                                          // 1505
             * @type {!Array.<ProtoBuf.Reflect.T>}                                                                     // 1506
             */                                                                                                        // 1507
            this.children = [];                                                                                        // 1508
                                                                                                                       // 1509
            /**                                                                                                        // 1510
             * Options.                                                                                                // 1511
             * @type {!Object.<string, *>}                                                                             // 1512
             */                                                                                                        // 1513
            this.options = options || {};                                                                              // 1514
                                                                                                                       // 1515
            /**                                                                                                        // 1516
             * Syntax level (e.g., proto2 or proto3).                                                                  // 1517
             * @type {!string}                                                                                         // 1518
             */                                                                                                        // 1519
            this.syntax = syntax || "proto2";                                                                          // 1520
        };                                                                                                             // 1521
                                                                                                                       // 1522
        /**                                                                                                            // 1523
         * @alias ProtoBuf.Reflect.Namespace.prototype                                                                 // 1524
         * @inner                                                                                                      // 1525
         */                                                                                                            // 1526
        var NamespacePrototype = Namespace.prototype = Object.create(T.prototype);                                     // 1527
                                                                                                                       // 1528
        /**                                                                                                            // 1529
         * Returns an array of the namespace's children.                                                               // 1530
         * @param {ProtoBuf.Reflect.T=} type Filter type (returns instances of this type only). Defaults to null (all children).
         * @return {Array.<ProtoBuf.Reflect.T>}                                                                        // 1532
         * @expose                                                                                                     // 1533
         */                                                                                                            // 1534
        NamespacePrototype.getChildren = function(type) {                                                              // 1535
            type = type || null;                                                                                       // 1536
            if (type == null)                                                                                          // 1537
                return this.children.slice();                                                                          // 1538
            var children = [];                                                                                         // 1539
            for (var i=0, k=this.children.length; i<k; ++i)                                                            // 1540
                if (this.children[i] instanceof type)                                                                  // 1541
                    children.push(this.children[i]);                                                                   // 1542
            return children;                                                                                           // 1543
        };                                                                                                             // 1544
                                                                                                                       // 1545
        /**                                                                                                            // 1546
         * Adds a child to the namespace.                                                                              // 1547
         * @param {ProtoBuf.Reflect.T} child Child                                                                     // 1548
         * @throws {Error} If the child cannot be added (duplicate)                                                    // 1549
         * @expose                                                                                                     // 1550
         */                                                                                                            // 1551
        NamespacePrototype.addChild = function(child) {                                                                // 1552
            var other;                                                                                                 // 1553
            if (other = this.getChild(child.name)) {                                                                   // 1554
                // Try to revert camelcase transformation on collision                                                 // 1555
                if (other instanceof Message.Field && other.name !== other.originalName && this.getChild(other.originalName) === null)
                    other.name = other.originalName; // Revert previous first (effectively keeps both originals)       // 1557
                else if (child instanceof Message.Field && child.name !== child.originalName && this.getChild(child.originalName) === null)
                    child.name = child.originalName;                                                                   // 1559
                else                                                                                                   // 1560
                    throw Error("Duplicate name in namespace "+this.toString(true)+": "+child.name);                   // 1561
            }                                                                                                          // 1562
            this.children.push(child);                                                                                 // 1563
        };                                                                                                             // 1564
                                                                                                                       // 1565
        /**                                                                                                            // 1566
         * Gets a child by its name or id.                                                                             // 1567
         * @param {string|number} nameOrId Child name or id                                                            // 1568
         * @return {?ProtoBuf.Reflect.T} The child or null if not found                                                // 1569
         * @expose                                                                                                     // 1570
         */                                                                                                            // 1571
        NamespacePrototype.getChild = function(nameOrId) {                                                             // 1572
            var key = typeof nameOrId === 'number' ? 'id' : 'name';                                                    // 1573
            for (var i=0, k=this.children.length; i<k; ++i)                                                            // 1574
                if (this.children[i][key] === nameOrId)                                                                // 1575
                    return this.children[i];                                                                           // 1576
            return null;                                                                                               // 1577
        };                                                                                                             // 1578
                                                                                                                       // 1579
        /**                                                                                                            // 1580
         * Resolves a reflect object inside of this namespace.                                                         // 1581
         * @param {string|!Array.<string>} qn Qualified name to resolve                                                // 1582
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types, defaults to `false`                     // 1583
         * @return {?ProtoBuf.Reflect.Namespace} The resolved type or null if not found                                // 1584
         * @expose                                                                                                     // 1585
         */                                                                                                            // 1586
        NamespacePrototype.resolve = function(qn, excludeNonNamespace) {                                               // 1587
            var part = typeof qn === 'string' ? qn.split(".") : qn,                                                    // 1588
                ptr = this,                                                                                            // 1589
                i = 0;                                                                                                 // 1590
            if (part[i] === "") { // Fully qualified name, e.g. ".My.Message'                                          // 1591
                while (ptr.parent !== null)                                                                            // 1592
                    ptr = ptr.parent;                                                                                  // 1593
                i++;                                                                                                   // 1594
            }                                                                                                          // 1595
            var child;                                                                                                 // 1596
            do {                                                                                                       // 1597
                do {                                                                                                   // 1598
                    if (!(ptr instanceof Reflect.Namespace)) {                                                         // 1599
                        ptr = null;                                                                                    // 1600
                        break;                                                                                         // 1601
                    }                                                                                                  // 1602
                    child = ptr.getChild(part[i]);                                                                     // 1603
                    if (!child || !(child instanceof Reflect.T) || (excludeNonNamespace && !(child instanceof Reflect.Namespace))) {
                        ptr = null;                                                                                    // 1605
                        break;                                                                                         // 1606
                    }                                                                                                  // 1607
                    ptr = child; i++;                                                                                  // 1608
                } while (i < part.length);                                                                             // 1609
                if (ptr != null)                                                                                       // 1610
                    break; // Found                                                                                    // 1611
                // Else search the parent                                                                              // 1612
                if (this.parent !== null)                                                                              // 1613
                    return this.parent.resolve(qn, excludeNonNamespace);                                               // 1614
            } while (ptr != null);                                                                                     // 1615
            return ptr;                                                                                                // 1616
        };                                                                                                             // 1617
                                                                                                                       // 1618
        /**                                                                                                            // 1619
         * Determines the shortest qualified name of the specified type, if any, relative to this namespace.           // 1620
         * @param {!ProtoBuf.Reflect.T} t Reflection type                                                              // 1621
         * @returns {string} The shortest qualified name or, if there is none, the fqn                                 // 1622
         * @expose                                                                                                     // 1623
         */                                                                                                            // 1624
        NamespacePrototype.qn = function(t) {                                                                          // 1625
            var part = [], ptr = t;                                                                                    // 1626
            do {                                                                                                       // 1627
                part.unshift(ptr.name);                                                                                // 1628
                ptr = ptr.parent;                                                                                      // 1629
            } while (ptr !== null);                                                                                    // 1630
            for (var len=1; len <= part.length; len++) {                                                               // 1631
                var qn = part.slice(part.length-len);                                                                  // 1632
                if (t === this.resolve(qn, t instanceof Reflect.Namespace))                                            // 1633
                    return qn.join(".");                                                                               // 1634
            }                                                                                                          // 1635
            return t.fqn();                                                                                            // 1636
        };                                                                                                             // 1637
                                                                                                                       // 1638
        /**                                                                                                            // 1639
         * Builds the namespace and returns the runtime counterpart.                                                   // 1640
         * @return {Object.<string,Function|Object>} Runtime namespace                                                 // 1641
         * @expose                                                                                                     // 1642
         */                                                                                                            // 1643
        NamespacePrototype.build = function() {                                                                        // 1644
            /** @dict */                                                                                               // 1645
            var ns = {};                                                                                               // 1646
            var children = this.children;                                                                              // 1647
            for (var i=0, k=children.length, child; i<k; ++i) {                                                        // 1648
                child = children[i];                                                                                   // 1649
                if (child instanceof Namespace)                                                                        // 1650
                    ns[child.name] = child.build();                                                                    // 1651
            }                                                                                                          // 1652
            if (Object.defineProperty)                                                                                 // 1653
                Object.defineProperty(ns, "$options", { "value": this.buildOpt() });                                   // 1654
            return ns;                                                                                                 // 1655
        };                                                                                                             // 1656
                                                                                                                       // 1657
        /**                                                                                                            // 1658
         * Builds the namespace's '$options' property.                                                                 // 1659
         * @return {Object.<string,*>}                                                                                 // 1660
         */                                                                                                            // 1661
        NamespacePrototype.buildOpt = function() {                                                                     // 1662
            var opt = {},                                                                                              // 1663
                keys = Object.keys(this.options);                                                                      // 1664
            for (var i=0, k=keys.length; i<k; ++i) {                                                                   // 1665
                var key = keys[i],                                                                                     // 1666
                    val = this.options[keys[i]];                                                                       // 1667
                // TODO: Options are not resolved, yet.                                                                // 1668
                // if (val instanceof Namespace) {                                                                     // 1669
                //     opt[key] = val.build();                                                                         // 1670
                // } else {                                                                                            // 1671
                opt[key] = val;                                                                                        // 1672
                // }                                                                                                   // 1673
            }                                                                                                          // 1674
            return opt;                                                                                                // 1675
        };                                                                                                             // 1676
                                                                                                                       // 1677
        /**                                                                                                            // 1678
         * Gets the value assigned to the option with the specified name.                                              // 1679
         * @param {string=} name Returns the option value if specified, otherwise all options are returned.            // 1680
         * @return {*|Object.<string,*>}null} Option value or NULL if there is no such option                          // 1681
         */                                                                                                            // 1682
        NamespacePrototype.getOption = function(name) {                                                                // 1683
            if (typeof name === 'undefined')                                                                           // 1684
                return this.options;                                                                                   // 1685
            return typeof this.options[name] !== 'undefined' ? this.options[name] : null;                              // 1686
        };                                                                                                             // 1687
                                                                                                                       // 1688
        /**                                                                                                            // 1689
         * @alias ProtoBuf.Reflect.Namespace                                                                           // 1690
         * @expose                                                                                                     // 1691
         */                                                                                                            // 1692
        Reflect.Namespace = Namespace;                                                                                 // 1693
                                                                                                                       // 1694
        /**                                                                                                            // 1695
         * Constructs a new Element implementation that checks and converts values for a                               // 1696
         * particular field type, as appropriate.                                                                      // 1697
         *                                                                                                             // 1698
         * An Element represents a single value: either the value of a singular field,                                 // 1699
         * or a value contained in one entry of a repeated field or map field. This                                    // 1700
         * class does not implement these higher-level concepts; it only encapsulates                                  // 1701
         * the low-level typechecking and conversion.                                                                  // 1702
         *                                                                                                             // 1703
         * @exports ProtoBuf.Reflect.Element                                                                           // 1704
         * @param {{name: string, wireType: number}} type Resolved data type                                           // 1705
         * @param {ProtoBuf.Reflect.T|null} resolvedType Resolved type, if relevant                                    // 1706
         * (e.g. submessage field).                                                                                    // 1707
         * @param {boolean} isMapKey Is this element a Map key? The value will be                                      // 1708
         * converted to string form if so.                                                                             // 1709
         * @param {string} syntax Syntax level of defining message type, e.g.,                                         // 1710
         * proto2 or proto3.                                                                                           // 1711
         * @constructor                                                                                                // 1712
         */                                                                                                            // 1713
        var Element = function(type, resolvedType, isMapKey, syntax) {                                                 // 1714
                                                                                                                       // 1715
            /**                                                                                                        // 1716
             * Element type, as a string (e.g., int32).                                                                // 1717
             * @type {{name: string, wireType: number}}                                                                // 1718
             */                                                                                                        // 1719
            this.type = type;                                                                                          // 1720
                                                                                                                       // 1721
            /**                                                                                                        // 1722
             * Element type reference to submessage or enum definition, if needed.                                     // 1723
             * @type {ProtoBuf.Reflect.T|null}                                                                         // 1724
             */                                                                                                        // 1725
            this.resolvedType = resolvedType;                                                                          // 1726
                                                                                                                       // 1727
            /**                                                                                                        // 1728
             * Element is a map key.                                                                                   // 1729
             * @type {boolean}                                                                                         // 1730
             */                                                                                                        // 1731
            this.isMapKey = isMapKey;                                                                                  // 1732
                                                                                                                       // 1733
            /**                                                                                                        // 1734
             * Syntax level of defining message type, e.g., proto2 or proto3.                                          // 1735
             * @type {string}                                                                                          // 1736
             */                                                                                                        // 1737
            this.syntax = syntax;                                                                                      // 1738
                                                                                                                       // 1739
            if (isMapKey && ProtoBuf.MAP_KEY_TYPES.indexOf(type) < 0)                                                  // 1740
                throw Error("Invalid map key type: " + type.name);                                                     // 1741
        };                                                                                                             // 1742
                                                                                                                       // 1743
        var ElementPrototype = Element.prototype;                                                                      // 1744
                                                                                                                       // 1745
        /**                                                                                                            // 1746
         * Obtains a (new) default value for the specified type.                                                       // 1747
         * @param type {string|{name: string, wireType: number}} Field type                                            // 1748
         * @returns {*} Default value                                                                                  // 1749
         * @inner                                                                                                      // 1750
         */                                                                                                            // 1751
        function mkDefault(type) {                                                                                     // 1752
            if (typeof type === 'string')                                                                              // 1753
                type = ProtoBuf.TYPES[type];                                                                           // 1754
            if (typeof type.defaultValue === 'undefined')                                                              // 1755
                throw Error("default value for type "+type.name+" is not supported");                                  // 1756
            if (type == ProtoBuf.TYPES["bytes"])                                                                       // 1757
                return new ByteBuffer(0);                                                                              // 1758
            return type.defaultValue;                                                                                  // 1759
        }                                                                                                              // 1760
                                                                                                                       // 1761
        /**                                                                                                            // 1762
         * Returns the default value for this field in proto3.                                                         // 1763
         * @function                                                                                                   // 1764
         * @param type {string|{name: string, wireType: number}} the field type                                        // 1765
         * @returns {*} Default value                                                                                  // 1766
         */                                                                                                            // 1767
        Element.defaultFieldValue = mkDefault;                                                                         // 1768
                                                                                                                       // 1769
        /**                                                                                                            // 1770
         * Makes a Long from a value.                                                                                  // 1771
         * @param {{low: number, high: number, unsigned: boolean}|string|number} value Value                           // 1772
         * @param {boolean=} unsigned Whether unsigned or not, defaults to reuse it from Long-like objects or to signed for
         *  strings and numbers                                                                                        // 1774
         * @returns {!Long}                                                                                            // 1775
         * @throws {Error} If the value cannot be converted to a Long                                                  // 1776
         * @inner                                                                                                      // 1777
         */                                                                                                            // 1778
        function mkLong(value, unsigned) {                                                                             // 1779
            if (value && typeof value.low === 'number' && typeof value.high === 'number' && typeof value.unsigned === 'boolean'
                && value.low === value.low && value.high === value.high)                                               // 1781
                return new ProtoBuf.Long(value.low, value.high, typeof unsigned === 'undefined' ? value.unsigned : unsigned);
            if (typeof value === 'string')                                                                             // 1783
                return ProtoBuf.Long.fromString(value, unsigned || false, 10);                                         // 1784
            if (typeof value === 'number')                                                                             // 1785
                return ProtoBuf.Long.fromNumber(value, unsigned || false);                                             // 1786
            throw Error("not convertible to Long");                                                                    // 1787
        }                                                                                                              // 1788
                                                                                                                       // 1789
        /**                                                                                                            // 1790
         * Checks if the given value can be set for an element of this type (singular                                  // 1791
         * field or one element of a repeated field or map).                                                           // 1792
         * @param {*} value Value to check                                                                             // 1793
         * @return {*} Verified, maybe adjusted, value                                                                 // 1794
         * @throws {Error} If the value cannot be verified for this element slot                                       // 1795
         * @expose                                                                                                     // 1796
         */                                                                                                            // 1797
        ElementPrototype.verifyValue = function(value) {                                                               // 1798
            var self = this;                                                                                           // 1799
            function fail(val, msg) {                                                                                  // 1800
                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
            }                                                                                                          // 1802
            switch (this.type) {                                                                                       // 1803
                // Signed 32bit                                                                                        // 1804
                case ProtoBuf.TYPES["int32"]:                                                                          // 1805
                case ProtoBuf.TYPES["sint32"]:                                                                         // 1806
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 1807
                    // Account for !NaN: value === value                                                               // 1808
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))                             // 1809
                        fail(typeof value, "not an integer");                                                          // 1810
                    return value > 4294967295 ? value | 0 : value;                                                     // 1811
                                                                                                                       // 1812
                // Unsigned 32bit                                                                                      // 1813
                case ProtoBuf.TYPES["uint32"]:                                                                         // 1814
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 1815
                    if (typeof value !== 'number' || (value === value && value % 1 !== 0))                             // 1816
                        fail(typeof value, "not an integer");                                                          // 1817
                    return value < 0 ? value >>> 0 : value;                                                            // 1818
                                                                                                                       // 1819
                // Signed 64bit                                                                                        // 1820
                case ProtoBuf.TYPES["int64"]:                                                                          // 1821
                case ProtoBuf.TYPES["sint64"]:                                                                         // 1822
                case ProtoBuf.TYPES["sfixed64"]: {                                                                     // 1823
                    if (ProtoBuf.Long)                                                                                 // 1824
                        try {                                                                                          // 1825
                            return mkLong(value, false);                                                               // 1826
                        } catch (e) {                                                                                  // 1827
                            fail(typeof value, e.message);                                                             // 1828
                        }                                                                                              // 1829
                    else                                                                                               // 1830
                        fail(typeof value, "requires Long.js");                                                        // 1831
                }                                                                                                      // 1832
                                                                                                                       // 1833
                // Unsigned 64bit                                                                                      // 1834
                case ProtoBuf.TYPES["uint64"]:                                                                         // 1835
                case ProtoBuf.TYPES["fixed64"]: {                                                                      // 1836
                    if (ProtoBuf.Long)                                                                                 // 1837
                        try {                                                                                          // 1838
                            return mkLong(value, true);                                                                // 1839
                        } catch (e) {                                                                                  // 1840
                            fail(typeof value, e.message);                                                             // 1841
                        }                                                                                              // 1842
                    else                                                                                               // 1843
                        fail(typeof value, "requires Long.js");                                                        // 1844
                }                                                                                                      // 1845
                                                                                                                       // 1846
                // Bool                                                                                                // 1847
                case ProtoBuf.TYPES["bool"]:                                                                           // 1848
                    if (typeof value !== 'boolean')                                                                    // 1849
                        fail(typeof value, "not a boolean");                                                           // 1850
                    return value;                                                                                      // 1851
                                                                                                                       // 1852
                // Float                                                                                               // 1853
                case ProtoBuf.TYPES["float"]:                                                                          // 1854
                case ProtoBuf.TYPES["double"]:                                                                         // 1855
                    if (typeof value !== 'number')                                                                     // 1856
                        fail(typeof value, "not a number");                                                            // 1857
                    return value;                                                                                      // 1858
                                                                                                                       // 1859
                // Length-delimited string                                                                             // 1860
                case ProtoBuf.TYPES["string"]:                                                                         // 1861
                    if (typeof value !== 'string' && !(value && value instanceof String))                              // 1862
                        fail(typeof value, "not a string");                                                            // 1863
                    return ""+value; // Convert String object to string                                                // 1864
                                                                                                                       // 1865
                // Length-delimited bytes                                                                              // 1866
                case ProtoBuf.TYPES["bytes"]:                                                                          // 1867
                    if (ByteBuffer.isByteBuffer(value))                                                                // 1868
                        return value;                                                                                  // 1869
                    return ByteBuffer.wrap(value, "base64");                                                           // 1870
                                                                                                                       // 1871
                // Constant enum value                                                                                 // 1872
                case ProtoBuf.TYPES["enum"]: {                                                                         // 1873
                    var values = this.resolvedType.getChildren(ProtoBuf.Reflect.Enum.Value);                           // 1874
                    for (i=0; i<values.length; i++)                                                                    // 1875
                        if (values[i].name == value)                                                                   // 1876
                            return values[i].id;                                                                       // 1877
                        else if (values[i].id == value)                                                                // 1878
                            return values[i].id;                                                                       // 1879
                                                                                                                       // 1880
                    if (this.syntax === 'proto3') {                                                                    // 1881
                        // proto3: just make sure it's an integer.                                                     // 1882
                        if (typeof value !== 'number' || (value === value && value % 1 !== 0))                         // 1883
                            fail(typeof value, "not an integer");                                                      // 1884
                        if (value > 4294967295 || value < 0)                                                           // 1885
                            fail(typeof value, "not in range for uint32")                                              // 1886
                        return value;                                                                                  // 1887
                    } else {                                                                                           // 1888
                        // proto2 requires enum values to be valid.                                                    // 1889
                        fail(value, "not a valid enum value");                                                         // 1890
                    }                                                                                                  // 1891
                }                                                                                                      // 1892
                // Embedded message                                                                                    // 1893
                case ProtoBuf.TYPES["group"]:                                                                          // 1894
                case ProtoBuf.TYPES["message"]: {                                                                      // 1895
                    if (!value || typeof value !== 'object')                                                           // 1896
                        fail(typeof value, "object expected");                                                         // 1897
                    if (value instanceof this.resolvedType.clazz)                                                      // 1898
                        return value;                                                                                  // 1899
                    if (value instanceof ProtoBuf.Builder.Message) {                                                   // 1900
                        // Mismatched type: Convert to object (see: https://github.com/dcodeIO/ProtoBuf.js/issues/180)
                        var obj = {};                                                                                  // 1902
                        for (var i in value)                                                                           // 1903
                            if (value.hasOwnProperty(i))                                                               // 1904
                                obj[i] = value[i];                                                                     // 1905
                        value = obj;                                                                                   // 1906
                    }                                                                                                  // 1907
                    // Else let's try to construct one from a key-value object                                         // 1908
                    return new (this.resolvedType.clazz)(value); // May throw for a hundred of reasons                 // 1909
                }                                                                                                      // 1910
            }                                                                                                          // 1911
                                                                                                                       // 1912
            // We should never end here                                                                                // 1913
            throw Error("[INTERNAL] Illegal value for "+this.toString(true)+": "+value+" (undefined type "+this.type+")");
        };                                                                                                             // 1915
                                                                                                                       // 1916
        /**                                                                                                            // 1917
         * Calculates the byte length of an element on the wire.                                                       // 1918
         * @param {number} id Field number                                                                             // 1919
         * @param {*} value Field value                                                                                // 1920
         * @returns {number} Byte length                                                                               // 1921
         * @throws {Error} If the value cannot be calculated                                                           // 1922
         * @expose                                                                                                     // 1923
         */                                                                                                            // 1924
        ElementPrototype.calculateLength = function(id, value) {                                                       // 1925
            if (value === null) return 0; // Nothing to encode                                                         // 1926
            // Tag has already been written                                                                            // 1927
            var n;                                                                                                     // 1928
            switch (this.type) {                                                                                       // 1929
                case ProtoBuf.TYPES["int32"]:                                                                          // 1930
                    return value < 0 ? ByteBuffer.calculateVarint64(value) : ByteBuffer.calculateVarint32(value);      // 1931
                case ProtoBuf.TYPES["uint32"]:                                                                         // 1932
                    return ByteBuffer.calculateVarint32(value);                                                        // 1933
                case ProtoBuf.TYPES["sint32"]:                                                                         // 1934
                    return ByteBuffer.calculateVarint32(ByteBuffer.zigZagEncode32(value));                             // 1935
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 1936
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 1937
                case ProtoBuf.TYPES["float"]:                                                                          // 1938
                    return 4;                                                                                          // 1939
                case ProtoBuf.TYPES["int64"]:                                                                          // 1940
                case ProtoBuf.TYPES["uint64"]:                                                                         // 1941
                    return ByteBuffer.calculateVarint64(value);                                                        // 1942
                case ProtoBuf.TYPES["sint64"]:                                                                         // 1943
                    return ByteBuffer.calculateVarint64(ByteBuffer.zigZagEncode64(value));                             // 1944
                case ProtoBuf.TYPES["fixed64"]:                                                                        // 1945
                case ProtoBuf.TYPES["sfixed64"]:                                                                       // 1946
                    return 8;                                                                                          // 1947
                case ProtoBuf.TYPES["bool"]:                                                                           // 1948
                    return 1;                                                                                          // 1949
                case ProtoBuf.TYPES["enum"]:                                                                           // 1950
                    return ByteBuffer.calculateVarint32(value);                                                        // 1951
                case ProtoBuf.TYPES["double"]:                                                                         // 1952
                    return 8;                                                                                          // 1953
                case ProtoBuf.TYPES["string"]:                                                                         // 1954
                    n = ByteBuffer.calculateUTF8Bytes(value);                                                          // 1955
                    return ByteBuffer.calculateVarint32(n) + n;                                                        // 1956
                case ProtoBuf.TYPES["bytes"]:                                                                          // 1957
                    if (value.remaining() < 0)                                                                         // 1958
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    return ByteBuffer.calculateVarint32(value.remaining()) + value.remaining();                        // 1960
                case ProtoBuf.TYPES["message"]:                                                                        // 1961
                    n = this.resolvedType.calculate(value);                                                            // 1962
                    return ByteBuffer.calculateVarint32(n) + n;                                                        // 1963
                case ProtoBuf.TYPES["group"]:                                                                          // 1964
                    n = this.resolvedType.calculate(value);                                                            // 1965
                    return n + ByteBuffer.calculateVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);                 // 1966
            }                                                                                                          // 1967
            // We should never end here                                                                                // 1968
            throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");    // 1969
        };                                                                                                             // 1970
                                                                                                                       // 1971
        /**                                                                                                            // 1972
         * Encodes a value to the specified buffer. Does not encode the key.                                           // 1973
         * @param {number} id Field number                                                                             // 1974
         * @param {*} value Field value                                                                                // 1975
         * @param {ByteBuffer} buffer ByteBuffer to encode to                                                          // 1976
         * @return {ByteBuffer} The ByteBuffer for chaining                                                            // 1977
         * @throws {Error} If the value cannot be encoded                                                              // 1978
         * @expose                                                                                                     // 1979
         */                                                                                                            // 1980
        ElementPrototype.encodeValue = function(id, value, buffer) {                                                   // 1981
            if (value === null) return buffer; // Nothing to encode                                                    // 1982
            // Tag has already been written                                                                            // 1983
                                                                                                                       // 1984
            switch (this.type) {                                                                                       // 1985
                // 32bit signed varint                                                                                 // 1986
                case ProtoBuf.TYPES["int32"]:                                                                          // 1987
                    // "If you use int32 or int64 as the type for a negative number, the resulting varint is always ten bytes
                    // long – it is, effectively, treated like a very large unsigned integer." (see #122)              // 1989
                    if (value < 0)                                                                                     // 1990
                        buffer.writeVarint64(value);                                                                   // 1991
                    else                                                                                               // 1992
                        buffer.writeVarint32(value);                                                                   // 1993
                    break;                                                                                             // 1994
                                                                                                                       // 1995
                // 32bit unsigned varint                                                                               // 1996
                case ProtoBuf.TYPES["uint32"]:                                                                         // 1997
                    buffer.writeVarint32(value);                                                                       // 1998
                    break;                                                                                             // 1999
                                                                                                                       // 2000
                // 32bit varint zig-zag                                                                                // 2001
                case ProtoBuf.TYPES["sint32"]:                                                                         // 2002
                    buffer.writeVarint32ZigZag(value);                                                                 // 2003
                    break;                                                                                             // 2004
                                                                                                                       // 2005
                // Fixed unsigned 32bit                                                                                // 2006
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 2007
                    buffer.writeUint32(value);                                                                         // 2008
                    break;                                                                                             // 2009
                                                                                                                       // 2010
                // Fixed signed 32bit                                                                                  // 2011
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 2012
                    buffer.writeInt32(value);                                                                          // 2013
                    break;                                                                                             // 2014
                                                                                                                       // 2015
                // 64bit varint as-is                                                                                  // 2016
                case ProtoBuf.TYPES["int64"]:                                                                          // 2017
                case ProtoBuf.TYPES["uint64"]:                                                                         // 2018
                    buffer.writeVarint64(value); // throws                                                             // 2019
                    break;                                                                                             // 2020
                                                                                                                       // 2021
                // 64bit varint zig-zag                                                                                // 2022
                case ProtoBuf.TYPES["sint64"]:                                                                         // 2023
                    buffer.writeVarint64ZigZag(value); // throws                                                       // 2024
                    break;                                                                                             // 2025
                                                                                                                       // 2026
                // Fixed unsigned 64bit                                                                                // 2027
                case ProtoBuf.TYPES["fixed64"]:                                                                        // 2028
                    buffer.writeUint64(value); // throws                                                               // 2029
                    break;                                                                                             // 2030
                                                                                                                       // 2031
                // Fixed signed 64bit                                                                                  // 2032
                case ProtoBuf.TYPES["sfixed64"]:                                                                       // 2033
                    buffer.writeInt64(value); // throws                                                                // 2034
                    break;                                                                                             // 2035
                                                                                                                       // 2036
                // Bool                                                                                                // 2037
                case ProtoBuf.TYPES["bool"]:                                                                           // 2038
                    if (typeof value === 'string')                                                                     // 2039
                        buffer.writeVarint32(value.toLowerCase() === 'false' ? 0 : !!value);                           // 2040
                    else                                                                                               // 2041
                        buffer.writeVarint32(value ? 1 : 0);                                                           // 2042
                    break;                                                                                             // 2043
                                                                                                                       // 2044
                // Constant enum value                                                                                 // 2045
                case ProtoBuf.TYPES["enum"]:                                                                           // 2046
                    buffer.writeVarint32(value);                                                                       // 2047
                    break;                                                                                             // 2048
                                                                                                                       // 2049
                // 32bit float                                                                                         // 2050
                case ProtoBuf.TYPES["float"]:                                                                          // 2051
                    buffer.writeFloat32(value);                                                                        // 2052
                    break;                                                                                             // 2053
                                                                                                                       // 2054
                // 64bit float                                                                                         // 2055
                case ProtoBuf.TYPES["double"]:                                                                         // 2056
                    buffer.writeFloat64(value);                                                                        // 2057
                    break;                                                                                             // 2058
                                                                                                                       // 2059
                // Length-delimited string                                                                             // 2060
                case ProtoBuf.TYPES["string"]:                                                                         // 2061
                    buffer.writeVString(value);                                                                        // 2062
                    break;                                                                                             // 2063
                                                                                                                       // 2064
                // Length-delimited bytes                                                                              // 2065
                case ProtoBuf.TYPES["bytes"]:                                                                          // 2066
                    if (value.remaining() < 0)                                                                         // 2067
                        throw Error("Illegal value for "+this.toString(true)+": "+value.remaining()+" bytes remaining");
                    var prevOffset = value.offset;                                                                     // 2069
                    buffer.writeVarint32(value.remaining());                                                           // 2070
                    buffer.append(value);                                                                              // 2071
                    value.offset = prevOffset;                                                                         // 2072
                    break;                                                                                             // 2073
                                                                                                                       // 2074
                // Embedded message                                                                                    // 2075
                case ProtoBuf.TYPES["message"]:                                                                        // 2076
                    var bb = new ByteBuffer().LE();                                                                    // 2077
                    this.resolvedType.encode(value, bb);                                                               // 2078
                    buffer.writeVarint32(bb.offset);                                                                   // 2079
                    buffer.append(bb.flip());                                                                          // 2080
                    break;                                                                                             // 2081
                                                                                                                       // 2082
                // Legacy group                                                                                        // 2083
                case ProtoBuf.TYPES["group"]:                                                                          // 2084
                    this.resolvedType.encode(value, buffer);                                                           // 2085
                    buffer.writeVarint32((id << 3) | ProtoBuf.WIRE_TYPES.ENDGROUP);                                    // 2086
                    break;                                                                                             // 2087
                                                                                                                       // 2088
                default:                                                                                               // 2089
                    // We should never end here                                                                        // 2090
                    throw Error("[INTERNAL] Illegal value to encode in "+this.toString(true)+": "+value+" (unknown type)");
            }                                                                                                          // 2092
            return buffer;                                                                                             // 2093
        };                                                                                                             // 2094
                                                                                                                       // 2095
        /**                                                                                                            // 2096
         * Decode one element value from the specified buffer.                                                         // 2097
         * @param {ByteBuffer} buffer ByteBuffer to decode from                                                        // 2098
         * @param {number} wireType The field wire type                                                                // 2099
         * @param {number} id The field number                                                                         // 2100
         * @return {*} Decoded value                                                                                   // 2101
         * @throws {Error} If the field cannot be decoded                                                              // 2102
         * @expose                                                                                                     // 2103
         */                                                                                                            // 2104
        ElementPrototype.decode = function(buffer, wireType, id) {                                                     // 2105
            if (wireType != this.type.wireType)                                                                        // 2106
                throw Error("Unexpected wire type for element");                                                       // 2107
                                                                                                                       // 2108
            var value, nBytes;                                                                                         // 2109
            switch (this.type) {                                                                                       // 2110
                // 32bit signed varint                                                                                 // 2111
                case ProtoBuf.TYPES["int32"]:                                                                          // 2112
                    return buffer.readVarint32() | 0;                                                                  // 2113
                                                                                                                       // 2114
                // 32bit unsigned varint                                                                               // 2115
                case ProtoBuf.TYPES["uint32"]:                                                                         // 2116
                    return buffer.readVarint32() >>> 0;                                                                // 2117
                                                                                                                       // 2118
                // 32bit signed varint zig-zag                                                                         // 2119
                case ProtoBuf.TYPES["sint32"]:                                                                         // 2120
                    return buffer.readVarint32ZigZag() | 0;                                                            // 2121
                                                                                                                       // 2122
                // Fixed 32bit unsigned                                                                                // 2123
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 2124
                    return buffer.readUint32() >>> 0;                                                                  // 2125
                                                                                                                       // 2126
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 2127
                    return buffer.readInt32() | 0;                                                                     // 2128
                                                                                                                       // 2129
                // 64bit signed varint                                                                                 // 2130
                case ProtoBuf.TYPES["int64"]:                                                                          // 2131
                    return buffer.readVarint64();                                                                      // 2132
                                                                                                                       // 2133
                // 64bit unsigned varint                                                                               // 2134
                case ProtoBuf.TYPES["uint64"]:                                                                         // 2135
                    return buffer.readVarint64().toUnsigned();                                                         // 2136
                                                                                                                       // 2137
                // 64bit signed varint zig-zag                                                                         // 2138
                case ProtoBuf.TYPES["sint64"]:                                                                         // 2139
                    return buffer.readVarint64ZigZag();                                                                // 2140
                                                                                                                       // 2141
                // Fixed 64bit unsigned                                                                                // 2142
                case ProtoBuf.TYPES["fixed64"]:                                                                        // 2143
                    return buffer.readUint64();                                                                        // 2144
                                                                                                                       // 2145
                // Fixed 64bit signed                                                                                  // 2146
                case ProtoBuf.TYPES["sfixed64"]:                                                                       // 2147
                    return buffer.readInt64();                                                                         // 2148
                                                                                                                       // 2149
                // Bool varint                                                                                         // 2150
                case ProtoBuf.TYPES["bool"]:                                                                           // 2151
                    return !!buffer.readVarint32();                                                                    // 2152
                                                                                                                       // 2153
                // Constant enum value (varint)                                                                        // 2154
                case ProtoBuf.TYPES["enum"]:                                                                           // 2155
                    // The following Builder.Message#set will already throw                                            // 2156
                    return buffer.readVarint32();                                                                      // 2157
                                                                                                                       // 2158
                // 32bit float                                                                                         // 2159
                case ProtoBuf.TYPES["float"]:                                                                          // 2160
                    return buffer.readFloat();                                                                         // 2161
                                                                                                                       // 2162
                // 64bit float                                                                                         // 2163
                case ProtoBuf.TYPES["double"]:                                                                         // 2164
                    return buffer.readDouble();                                                                        // 2165
                                                                                                                       // 2166
                // Length-delimited string                                                                             // 2167
                case ProtoBuf.TYPES["string"]:                                                                         // 2168
                    return buffer.readVString();                                                                       // 2169
                                                                                                                       // 2170
                // Length-delimited bytes                                                                              // 2171
                case ProtoBuf.TYPES["bytes"]: {                                                                        // 2172
                    nBytes = buffer.readVarint32();                                                                    // 2173
                    if (buffer.remaining() < nBytes)                                                                   // 2174
                        throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                    value = buffer.clone(); // Offset already set                                                      // 2176
                    value.limit = value.offset+nBytes;                                                                 // 2177
                    buffer.offset += nBytes;                                                                           // 2178
                    return value;                                                                                      // 2179
                }                                                                                                      // 2180
                                                                                                                       // 2181
                // Length-delimited embedded message                                                                   // 2182
                case ProtoBuf.TYPES["message"]: {                                                                      // 2183
                    nBytes = buffer.readVarint32();                                                                    // 2184
                    return this.resolvedType.decode(buffer, nBytes);                                                   // 2185
                }                                                                                                      // 2186
                                                                                                                       // 2187
                // Legacy group                                                                                        // 2188
                case ProtoBuf.TYPES["group"]:                                                                          // 2189
                    return this.resolvedType.decode(buffer, -1, id);                                                   // 2190
            }                                                                                                          // 2191
                                                                                                                       // 2192
            // We should never end here                                                                                // 2193
            throw Error("[INTERNAL] Illegal decode type");                                                             // 2194
        };                                                                                                             // 2195
                                                                                                                       // 2196
        /**                                                                                                            // 2197
         * Converts a value from a string to the canonical element type.                                               // 2198
         *                                                                                                             // 2199
         * Legal only when isMapKey is true.                                                                           // 2200
         *                                                                                                             // 2201
         * @param {string} str The string value                                                                        // 2202
         * @returns {*} The value                                                                                      // 2203
         */                                                                                                            // 2204
        ElementPrototype.valueFromString = function(str) {                                                             // 2205
            if (!this.isMapKey) {                                                                                      // 2206
                throw Error("valueFromString() called on non-map-key element");                                        // 2207
            }                                                                                                          // 2208
                                                                                                                       // 2209
            switch (this.type) {                                                                                       // 2210
                case ProtoBuf.TYPES["int32"]:                                                                          // 2211
                case ProtoBuf.TYPES["sint32"]:                                                                         // 2212
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 2213
                case ProtoBuf.TYPES["uint32"]:                                                                         // 2214
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 2215
                    return this.verifyValue(parseInt(str));                                                            // 2216
                                                                                                                       // 2217
                case ProtoBuf.TYPES["int64"]:                                                                          // 2218
                case ProtoBuf.TYPES["sint64"]:                                                                         // 2219
                case ProtoBuf.TYPES["sfixed64"]:                                                                       // 2220
                case ProtoBuf.TYPES["uint64"]:                                                                         // 2221
                case ProtoBuf.TYPES["fixed64"]:                                                                        // 2222
                      // Long-based fields support conversions from string already.                                    // 2223
                      return this.verifyValue(str);                                                                    // 2224
                                                                                                                       // 2225
                case ProtoBuf.TYPES["bool"]:                                                                           // 2226
                      return str === "true";                                                                           // 2227
                                                                                                                       // 2228
                case ProtoBuf.TYPES["string"]:                                                                         // 2229
                      return this.verifyValue(str);                                                                    // 2230
                                                                                                                       // 2231
                case ProtoBuf.TYPES["bytes"]:                                                                          // 2232
                      return ByteBuffer.fromBinary(str);                                                               // 2233
            }                                                                                                          // 2234
        };                                                                                                             // 2235
                                                                                                                       // 2236
        /**                                                                                                            // 2237
         * Converts a value from the canonical element type to a string.                                               // 2238
         *                                                                                                             // 2239
         * It should be the case that `valueFromString(valueToString(val))` returns                                    // 2240
         * a value equivalent to `verifyValue(val)` for every legal value of `val`                                     // 2241
         * according to this element type.                                                                             // 2242
         *                                                                                                             // 2243
         * This may be used when the element must be stored or used as a string,                                       // 2244
         * e.g., as a map key on an Object.                                                                            // 2245
         *                                                                                                             // 2246
         * Legal only when isMapKey is true.                                                                           // 2247
         *                                                                                                             // 2248
         * @param {*} val The value                                                                                    // 2249
         * @returns {string} The string form of the value.                                                             // 2250
         */                                                                                                            // 2251
        ElementPrototype.valueToString = function(value) {                                                             // 2252
            if (!this.isMapKey) {                                                                                      // 2253
                throw Error("valueToString() called on non-map-key element");                                          // 2254
            }                                                                                                          // 2255
                                                                                                                       // 2256
            if (this.type === ProtoBuf.TYPES["bytes"]) {                                                               // 2257
                return value.toString("binary");                                                                       // 2258
            } else {                                                                                                   // 2259
                return value.toString();                                                                               // 2260
            }                                                                                                          // 2261
        };                                                                                                             // 2262
                                                                                                                       // 2263
        /**                                                                                                            // 2264
         * @alias ProtoBuf.Reflect.Element                                                                             // 2265
         * @expose                                                                                                     // 2266
         */                                                                                                            // 2267
        Reflect.Element = Element;                                                                                     // 2268
                                                                                                                       // 2269
        /**                                                                                                            // 2270
         * Constructs a new Message.                                                                                   // 2271
         * @exports ProtoBuf.Reflect.Message                                                                           // 2272
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 2273
         * @param {!ProtoBuf.Reflect.Namespace} parent Parent message or namespace                                     // 2274
         * @param {string} name Message name                                                                           // 2275
         * @param {Object.<string,*>=} options Message options                                                         // 2276
         * @param {boolean=} isGroup `true` if this is a legacy group                                                  // 2277
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)                                  // 2278
         * @constructor                                                                                                // 2279
         * @extends ProtoBuf.Reflect.Namespace                                                                         // 2280
         */                                                                                                            // 2281
        var Message = function(builder, parent, name, options, isGroup, syntax) {                                      // 2282
            Namespace.call(this, builder, parent, name, options, syntax);                                              // 2283
                                                                                                                       // 2284
            /**                                                                                                        // 2285
             * @override                                                                                               // 2286
             */                                                                                                        // 2287
            this.className = "Message";                                                                                // 2288
                                                                                                                       // 2289
            /**                                                                                                        // 2290
             * Extensions range.                                                                                       // 2291
             * @type {!Array.<number>|undefined}                                                                       // 2292
             * @expose                                                                                                 // 2293
             */                                                                                                        // 2294
            this.extensions = undefined;                                                                               // 2295
                                                                                                                       // 2296
            /**                                                                                                        // 2297
             * Runtime message class.                                                                                  // 2298
             * @type {?function(new:ProtoBuf.Builder.Message)}                                                         // 2299
             * @expose                                                                                                 // 2300
             */                                                                                                        // 2301
            this.clazz = null;                                                                                         // 2302
                                                                                                                       // 2303
            /**                                                                                                        // 2304
             * Whether this is a legacy group or not.                                                                  // 2305
             * @type {boolean}                                                                                         // 2306
             * @expose                                                                                                 // 2307
             */                                                                                                        // 2308
            this.isGroup = !!isGroup;                                                                                  // 2309
                                                                                                                       // 2310
            // The following cached collections are used to efficiently iterate over or look up fields when decoding.  // 2311
                                                                                                                       // 2312
            /**                                                                                                        // 2313
             * Cached fields.                                                                                          // 2314
             * @type {?Array.<!ProtoBuf.Reflect.Message.Field>}                                                        // 2315
             * @private                                                                                                // 2316
             */                                                                                                        // 2317
            this._fields = null;                                                                                       // 2318
                                                                                                                       // 2319
            /**                                                                                                        // 2320
             * Cached fields by id.                                                                                    // 2321
             * @type {?Object.<number,!ProtoBuf.Reflect.Message.Field>}                                                // 2322
             * @private                                                                                                // 2323
             */                                                                                                        // 2324
            this._fieldsById = null;                                                                                   // 2325
                                                                                                                       // 2326
            /**                                                                                                        // 2327
             * Cached fields by name.                                                                                  // 2328
             * @type {?Object.<string,!ProtoBuf.Reflect.Message.Field>}                                                // 2329
             * @private                                                                                                // 2330
             */                                                                                                        // 2331
            this._fieldsByName = null;                                                                                 // 2332
        };                                                                                                             // 2333
                                                                                                                       // 2334
        /**                                                                                                            // 2335
         * @alias ProtoBuf.Reflect.Message.prototype                                                                   // 2336
         * @inner                                                                                                      // 2337
         */                                                                                                            // 2338
        var MessagePrototype = Message.prototype = Object.create(Namespace.prototype);                                 // 2339
                                                                                                                       // 2340
        /**                                                                                                            // 2341
         * Builds the message and returns the runtime counterpart, which is a fully functional class.                  // 2342
         * @see ProtoBuf.Builder.Message                                                                               // 2343
         * @param {boolean=} rebuild Whether to rebuild or not, defaults to false                                      // 2344
         * @return {ProtoBuf.Reflect.Message} Message class                                                            // 2345
         * @throws {Error} If the message cannot be built                                                              // 2346
         * @expose                                                                                                     // 2347
         */                                                                                                            // 2348
        MessagePrototype.build = function(rebuild) {                                                                   // 2349
            if (this.clazz && !rebuild)                                                                                // 2350
                return this.clazz;                                                                                     // 2351
                                                                                                                       // 2352
            // Create the runtime Message class in its own scope                                                       // 2353
            var clazz = (function(ProtoBuf, T) {                                                                       // 2354
                                                                                                                       // 2355
                var fields = T.getChildren(ProtoBuf.Reflect.Message.Field),                                            // 2356
                    oneofs = T.getChildren(ProtoBuf.Reflect.Message.OneOf);                                            // 2357
                                                                                                                       // 2358
                /**                                                                                                    // 2359
                 * Constructs a new runtime Message.                                                                   // 2360
                 * @name ProtoBuf.Builder.Message                                                                      // 2361
                 * @class Barebone of all runtime messages.                                                            // 2362
                 * @param {!Object.<string,*>|string} values Preset values                                             // 2363
                 * @param {...string} var_args                                                                         // 2364
                 * @constructor                                                                                        // 2365
                 * @throws {Error} If the message cannot be created                                                    // 2366
                 */                                                                                                    // 2367
                var Message = function(values, var_args) {                                                             // 2368
                    ProtoBuf.Builder.Message.call(this);                                                               // 2369
                                                                                                                       // 2370
                    // Create virtual oneof properties                                                                 // 2371
                    for (var i=0, k=oneofs.length; i<k; ++i)                                                           // 2372
                        this[oneofs[i].name] = null;                                                                   // 2373
                    // Create fields and set default values                                                            // 2374
                    for (i=0, k=fields.length; i<k; ++i) {                                                             // 2375
                        var field = fields[i];                                                                         // 2376
                        this[field.name] =                                                                             // 2377
                            field.repeated ? [] :                                                                      // 2378
                            (field.map ? new ProtoBuf.Map(field) : null);                                              // 2379
                        if ((field.required || T.syntax === 'proto3') &&                                               // 2380
                            field.defaultValue !== null)                                                               // 2381
                            this[field.name] = field.defaultValue;                                                     // 2382
                    }                                                                                                  // 2383
                                                                                                                       // 2384
                    if (arguments.length > 0) {                                                                        // 2385
                        var value;                                                                                     // 2386
                        // Set field values from a values object                                                       // 2387
                        if (arguments.length === 1 && values !== null && typeof values === 'object' &&                 // 2388
                            /* not _another_ Message */ (typeof values.encode !== 'function' || values instanceof Message) &&
                            /* not a repeated field */ !Array.isArray(values) &&                                       // 2390
                            /* not a Map */ !(values instanceof ProtoBuf.Map) &&                                       // 2391
                            /* not a ByteBuffer */ !ByteBuffer.isByteBuffer(values) &&                                 // 2392
                            /* not an ArrayBuffer */ !(values instanceof ArrayBuffer) &&                               // 2393
                            /* not a Long */ !(ProtoBuf.Long && values instanceof ProtoBuf.Long)) {                    // 2394
                            this.$set(values);                                                                         // 2395
                        } else // Set field values from arguments, in declaration order                                // 2396
                            for (i=0, k=arguments.length; i<k; ++i)                                                    // 2397
                                if (typeof (value = arguments[i]) !== 'undefined')                                     // 2398
                                    this.$set(fields[i].name, value); // May throw                                     // 2399
                    }                                                                                                  // 2400
                };                                                                                                     // 2401
                                                                                                                       // 2402
                /**                                                                                                    // 2403
                 * @alias ProtoBuf.Builder.Message.prototype                                                           // 2404
                 * @inner                                                                                              // 2405
                 */                                                                                                    // 2406
                var MessagePrototype = Message.prototype = Object.create(ProtoBuf.Builder.Message.prototype);          // 2407
                                                                                                                       // 2408
                /**                                                                                                    // 2409
                 * Adds a value to a repeated field.                                                                   // 2410
                 * @name ProtoBuf.Builder.Message#add                                                                  // 2411
                 * @function                                                                                           // 2412
                 * @param {string} key Field name                                                                      // 2413
                 * @param {*} value Value to add                                                                       // 2414
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)                  // 2415
                 * @returns {!ProtoBuf.Builder.Message} this                                                           // 2416
                 * @throws {Error} If the value cannot be added                                                        // 2417
                 * @expose                                                                                             // 2418
                 */                                                                                                    // 2419
                MessagePrototype.add = function(key, value, noAssert) {                                                // 2420
                    var field = T._fieldsByName[key];                                                                  // 2421
                    if (!noAssert) {                                                                                   // 2422
                        if (!field)                                                                                    // 2423
                            throw Error(this+"#"+key+" is undefined");                                                 // 2424
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))                                        // 2425
                            throw Error(this+"#"+key+" is not a field: "+field.toString(true)); // May throw if it's an enum or embedded message
                        if (!field.repeated)                                                                           // 2427
                            throw Error(this+"#"+key+" is not a repeated field");                                      // 2428
                        value = field.verifyValue(value, true);                                                        // 2429
                    }                                                                                                  // 2430
                    if (this[key] === null)                                                                            // 2431
                        this[key] = [];                                                                                // 2432
                    this[key].push(value);                                                                             // 2433
                    return this;                                                                                       // 2434
                };                                                                                                     // 2435
                                                                                                                       // 2436
                /**                                                                                                    // 2437
                 * Adds a value to a repeated field. This is an alias for {@link ProtoBuf.Builder.Message#add}.        // 2438
                 * @name ProtoBuf.Builder.Message#$add                                                                 // 2439
                 * @function                                                                                           // 2440
                 * @param {string} key Field name                                                                      // 2441
                 * @param {*} value Value to add                                                                       // 2442
                 * @param {boolean=} noAssert Whether to assert the value or not (asserts by default)                  // 2443
                 * @returns {!ProtoBuf.Builder.Message} this                                                           // 2444
                 * @throws {Error} If the value cannot be added                                                        // 2445
                 * @expose                                                                                             // 2446
                 */                                                                                                    // 2447
                MessagePrototype.$add = MessagePrototype.add;                                                          // 2448
                                                                                                                       // 2449
                /**                                                                                                    // 2450
                 * Sets a field's value.                                                                               // 2451
                 * @name ProtoBuf.Builder.Message#set                                                                  // 2452
                 * @function                                                                                           // 2453
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values      // 2454
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted                      // 2455
                 * @param {boolean=} noAssert Whether to not assert for an actual field / proper value type, defaults to `false`
                 * @returns {!ProtoBuf.Builder.Message} this                                                           // 2457
                 * @throws {Error} If the value cannot be set                                                          // 2458
                 * @expose                                                                                             // 2459
                 */                                                                                                    // 2460
                MessagePrototype.set = function(keyOrObj, value, noAssert) {                                           // 2461
                    if (keyOrObj && typeof keyOrObj === 'object') {                                                    // 2462
                        noAssert = value;                                                                              // 2463
                        for (var ikey in keyOrObj)                                                                     // 2464
                            if (keyOrObj.hasOwnProperty(ikey) && typeof (value = keyOrObj[ikey]) !== 'undefined')      // 2465
                                this.$set(ikey, value, noAssert);                                                      // 2466
                        return this;                                                                                   // 2467
                    }                                                                                                  // 2468
                    var field = T._fieldsByName[keyOrObj];                                                             // 2469
                    if (!noAssert) {                                                                                   // 2470
                        if (!field)                                                                                    // 2471
                            throw Error(this+"#"+keyOrObj+" is not a field: undefined");                               // 2472
                        if (!(field instanceof ProtoBuf.Reflect.Message.Field))                                        // 2473
                            throw Error(this+"#"+keyOrObj+" is not a field: "+field.toString(true));                   // 2474
                        this[field.name] = (value = field.verifyValue(value)); // May throw                            // 2475
                    } else                                                                                             // 2476
                        this[keyOrObj] = value;                                                                        // 2477
                    if (field && field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)               // 2478
                        var currentField = this[field.oneof.name]; // Virtual field references currently set field     // 2479
                        if (value !== null) {                                                                          // 2480
                            if (currentField !== null && currentField !== field.name)                                  // 2481
                                this[currentField] = null; // Clear currently set field                                // 2482
                            this[field.oneof.name] = field.name; // Point virtual field at this field                  // 2483
                        } else if (/* value === null && */currentField === keyOrObj)                                   // 2484
                            this[field.oneof.name] = null; // Clear virtual field (current field explicitly cleared)   // 2485
                    }                                                                                                  // 2486
                    return this;                                                                                       // 2487
                };                                                                                                     // 2488
                                                                                                                       // 2489
                /**                                                                                                    // 2490
                 * Sets a field's value. This is an alias for [@link ProtoBuf.Builder.Message#set}.                    // 2491
                 * @name ProtoBuf.Builder.Message#$set                                                                 // 2492
                 * @function                                                                                           // 2493
                 * @param {string|!Object.<string,*>} keyOrObj String key or plain object holding multiple values      // 2494
                 * @param {(*|boolean)=} value Value to set if key is a string, otherwise omitted                      // 2495
                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`                     // 2496
                 * @throws {Error} If the value cannot be set                                                          // 2497
                 * @expose                                                                                             // 2498
                 */                                                                                                    // 2499
                MessagePrototype.$set = MessagePrototype.set;                                                          // 2500
                                                                                                                       // 2501
                /**                                                                                                    // 2502
                 * Gets a field's value.                                                                               // 2503
                 * @name ProtoBuf.Builder.Message#get                                                                  // 2504
                 * @function                                                                                           // 2505
                 * @param {string} key Key                                                                             // 2506
                 * @param {boolean=} noAssert Whether to not assert for an actual field, defaults to `false`           // 2507
                 * @return {*} Value                                                                                   // 2508
                 * @throws {Error} If there is no such field                                                           // 2509
                 * @expose                                                                                             // 2510
                 */                                                                                                    // 2511
                MessagePrototype.get = function(key, noAssert) {                                                       // 2512
                    if (noAssert)                                                                                      // 2513
                        return this[key];                                                                              // 2514
                    var field = T._fieldsByName[key];                                                                  // 2515
                    if (!field || !(field instanceof ProtoBuf.Reflect.Message.Field))                                  // 2516
                        throw Error(this+"#"+key+" is not a field: undefined");                                        // 2517
                    if (!(field instanceof ProtoBuf.Reflect.Message.Field))                                            // 2518
                        throw Error(this+"#"+key+" is not a field: "+field.toString(true));                            // 2519
                    return this[field.name];                                                                           // 2520
                };                                                                                                     // 2521
                                                                                                                       // 2522
                /**                                                                                                    // 2523
                 * Gets a field's value. This is an alias for {@link ProtoBuf.Builder.Message#$get}.                   // 2524
                 * @name ProtoBuf.Builder.Message#$get                                                                 // 2525
                 * @function                                                                                           // 2526
                 * @param {string} key Key                                                                             // 2527
                 * @return {*} Value                                                                                   // 2528
                 * @throws {Error} If there is no such field                                                           // 2529
                 * @expose                                                                                             // 2530
                 */                                                                                                    // 2531
                MessagePrototype.$get = MessagePrototype.get;                                                          // 2532
                                                                                                                       // 2533
                // Getters and setters                                                                                 // 2534
                                                                                                                       // 2535
                for (var i=0; i<fields.length; i++) {                                                                  // 2536
                    var field = fields[i];                                                                             // 2537
                    // no setters for extension fields as these are named by their fqn                                 // 2538
                    if (field instanceof ProtoBuf.Reflect.Message.ExtensionField)                                      // 2539
                        continue;                                                                                      // 2540
                                                                                                                       // 2541
                    if (T.builder.options['populateAccessors'])                                                        // 2542
                        (function(field) {                                                                             // 2543
                            // set/get[SomeValue]                                                                      // 2544
                            var Name = field.originalName.replace(/(_[a-zA-Z])/g, function(match) {                    // 2545
                                return match.toUpperCase().replace('_','');                                            // 2546
                            });                                                                                        // 2547
                            Name = Name.substring(0,1).toUpperCase() + Name.substring(1);                              // 2548
                                                                                                                       // 2549
                            // set/get_[some_value] FIXME: Do we really need these?                                    // 2550
                            var name = field.originalName.replace(/([A-Z])/g, function(match) {                        // 2551
                                return "_"+match;                                                                      // 2552
                            });                                                                                        // 2553
                                                                                                                       // 2554
                            /**                                                                                        // 2555
                             * The current field's unbound setter function.                                            // 2556
                             * @function                                                                               // 2557
                             * @param {*} value                                                                        // 2558
                             * @param {boolean=} noAssert                                                              // 2559
                             * @returns {!ProtoBuf.Builder.Message}                                                    // 2560
                             * @inner                                                                                  // 2561
                             */                                                                                        // 2562
                            var setter = function(value, noAssert) {                                                   // 2563
                                this[field.name] = noAssert ? value : field.verifyValue(value);                        // 2564
                                return this;                                                                           // 2565
                            };                                                                                         // 2566
                                                                                                                       // 2567
                            /**                                                                                        // 2568
                             * The current field's unbound getter function.                                            // 2569
                             * @function                                                                               // 2570
                             * @returns {*}                                                                            // 2571
                             * @inner                                                                                  // 2572
                             */                                                                                        // 2573
                            var getter = function() {                                                                  // 2574
                                return this[field.name];                                                               // 2575
                            };                                                                                         // 2576
                                                                                                                       // 2577
                            if (T.getChild("set"+Name) === null)                                                       // 2578
                                /**                                                                                    // 2579
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.                                                                     // 2581
                                 * @name ProtoBuf.Builder.Message#set[SomeField]                                       // 2582
                                 * @function                                                                           // 2583
                                 * @param {*} value Value to set                                                       // 2584
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`     // 2585
                                 * @returns {!ProtoBuf.Builder.Message} this                                           // 2586
                                 * @abstract                                                                           // 2587
                                 * @throws {Error} If the value cannot be set                                          // 2588
                                 */                                                                                    // 2589
                                MessagePrototype["set"+Name] = setter;                                                 // 2590
                                                                                                                       // 2591
                            if (T.getChild("set_"+name) === null)                                                      // 2592
                                /**                                                                                    // 2593
                                 * Sets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.                                                                     // 2595
                                 * @name ProtoBuf.Builder.Message#set_[some_field]                                     // 2596
                                 * @function                                                                           // 2597
                                 * @param {*} value Value to set                                                       // 2598
                                 * @param {boolean=} noAssert Whether to not assert the value, defaults to `false`     // 2599
                                 * @returns {!ProtoBuf.Builder.Message} this                                           // 2600
                                 * @abstract                                                                           // 2601
                                 * @throws {Error} If the value cannot be set                                          // 2602
                                 */                                                                                    // 2603
                                MessagePrototype["set_"+name] = setter;                                                // 2604
                                                                                                                       // 2605
                            if (T.getChild("get"+Name) === null)                                                       // 2606
                                /**                                                                                    // 2607
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.                                                                     // 2609
                                 * @name ProtoBuf.Builder.Message#get[SomeField]                                       // 2610
                                 * @function                                                                           // 2611
                                 * @abstract                                                                           // 2612
                                 * @return {*} The value                                                               // 2613
                                 */                                                                                    // 2614
                                MessagePrototype["get"+Name] = getter;                                                 // 2615
                                                                                                                       // 2616
                            if (T.getChild("get_"+name) === null)                                                      // 2617
                                /**                                                                                    // 2618
                                 * Gets a value. This method is present for each field, but only if there is no name conflict with
                                 *  another field.                                                                     // 2620
                                 * @name ProtoBuf.Builder.Message#get_[some_field]                                     // 2621
                                 * @function                                                                           // 2622
                                 * @return {*} The value                                                               // 2623
                                 * @abstract                                                                           // 2624
                                 */                                                                                    // 2625
                                MessagePrototype["get_"+name] = getter;                                                // 2626
                                                                                                                       // 2627
                        })(field);                                                                                     // 2628
                }                                                                                                      // 2629
                                                                                                                       // 2630
                // En-/decoding                                                                                        // 2631
                                                                                                                       // 2632
                /**                                                                                                    // 2633
                 * Encodes the message.                                                                                // 2634
                 * @name ProtoBuf.Builder.Message#$encode                                                              // 2635
                 * @function                                                                                           // 2636
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`                  // 2638
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer                                               // 2639
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.                             // 2641
                 * @expose                                                                                             // 2642
                 * @see ProtoBuf.Builder.Message#encode64                                                              // 2643
                 * @see ProtoBuf.Builder.Message#encodeHex                                                             // 2644
                 * @see ProtoBuf.Builder.Message#encodeAB                                                              // 2645
                 */                                                                                                    // 2646
                MessagePrototype.encode = function(buffer, noVerify) {                                                 // 2647
                    if (typeof buffer === 'boolean')                                                                   // 2648
                        noVerify = buffer,                                                                             // 2649
                        buffer = undefined;                                                                            // 2650
                    var isNew = false;                                                                                 // 2651
                    if (!buffer)                                                                                       // 2652
                        buffer = new ByteBuffer(),                                                                     // 2653
                        isNew = true;                                                                                  // 2654
                    var le = buffer.littleEndian;                                                                      // 2655
                    try {                                                                                              // 2656
                        T.encode(this, buffer.LE(), noVerify);                                                         // 2657
                        return (isNew ? buffer.flip() : buffer).LE(le);                                                // 2658
                    } catch (e) {                                                                                      // 2659
                        buffer.LE(le);                                                                                 // 2660
                        throw(e);                                                                                      // 2661
                    }                                                                                                  // 2662
                };                                                                                                     // 2663
                                                                                                                       // 2664
                /**                                                                                                    // 2665
                 * Encodes a message using the specified data payload.                                                 // 2666
                 * @param {!Object.<string,*>} data Data payload                                                       // 2667
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`                  // 2669
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer                                               // 2670
                 * @expose                                                                                             // 2671
                 */                                                                                                    // 2672
                Message.encode = function(data, buffer, noVerify) {                                                    // 2673
                    return new Message(data).encode(buffer, noVerify);                                                 // 2674
                };                                                                                                     // 2675
                                                                                                                       // 2676
                /**                                                                                                    // 2677
                 * Calculates the byte length of the message.                                                          // 2678
                 * @name ProtoBuf.Builder.Message#calculate                                                            // 2679
                 * @function                                                                                           // 2680
                 * @returns {number} Byte length                                                                       // 2681
                 * @throws {Error} If the message cannot be calculated or if required fields are missing.              // 2682
                 * @expose                                                                                             // 2683
                 */                                                                                                    // 2684
                MessagePrototype.calculate = function() {                                                              // 2685
                    return T.calculate(this);                                                                          // 2686
                };                                                                                                     // 2687
                                                                                                                       // 2688
                /**                                                                                                    // 2689
                 * Encodes the varint32 length-delimited message.                                                      // 2690
                 * @name ProtoBuf.Builder.Message#encodeDelimited                                                      // 2691
                 * @function                                                                                           // 2692
                 * @param {(!ByteBuffer|boolean)=} buffer ByteBuffer to encode to. Will create a new one and flip it if omitted.
                 * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`                  // 2694
                 * @return {!ByteBuffer} Encoded message as a ByteBuffer                                               // 2695
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ByteBuffer in the `encoded` property on the error.                             // 2697
                 * @expose                                                                                             // 2698
                 */                                                                                                    // 2699
                MessagePrototype.encodeDelimited = function(buffer, noVerify) {                                        // 2700
                    var isNew = false;                                                                                 // 2701
                    if (!buffer)                                                                                       // 2702
                        buffer = new ByteBuffer(),                                                                     // 2703
                        isNew = true;                                                                                  // 2704
                    var enc = new ByteBuffer().LE();                                                                   // 2705
                    T.encode(this, enc, noVerify).flip();                                                              // 2706
                    buffer.writeVarint32(enc.remaining());                                                             // 2707
                    buffer.append(enc);                                                                                // 2708
                    return isNew ? buffer.flip() : buffer;                                                             // 2709
                };                                                                                                     // 2710
                                                                                                                       // 2711
                /**                                                                                                    // 2712
                 * Directly encodes the message to an ArrayBuffer.                                                     // 2713
                 * @name ProtoBuf.Builder.Message#encodeAB                                                             // 2714
                 * @function                                                                                           // 2715
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer                                                // 2716
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.                            // 2718
                 * @expose                                                                                             // 2719
                 */                                                                                                    // 2720
                MessagePrototype.encodeAB = function() {                                                               // 2721
                    try {                                                                                              // 2722
                        return this.encode().toArrayBuffer();                                                          // 2723
                    } catch (e) {                                                                                      // 2724
                        if (e["encoded"]) e["encoded"] = e["encoded"].toArrayBuffer();                                 // 2725
                        throw(e);                                                                                      // 2726
                    }                                                                                                  // 2727
                };                                                                                                     // 2728
                                                                                                                       // 2729
                /**                                                                                                    // 2730
                 * Returns the message as an ArrayBuffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeAB}.
                 * @name ProtoBuf.Builder.Message#toArrayBuffer                                                        // 2732
                 * @function                                                                                           // 2733
                 * @return {ArrayBuffer} Encoded message as ArrayBuffer                                                // 2734
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded ArrayBuffer in the `encoded` property on the error.                            // 2736
                 * @expose                                                                                             // 2737
                 */                                                                                                    // 2738
                MessagePrototype.toArrayBuffer = MessagePrototype.encodeAB;                                            // 2739
                                                                                                                       // 2740
                /**                                                                                                    // 2741
                 * Directly encodes the message to a node Buffer.                                                      // 2742
                 * @name ProtoBuf.Builder.Message#encodeNB                                                             // 2743
                 * @function                                                                                           // 2744
                 * @return {!Buffer}                                                                                   // 2745
                 * @throws {Error} If the message cannot be encoded, not running under node.js or if required fields are
                 *  missing. The later still returns the encoded node Buffer in the `encoded` property on the error.   // 2747
                 * @expose                                                                                             // 2748
                 */                                                                                                    // 2749
                MessagePrototype.encodeNB = function() {                                                               // 2750
                    try {                                                                                              // 2751
                        return this.encode().toBuffer();                                                               // 2752
                    } catch (e) {                                                                                      // 2753
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBuffer();                                      // 2754
                        throw(e);                                                                                      // 2755
                    }                                                                                                  // 2756
                };                                                                                                     // 2757
                                                                                                                       // 2758
                /**                                                                                                    // 2759
                 * Returns the message as a node Buffer. This is an alias for {@link ProtoBuf.Builder.Message#encodeNB}.
                 * @name ProtoBuf.Builder.Message#toBuffer                                                             // 2761
                 * @function                                                                                           // 2762
                 * @return {!Buffer}                                                                                   // 2763
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded node Buffer in the `encoded` property on the error.                            // 2765
                 * @expose                                                                                             // 2766
                 */                                                                                                    // 2767
                MessagePrototype.toBuffer = MessagePrototype.encodeNB;                                                 // 2768
                                                                                                                       // 2769
                /**                                                                                                    // 2770
                 * Directly encodes the message to a base64 encoded string.                                            // 2771
                 * @name ProtoBuf.Builder.Message#encode64                                                             // 2772
                 * @function                                                                                           // 2773
                 * @return {string} Base64 encoded string                                                              // 2774
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded base64 string in the `encoded` property on the error.                    // 2776
                 * @expose                                                                                             // 2777
                 */                                                                                                    // 2778
                MessagePrototype.encode64 = function() {                                                               // 2779
                    try {                                                                                              // 2780
                        return this.encode().toBase64();                                                               // 2781
                    } catch (e) {                                                                                      // 2782
                        if (e["encoded"]) e["encoded"] = e["encoded"].toBase64();                                      // 2783
                        throw(e);                                                                                      // 2784
                    }                                                                                                  // 2785
                };                                                                                                     // 2786
                                                                                                                       // 2787
                /**                                                                                                    // 2788
                 * Returns the message as a base64 encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encode64}.
                 * @name ProtoBuf.Builder.Message#toBase64                                                             // 2790
                 * @function                                                                                           // 2791
                 * @return {string} Base64 encoded string                                                              // 2792
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded base64 string in the `encoded` property on the error.                          // 2794
                 * @expose                                                                                             // 2795
                 */                                                                                                    // 2796
                MessagePrototype.toBase64 = MessagePrototype.encode64;                                                 // 2797
                                                                                                                       // 2798
                /**                                                                                                    // 2799
                 * Directly encodes the message to a hex encoded string.                                               // 2800
                 * @name ProtoBuf.Builder.Message#encodeHex                                                            // 2801
                 * @function                                                                                           // 2802
                 * @return {string} Hex encoded string                                                                 // 2803
                 * @throws {Error} If the underlying buffer cannot be encoded or if required fields are missing. The later
                 *  still returns the encoded hex string in the `encoded` property on the error.                       // 2805
                 * @expose                                                                                             // 2806
                 */                                                                                                    // 2807
                MessagePrototype.encodeHex = function() {                                                              // 2808
                    try {                                                                                              // 2809
                        return this.encode().toHex();                                                                  // 2810
                    } catch (e) {                                                                                      // 2811
                        if (e["encoded"]) e["encoded"] = e["encoded"].toHex();                                         // 2812
                        throw(e);                                                                                      // 2813
                    }                                                                                                  // 2814
                };                                                                                                     // 2815
                                                                                                                       // 2816
                /**                                                                                                    // 2817
                 * Returns the message as a hex encoded string. This is an alias for {@link ProtoBuf.Builder.Message#encodeHex}.
                 * @name ProtoBuf.Builder.Message#toHex                                                                // 2819
                 * @function                                                                                           // 2820
                 * @return {string} Hex encoded string                                                                 // 2821
                 * @throws {Error} If the message cannot be encoded or if required fields are missing. The later still
                 *  returns the encoded hex string in the `encoded` property on the error.                             // 2823
                 * @expose                                                                                             // 2824
                 */                                                                                                    // 2825
                MessagePrototype.toHex = MessagePrototype.encodeHex;                                                   // 2826
                                                                                                                       // 2827
                /**                                                                                                    // 2828
                 * Clones a message object or field value to a raw object.                                             // 2829
                 * @param {*} obj Object to clone                                                                      // 2830
                 * @param {boolean} binaryAsBase64 Whether to include binary data as base64 strings or as a buffer otherwise
                 * @param {boolean} longsAsStrings Whether to encode longs as strings                                  // 2832
                 * @param {!ProtoBuf.Reflect.T=} resolvedType The resolved field type if a field                       // 2833
                 * @returns {*} Cloned object                                                                          // 2834
                 * @inner                                                                                              // 2835
                 */                                                                                                    // 2836
                function cloneRaw(obj, binaryAsBase64, longsAsStrings, resolvedType) {                                 // 2837
                    if (obj === null || typeof obj !== 'object') {                                                     // 2838
                        // Convert enum values to their respective names                                               // 2839
                        if (resolvedType && resolvedType instanceof ProtoBuf.Reflect.Enum) {                           // 2840
                            var name = ProtoBuf.Reflect.Enum.getName(resolvedType.object, obj);                        // 2841
                            if (name !== null)                                                                         // 2842
                                return name;                                                                           // 2843
                        }                                                                                              // 2844
                        // Pass-through string, number, boolean, null...                                               // 2845
                        return obj;                                                                                    // 2846
                    }                                                                                                  // 2847
                    // Convert ByteBuffers to raw buffer or strings                                                    // 2848
                    if (ByteBuffer.isByteBuffer(obj))                                                                  // 2849
                        return binaryAsBase64 ? obj.toBase64() : obj.toBuffer();                                       // 2850
                    // Convert Longs to proper objects or strings                                                      // 2851
                    if (ProtoBuf.Long.isLong(obj))                                                                     // 2852
                        return longsAsStrings ? obj.toString() : ProtoBuf.Long.fromValue(obj);                         // 2853
                    var clone;                                                                                         // 2854
                    // Clone arrays                                                                                    // 2855
                    if (Array.isArray(obj)) {                                                                          // 2856
                        clone = [];                                                                                    // 2857
                        obj.forEach(function(v, k) {                                                                   // 2858
                            clone[k] = cloneRaw(v, binaryAsBase64, longsAsStrings, resolvedType);                      // 2859
                        });                                                                                            // 2860
                        return clone;                                                                                  // 2861
                    }                                                                                                  // 2862
                    clone = {};                                                                                        // 2863
                    // Convert maps to objects                                                                         // 2864
                    if (obj instanceof ProtoBuf.Map) {                                                                 // 2865
                        var it = obj.entries();                                                                        // 2866
                        for (var e = it.next(); !e.done; e = it.next())                                                // 2867
                            clone[obj.keyElem.valueToString(e.value[0])] = cloneRaw(e.value[1], binaryAsBase64, longsAsStrings, obj.valueElem.resolvedType);
                        return clone;                                                                                  // 2869
                    }                                                                                                  // 2870
                    // Everything else is a non-null object                                                            // 2871
                    var type = obj.$type,                                                                              // 2872
                        field = undefined;                                                                             // 2873
                    for (var i in obj)                                                                                 // 2874
                        if (obj.hasOwnProperty(i)) {                                                                   // 2875
                            if (type && (field = type.getChild(i)))                                                    // 2876
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings, field.resolvedType);       // 2877
                            else                                                                                       // 2878
                                clone[i] = cloneRaw(obj[i], binaryAsBase64, longsAsStrings);                           // 2879
                        }                                                                                              // 2880
                    return clone;                                                                                      // 2881
                }                                                                                                      // 2882
                                                                                                                       // 2883
                /**                                                                                                    // 2884
                 * Returns the message's raw payload.                                                                  // 2885
                 * @param {boolean=} binaryAsBase64 Whether to include binary data as base64 strings instead of Buffers, defaults to `false`
                 * @param {boolean} longsAsStrings Whether to encode longs as strings                                  // 2887
                 * @returns {Object.<string,*>} Raw payload                                                            // 2888
                 * @expose                                                                                             // 2889
                 */                                                                                                    // 2890
                MessagePrototype.toRaw = function(binaryAsBase64, longsAsStrings) {                                    // 2891
                    return cloneRaw(this, !!binaryAsBase64, !!longsAsStrings, this.$type);                             // 2892
                };                                                                                                     // 2893
                                                                                                                       // 2894
                /**                                                                                                    // 2895
                 * Encodes a message to JSON.                                                                          // 2896
                 * @returns {string} JSON string                                                                       // 2897
                 * @expose                                                                                             // 2898
                 */                                                                                                    // 2899
                MessagePrototype.encodeJSON = function() {                                                             // 2900
                    return JSON.stringify(                                                                             // 2901
                        cloneRaw(this,                                                                                 // 2902
                             /* binary-as-base64 */ true,                                                              // 2903
                             /* longs-as-strings */ true,                                                              // 2904
                             this.$type                                                                                // 2905
                        )                                                                                              // 2906
                    );                                                                                                 // 2907
                };                                                                                                     // 2908
                                                                                                                       // 2909
                /**                                                                                                    // 2910
                 * Decodes a message from the specified buffer or string.                                              // 2911
                 * @name ProtoBuf.Builder.Message.decode                                                               // 2912
                 * @function                                                                                           // 2913
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from                       // 2914
                 * @param {(number|string)=} length Message length. Defaults to decode all the remainig data.          // 2915
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {!ProtoBuf.Builder.Message} Decoded message                                                 // 2917
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.            // 2919
                 * @expose                                                                                             // 2920
                 * @see ProtoBuf.Builder.Message.decode64                                                              // 2921
                 * @see ProtoBuf.Builder.Message.decodeHex                                                             // 2922
                 */                                                                                                    // 2923
                Message.decode = function(buffer, length, enc) {                                                       // 2924
                    if (typeof length === 'string')                                                                    // 2925
                        enc = length,                                                                                  // 2926
                        length = -1;                                                                                   // 2927
                    if (typeof buffer === 'string')                                                                    // 2928
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");                                        // 2929
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw          // 2930
                    var le = buffer.littleEndian;                                                                      // 2931
                    try {                                                                                              // 2932
                        var msg = T.decode(buffer.LE());                                                               // 2933
                        buffer.LE(le);                                                                                 // 2934
                        return msg;                                                                                    // 2935
                    } catch (e) {                                                                                      // 2936
                        buffer.LE(le);                                                                                 // 2937
                        throw(e);                                                                                      // 2938
                    }                                                                                                  // 2939
                };                                                                                                     // 2940
                                                                                                                       // 2941
                /**                                                                                                    // 2942
                 * Decodes a varint32 length-delimited message from the specified buffer or string.                    // 2943
                 * @name ProtoBuf.Builder.Message.decodeDelimited                                                      // 2944
                 * @function                                                                                           // 2945
                 * @param {!ByteBuffer|!ArrayBuffer|!Buffer|string} buffer Buffer to decode from                       // 2946
                 * @param {string=} enc Encoding if buffer is a string: hex, utf8 (not recommended), defaults to base64
                 * @return {ProtoBuf.Builder.Message} Decoded message or `null` if not enough bytes are available yet  // 2948
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.            // 2950
                 * @expose                                                                                             // 2951
                 */                                                                                                    // 2952
                Message.decodeDelimited = function(buffer, enc) {                                                      // 2953
                    if (typeof buffer === 'string')                                                                    // 2954
                        buffer = ByteBuffer.wrap(buffer, enc ? enc : "base64");                                        // 2955
                    buffer = ByteBuffer.isByteBuffer(buffer) ? buffer : ByteBuffer.wrap(buffer); // May throw          // 2956
                    if (buffer.remaining() < 1)                                                                        // 2957
                        return null;                                                                                   // 2958
                    var off = buffer.offset,                                                                           // 2959
                        len = buffer.readVarint32();                                                                   // 2960
                    if (buffer.remaining() < len) {                                                                    // 2961
                        buffer.offset = off;                                                                           // 2962
                        return null;                                                                                   // 2963
                    }                                                                                                  // 2964
                    try {                                                                                              // 2965
                        var msg = T.decode(buffer.slice(buffer.offset, buffer.offset + len).LE());                     // 2966
                        buffer.offset += len;                                                                          // 2967
                        return msg;                                                                                    // 2968
                    } catch (err) {                                                                                    // 2969
                        buffer.offset += len;                                                                          // 2970
                        throw err;                                                                                     // 2971
                    }                                                                                                  // 2972
                };                                                                                                     // 2973
                                                                                                                       // 2974
                /**                                                                                                    // 2975
                 * Decodes the message from the specified base64 encoded string.                                       // 2976
                 * @name ProtoBuf.Builder.Message.decode64                                                             // 2977
                 * @function                                                                                           // 2978
                 * @param {string} str String to decode from                                                           // 2979
                 * @return {!ProtoBuf.Builder.Message} Decoded message                                                 // 2980
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.            // 2982
                 * @expose                                                                                             // 2983
                 */                                                                                                    // 2984
                Message.decode64 = function(str) {                                                                     // 2985
                    return Message.decode(str, "base64");                                                              // 2986
                };                                                                                                     // 2987
                                                                                                                       // 2988
                /**                                                                                                    // 2989
                 * Decodes the message from the specified hex encoded string.                                          // 2990
                 * @name ProtoBuf.Builder.Message.decodeHex                                                            // 2991
                 * @function                                                                                           // 2992
                 * @param {string} str String to decode from                                                           // 2993
                 * @return {!ProtoBuf.Builder.Message} Decoded message                                                 // 2994
                 * @throws {Error} If the message cannot be decoded or if required fields are missing. The later still
                 *  returns the decoded message with missing fields in the `decoded` property on the error.            // 2996
                 * @expose                                                                                             // 2997
                 */                                                                                                    // 2998
                Message.decodeHex = function(str) {                                                                    // 2999
                    return Message.decode(str, "hex");                                                                 // 3000
                };                                                                                                     // 3001
                                                                                                                       // 3002
                /**                                                                                                    // 3003
                 * Decodes the message from a JSON string.                                                             // 3004
                 * @name ProtoBuf.Builder.Message.decodeJSON                                                           // 3005
                 * @function                                                                                           // 3006
                 * @param {string} str String to decode from                                                           // 3007
                 * @return {!ProtoBuf.Builder.Message} Decoded message                                                 // 3008
                 * @throws {Error} If the message cannot be decoded or if required fields are                          // 3009
                 * missing.                                                                                            // 3010
                 * @expose                                                                                             // 3011
                 */                                                                                                    // 3012
                Message.decodeJSON = function(str) {                                                                   // 3013
                    return new Message(JSON.parse(str));                                                               // 3014
                };                                                                                                     // 3015
                                                                                                                       // 3016
                // Utility                                                                                             // 3017
                                                                                                                       // 3018
                /**                                                                                                    // 3019
                 * Returns a string representation of this Message.                                                    // 3020
                 * @name ProtoBuf.Builder.Message#toString                                                             // 3021
                 * @function                                                                                           // 3022
                 * @return {string} String representation as of ".Fully.Qualified.MessageName"                         // 3023
                 * @expose                                                                                             // 3024
                 */                                                                                                    // 3025
                MessagePrototype.toString = function() {                                                               // 3026
                    return T.toString();                                                                               // 3027
                };                                                                                                     // 3028
                                                                                                                       // 3029
                // Properties                                                                                          // 3030
                                                                                                                       // 3031
                /**                                                                                                    // 3032
                 * Message options.                                                                                    // 3033
                 * @name ProtoBuf.Builder.Message.$options                                                             // 3034
                 * @type {Object.<string,*>}                                                                           // 3035
                 * @expose                                                                                             // 3036
                 */                                                                                                    // 3037
                var $optionsS; // cc needs this                                                                        // 3038
                                                                                                                       // 3039
                /**                                                                                                    // 3040
                 * Message options.                                                                                    // 3041
                 * @name ProtoBuf.Builder.Message#$options                                                             // 3042
                 * @type {Object.<string,*>}                                                                           // 3043
                 * @expose                                                                                             // 3044
                 */                                                                                                    // 3045
                var $options;                                                                                          // 3046
                                                                                                                       // 3047
                /**                                                                                                    // 3048
                 * Reflection type.                                                                                    // 3049
                 * @name ProtoBuf.Builder.Message.$type                                                                // 3050
                 * @type {!ProtoBuf.Reflect.Message}                                                                   // 3051
                 * @expose                                                                                             // 3052
                 */                                                                                                    // 3053
                var $typeS;                                                                                            // 3054
                                                                                                                       // 3055
                /**                                                                                                    // 3056
                 * Reflection type.                                                                                    // 3057
                 * @name ProtoBuf.Builder.Message#$type                                                                // 3058
                 * @type {!ProtoBuf.Reflect.Message}                                                                   // 3059
                 * @expose                                                                                             // 3060
                 */                                                                                                    // 3061
                var $type;                                                                                             // 3062
                                                                                                                       // 3063
                if (Object.defineProperty)                                                                             // 3064
                    Object.defineProperty(Message, '$options', { "value": T.buildOpt() }),                             // 3065
                    Object.defineProperty(MessagePrototype, "$options", { "value": Message["$options"] }),             // 3066
                    Object.defineProperty(Message, "$type", { "value": T }),                                           // 3067
                    Object.defineProperty(MessagePrototype, "$type", { "value": T });                                  // 3068
                                                                                                                       // 3069
                return Message;                                                                                        // 3070
                                                                                                                       // 3071
            })(ProtoBuf, this);                                                                                        // 3072
                                                                                                                       // 3073
            // Static enums and prototyped sub-messages / cached collections                                           // 3074
            this._fields = [];                                                                                         // 3075
            this._fieldsById = {};                                                                                     // 3076
            this._fieldsByName = {};                                                                                   // 3077
            for (var i=0, k=this.children.length, child; i<k; i++) {                                                   // 3078
                child = this.children[i];                                                                              // 3079
                if (child instanceof Enum || child instanceof Message || child instanceof Service) {                   // 3080
                    if (clazz.hasOwnProperty(child.name))                                                              // 3081
                        throw Error("Illegal reflect child of "+this.toString(true)+": "+child.toString(true)+" cannot override static property '"+child.name+"'");
                    clazz[child.name] = child.build();                                                                 // 3083
                } else if (child instanceof Message.Field)                                                             // 3084
                    child.build(),                                                                                     // 3085
                    this._fields.push(child),                                                                          // 3086
                    this._fieldsById[child.id] = child,                                                                // 3087
                    this._fieldsByName[child.name] = child;                                                            // 3088
                else if (!(child instanceof Message.OneOf) && !(child instanceof Extension)) // Not built              // 3089
                    throw Error("Illegal reflect child of "+this.toString(true)+": "+this.children[i].toString(true));
            }                                                                                                          // 3091
                                                                                                                       // 3092
            return this.clazz = clazz;                                                                                 // 3093
        };                                                                                                             // 3094
                                                                                                                       // 3095
        /**                                                                                                            // 3096
         * Encodes a runtime message's contents to the specified buffer.                                               // 3097
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode                                        // 3098
         * @param {ByteBuffer} buffer ByteBuffer to write to                                                           // 3099
         * @param {boolean=} noVerify Whether to not verify field values, defaults to `false`                          // 3100
         * @return {ByteBuffer} The ByteBuffer for chaining                                                            // 3101
         * @throws {Error} If required fields are missing or the message cannot be encoded for another reason          // 3102
         * @expose                                                                                                     // 3103
         */                                                                                                            // 3104
        MessagePrototype.encode = function(message, buffer, noVerify) {                                                // 3105
            var fieldMissing = null,                                                                                   // 3106
                field;                                                                                                 // 3107
            for (var i=0, k=this._fields.length, val; i<k; ++i) {                                                      // 3108
                field = this._fields[i];                                                                               // 3109
                val = message[field.name];                                                                             // 3110
                if (field.required && val === null) {                                                                  // 3111
                    if (fieldMissing === null)                                                                         // 3112
                        fieldMissing = field;                                                                          // 3113
                } else                                                                                                 // 3114
                    field.encode(noVerify ? val : field.verifyValue(val), buffer, message);                            // 3115
            }                                                                                                          // 3116
            if (fieldMissing !== null) {                                                                               // 3117
                var err = Error("Missing at least one required field for "+this.toString(true)+": "+fieldMissing);     // 3118
                err["encoded"] = buffer; // Still expose what we got                                                   // 3119
                throw(err);                                                                                            // 3120
            }                                                                                                          // 3121
            return buffer;                                                                                             // 3122
        };                                                                                                             // 3123
                                                                                                                       // 3124
        /**                                                                                                            // 3125
         * Calculates a runtime message's byte length.                                                                 // 3126
         * @param {!ProtoBuf.Builder.Message} message Runtime message to encode                                        // 3127
         * @returns {number} Byte length                                                                               // 3128
         * @throws {Error} If required fields are missing or the message cannot be calculated for another reason       // 3129
         * @expose                                                                                                     // 3130
         */                                                                                                            // 3131
        MessagePrototype.calculate = function(message) {                                                               // 3132
            for (var n=0, i=0, k=this._fields.length, field, val; i<k; ++i) {                                          // 3133
                field = this._fields[i];                                                                               // 3134
                val = message[field.name];                                                                             // 3135
                if (field.required && val === null)                                                                    // 3136
                   throw Error("Missing at least one required field for "+this.toString(true)+": "+field);             // 3137
                else                                                                                                   // 3138
                    n += field.calculate(val, message);                                                                // 3139
            }                                                                                                          // 3140
            return n;                                                                                                  // 3141
        };                                                                                                             // 3142
                                                                                                                       // 3143
        /**                                                                                                            // 3144
         * Skips all data until the end of the specified group has been reached.                                       // 3145
         * @param {number} expectedId Expected GROUPEND id                                                             // 3146
         * @param {!ByteBuffer} buf ByteBuffer                                                                         // 3147
         * @returns {boolean} `true` if a value as been skipped, `false` if the end has been reached                   // 3148
         * @throws {Error} If it wasn't possible to find the end of the group (buffer overrun or end tag mismatch)     // 3149
         * @inner                                                                                                      // 3150
         */                                                                                                            // 3151
        function skipTillGroupEnd(expectedId, buf) {                                                                   // 3152
            var tag = buf.readVarint32(), // Throws on OOB                                                             // 3153
                wireType = tag & 0x07,                                                                                 // 3154
                id = tag >>> 3;                                                                                        // 3155
            switch (wireType) {                                                                                        // 3156
                case ProtoBuf.WIRE_TYPES.VARINT:                                                                       // 3157
                    do tag = buf.readUint8();                                                                          // 3158
                    while ((tag & 0x80) === 0x80);                                                                     // 3159
                    break;                                                                                             // 3160
                case ProtoBuf.WIRE_TYPES.BITS64:                                                                       // 3161
                    buf.offset += 8;                                                                                   // 3162
                    break;                                                                                             // 3163
                case ProtoBuf.WIRE_TYPES.LDELIM:                                                                       // 3164
                    tag = buf.readVarint32(); // reads the varint                                                      // 3165
                    buf.offset += tag;        // skips n bytes                                                         // 3166
                    break;                                                                                             // 3167
                case ProtoBuf.WIRE_TYPES.STARTGROUP:                                                                   // 3168
                    skipTillGroupEnd(id, buf);                                                                         // 3169
                    break;                                                                                             // 3170
                case ProtoBuf.WIRE_TYPES.ENDGROUP:                                                                     // 3171
                    if (id === expectedId)                                                                             // 3172
                        return false;                                                                                  // 3173
                    else                                                                                               // 3174
                        throw Error("Illegal GROUPEND after unknown group: "+id+" ("+expectedId+" expected)");         // 3175
                case ProtoBuf.WIRE_TYPES.BITS32:                                                                       // 3176
                    buf.offset += 4;                                                                                   // 3177
                    break;                                                                                             // 3178
                default:                                                                                               // 3179
                    throw Error("Illegal wire type in unknown group "+expectedId+": "+wireType);                       // 3180
            }                                                                                                          // 3181
            return true;                                                                                               // 3182
        }                                                                                                              // 3183
                                                                                                                       // 3184
        /**                                                                                                            // 3185
         * Decodes an encoded message and returns the decoded message.                                                 // 3186
         * @param {ByteBuffer} buffer ByteBuffer to decode from                                                        // 3187
         * @param {number=} length Message length. Defaults to decode all remaining data.                              // 3188
         * @param {number=} expectedGroupEndId Expected GROUPEND id if this is a legacy group                          // 3189
         * @return {ProtoBuf.Builder.Message} Decoded message                                                          // 3190
         * @throws {Error} If the message cannot be decoded                                                            // 3191
         * @expose                                                                                                     // 3192
         */                                                                                                            // 3193
        MessagePrototype.decode = function(buffer, length, expectedGroupEndId) {                                       // 3194
            length = typeof length === 'number' ? length : -1;                                                         // 3195
            var start = buffer.offset,                                                                                 // 3196
                msg = new (this.clazz)(),                                                                              // 3197
                tag, wireType, id, field;                                                                              // 3198
            while (buffer.offset < start+length || (length === -1 && buffer.remaining() > 0)) {                        // 3199
                tag = buffer.readVarint32();                                                                           // 3200
                wireType = tag & 0x07;                                                                                 // 3201
                id = tag >>> 3;                                                                                        // 3202
                if (wireType === ProtoBuf.WIRE_TYPES.ENDGROUP) {                                                       // 3203
                    if (id !== expectedGroupEndId)                                                                     // 3204
                        throw Error("Illegal group end indicator for "+this.toString(true)+": "+id+" ("+(expectedGroupEndId ? expectedGroupEndId+" expected" : "not a group")+")");
                    break;                                                                                             // 3206
                }                                                                                                      // 3207
                if (!(field = this._fieldsById[id])) {                                                                 // 3208
                    // "messages created by your new code can be parsed by your old code: old binaries simply ignore the new field when parsing."
                    switch (wireType) {                                                                                // 3210
                        case ProtoBuf.WIRE_TYPES.VARINT:                                                               // 3211
                            buffer.readVarint32();                                                                     // 3212
                            break;                                                                                     // 3213
                        case ProtoBuf.WIRE_TYPES.BITS32:                                                               // 3214
                            buffer.offset += 4;                                                                        // 3215
                            break;                                                                                     // 3216
                        case ProtoBuf.WIRE_TYPES.BITS64:                                                               // 3217
                            buffer.offset += 8;                                                                        // 3218
                            break;                                                                                     // 3219
                        case ProtoBuf.WIRE_TYPES.LDELIM:                                                               // 3220
                            var len = buffer.readVarint32();                                                           // 3221
                            buffer.offset += len;                                                                      // 3222
                            break;                                                                                     // 3223
                        case ProtoBuf.WIRE_TYPES.STARTGROUP:                                                           // 3224
                            while (skipTillGroupEnd(id, buffer)) {}                                                    // 3225
                            break;                                                                                     // 3226
                        default:                                                                                       // 3227
                            throw Error("Illegal wire type for unknown field "+id+" in "+this.toString(true)+"#decode: "+wireType);
                    }                                                                                                  // 3229
                    continue;                                                                                          // 3230
                }                                                                                                      // 3231
                if (field.repeated && !field.options["packed"]) {                                                      // 3232
                    msg[field.name].push(field.decode(wireType, buffer));                                              // 3233
                } else if (field.map) {                                                                                // 3234
                    var keyval = field.decode(wireType, buffer);                                                       // 3235
                    msg[field.name].set(keyval[0], keyval[1]);                                                         // 3236
                } else {                                                                                               // 3237
                    msg[field.name] = field.decode(wireType, buffer);                                                  // 3238
                    if (field.oneof) { // Field is part of an OneOf (not a virtual OneOf field)                        // 3239
                        var currentField = msg[field.oneof.name]; // Virtual field references currently set field      // 3240
                        if (currentField !== null && currentField !== field.name)                                      // 3241
                            msg[currentField] = null; // Clear currently set field                                     // 3242
                        msg[field.oneof.name] = field.name; // Point virtual field at this field                       // 3243
                    }                                                                                                  // 3244
                }                                                                                                      // 3245
            }                                                                                                          // 3246
                                                                                                                       // 3247
            // Check if all required fields are present and set default values for optional fields that are not        // 3248
            for (var i=0, k=this._fields.length; i<k; ++i) {                                                           // 3249
                field = this._fields[i];                                                                               // 3250
                if (msg[field.name] === null) {                                                                        // 3251
                    if (this.syntax === "proto3") { // Proto3 sets default values by specification                     // 3252
                        msg[field.name] = field.defaultValue;                                                          // 3253
                    } else if (field.required) {                                                                       // 3254
                        var err = Error("Missing at least one required field for " + this.toString(true) + ": " + field.name);
                        err["decoded"] = msg; // Still expose what we got                                              // 3256
                        throw(err);                                                                                    // 3257
                    } else if (ProtoBuf.populateDefaults && field.defaultValue !== null)                               // 3258
                        msg[field.name] = field.defaultValue;                                                          // 3259
                }                                                                                                      // 3260
            }                                                                                                          // 3261
            return msg;                                                                                                // 3262
        };                                                                                                             // 3263
                                                                                                                       // 3264
        /**                                                                                                            // 3265
         * @alias ProtoBuf.Reflect.Message                                                                             // 3266
         * @expose                                                                                                     // 3267
         */                                                                                                            // 3268
        Reflect.Message = Message;                                                                                     // 3269
                                                                                                                       // 3270
        /**                                                                                                            // 3271
         * Constructs a new Message Field.                                                                             // 3272
         * @exports ProtoBuf.Reflect.Message.Field                                                                     // 3273
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3274
         * @param {!ProtoBuf.Reflect.Message} message Message reference                                                // 3275
         * @param {string} rule Rule, one of requried, optional, repeated                                              // 3276
         * @param {string?} keytype Key data type, if any.                                                             // 3277
         * @param {string} type Data type, e.g. int32                                                                  // 3278
         * @param {string} name Field name                                                                             // 3279
         * @param {number} id Unique field id                                                                          // 3280
         * @param {Object.<string,*>=} options Options                                                                 // 3281
         * @param {!ProtoBuf.Reflect.Message.OneOf=} oneof Enclosing OneOf                                             // 3282
         * @param {string?} syntax The syntax level of this definition (e.g., proto3)                                  // 3283
         * @constructor                                                                                                // 3284
         * @extends ProtoBuf.Reflect.T                                                                                 // 3285
         */                                                                                                            // 3286
        var Field = function(builder, message, rule, keytype, type, name, id, options, oneof, syntax) {                // 3287
            T.call(this, builder, message, name);                                                                      // 3288
                                                                                                                       // 3289
            /**                                                                                                        // 3290
             * @override                                                                                               // 3291
             */                                                                                                        // 3292
            this.className = "Message.Field";                                                                          // 3293
                                                                                                                       // 3294
            /**                                                                                                        // 3295
             * Message field required flag.                                                                            // 3296
             * @type {boolean}                                                                                         // 3297
             * @expose                                                                                                 // 3298
             */                                                                                                        // 3299
            this.required = rule === "required";                                                                       // 3300
                                                                                                                       // 3301
            /**                                                                                                        // 3302
             * Message field repeated flag.                                                                            // 3303
             * @type {boolean}                                                                                         // 3304
             * @expose                                                                                                 // 3305
             */                                                                                                        // 3306
            this.repeated = rule === "repeated";                                                                       // 3307
                                                                                                                       // 3308
            /**                                                                                                        // 3309
             * Message field map flag.                                                                                 // 3310
             * @type {boolean}                                                                                         // 3311
             * @expose                                                                                                 // 3312
             */                                                                                                        // 3313
            this.map = rule === "map";                                                                                 // 3314
                                                                                                                       // 3315
            /**                                                                                                        // 3316
             * Message field key type. Type reference string if unresolved, protobuf                                   // 3317
             * type if resolved. Valid only if this.map === true, null otherwise.                                      // 3318
             * @type {string|{name: string, wireType: number}|null}                                                    // 3319
             * @expose                                                                                                 // 3320
             */                                                                                                        // 3321
            this.keyType = keytype || null;                                                                            // 3322
                                                                                                                       // 3323
            /**                                                                                                        // 3324
             * Message field type. Type reference string if unresolved, protobuf type if                               // 3325
             * resolved. In a map field, this is the value type.                                                       // 3326
             * @type {string|{name: string, wireType: number}}                                                         // 3327
             * @expose                                                                                                 // 3328
             */                                                                                                        // 3329
            this.type = type;                                                                                          // 3330
                                                                                                                       // 3331
            /**                                                                                                        // 3332
             * Resolved type reference inside the global namespace.                                                    // 3333
             * @type {ProtoBuf.Reflect.T|null}                                                                         // 3334
             * @expose                                                                                                 // 3335
             */                                                                                                        // 3336
            this.resolvedType = null;                                                                                  // 3337
                                                                                                                       // 3338
            /**                                                                                                        // 3339
             * Unique message field id.                                                                                // 3340
             * @type {number}                                                                                          // 3341
             * @expose                                                                                                 // 3342
             */                                                                                                        // 3343
            this.id = id;                                                                                              // 3344
                                                                                                                       // 3345
            /**                                                                                                        // 3346
             * Message field options.                                                                                  // 3347
             * @type {!Object.<string,*>}                                                                              // 3348
             * @dict                                                                                                   // 3349
             * @expose                                                                                                 // 3350
             */                                                                                                        // 3351
            this.options = options || {};                                                                              // 3352
                                                                                                                       // 3353
            /**                                                                                                        // 3354
             * Default value.                                                                                          // 3355
             * @type {*}                                                                                               // 3356
             * @expose                                                                                                 // 3357
             */                                                                                                        // 3358
            this.defaultValue = null;                                                                                  // 3359
                                                                                                                       // 3360
            /**                                                                                                        // 3361
             * Enclosing OneOf.                                                                                        // 3362
             * @type {?ProtoBuf.Reflect.Message.OneOf}                                                                 // 3363
             * @expose                                                                                                 // 3364
             */                                                                                                        // 3365
            this.oneof = oneof || null;                                                                                // 3366
                                                                                                                       // 3367
            /**                                                                                                        // 3368
             * Syntax level of this definition (e.g., proto3).                                                         // 3369
             * @type {string}                                                                                          // 3370
             * @expose                                                                                                 // 3371
             */                                                                                                        // 3372
            this.syntax = syntax || 'proto2';                                                                          // 3373
                                                                                                                       // 3374
            /**                                                                                                        // 3375
             * Original field name.                                                                                    // 3376
             * @type {string}                                                                                          // 3377
             * @expose                                                                                                 // 3378
             */                                                                                                        // 3379
            this.originalName = this.name; // Used to revert camelcase transformation on naming collisions             // 3380
                                                                                                                       // 3381
            /**                                                                                                        // 3382
             * Element implementation. Created in build() after types are resolved.                                    // 3383
             * @type {ProtoBuf.Element}                                                                                // 3384
             * @expose                                                                                                 // 3385
             */                                                                                                        // 3386
            this.element = null;                                                                                       // 3387
                                                                                                                       // 3388
            /**                                                                                                        // 3389
             * Key element implementation, for map fields. Created in build() after                                    // 3390
             * types are resolved.                                                                                     // 3391
             * @type {ProtoBuf.Element}                                                                                // 3392
             * @expose                                                                                                 // 3393
             */                                                                                                        // 3394
            this.keyElement = null;                                                                                    // 3395
                                                                                                                       // 3396
            // Convert field names to camel case notation if the override is set                                       // 3397
            if (this.builder.options['convertFieldsToCamelCase'] && !(this instanceof Message.ExtensionField))         // 3398
                this.name = ProtoBuf.Util.toCamelCase(this.name);                                                      // 3399
        };                                                                                                             // 3400
                                                                                                                       // 3401
        /**                                                                                                            // 3402
         * @alias ProtoBuf.Reflect.Message.Field.prototype                                                             // 3403
         * @inner                                                                                                      // 3404
         */                                                                                                            // 3405
        var FieldPrototype = Field.prototype = Object.create(T.prototype);                                             // 3406
                                                                                                                       // 3407
        /**                                                                                                            // 3408
         * Builds the field.                                                                                           // 3409
         * @override                                                                                                   // 3410
         * @expose                                                                                                     // 3411
         */                                                                                                            // 3412
        FieldPrototype.build = function() {                                                                            // 3413
            this.element = new Element(this.type, this.resolvedType, false, this.syntax);                              // 3414
            if (this.map)                                                                                              // 3415
                this.keyElement = new Element(this.keyType, undefined, true, this.syntax);                             // 3416
                                                                                                                       // 3417
            // In proto3, fields do not have field presence, and every field is set to                                 // 3418
            // its type's default value ("", 0, 0.0, or false).                                                        // 3419
            if (this.syntax === 'proto3' && !this.repeated && !this.map)                                               // 3420
                this.defaultValue = Element.defaultFieldValue(this.type);                                              // 3421
                                                                                                                       // 3422
            // Otherwise, default values are present when explicitly specified                                         // 3423
            else if (typeof this.options['default'] !== 'undefined')                                                   // 3424
                this.defaultValue = this.verifyValue(this.options['default']);                                         // 3425
        };                                                                                                             // 3426
                                                                                                                       // 3427
        /**                                                                                                            // 3428
         * Checks if the given value can be set for this field.                                                        // 3429
         * @param {*} value Value to check                                                                             // 3430
         * @param {boolean=} skipRepeated Whether to skip the repeated value check or not. Defaults to false.          // 3431
         * @return {*} Verified, maybe adjusted, value                                                                 // 3432
         * @throws {Error} If the value cannot be set for this field                                                   // 3433
         * @expose                                                                                                     // 3434
         */                                                                                                            // 3435
        FieldPrototype.verifyValue = function(value, skipRepeated) {                                                   // 3436
            skipRepeated = skipRepeated || false;                                                                      // 3437
            var self = this;                                                                                           // 3438
            function fail(val, msg) {                                                                                  // 3439
                throw Error("Illegal value for "+self.toString(true)+" of type "+self.type.name+": "+val+" ("+msg+")");
            }                                                                                                          // 3441
            if (value === null) { // NULL values for optional fields                                                   // 3442
                if (this.required)                                                                                     // 3443
                    fail(typeof value, "required");                                                                    // 3444
                if (this.syntax === 'proto3' && this.type !== ProtoBuf.TYPES["message"])                               // 3445
                    fail(typeof value, "proto3 field without field presence cannot be null");                          // 3446
                return null;                                                                                           // 3447
            }                                                                                                          // 3448
            var i;                                                                                                     // 3449
            if (this.repeated && !skipRepeated) { // Repeated values as arrays                                         // 3450
                if (!Array.isArray(value))                                                                             // 3451
                    value = [value];                                                                                   // 3452
                var res = [];                                                                                          // 3453
                for (i=0; i<value.length; i++)                                                                         // 3454
                    res.push(this.element.verifyValue(value[i]));                                                      // 3455
                return res;                                                                                            // 3456
            }                                                                                                          // 3457
            if (this.map && !skipRepeated) { // Map values as objects                                                  // 3458
                if (!(value instanceof ProtoBuf.Map)) {                                                                // 3459
                    // If not already a Map, attempt to convert.                                                       // 3460
                    if (!(value instanceof Object)) {                                                                  // 3461
                        fail(typeof value,                                                                             // 3462
                             "expected ProtoBuf.Map or raw object for map field");                                     // 3463
                    }                                                                                                  // 3464
                    return new ProtoBuf.Map(this, value);                                                              // 3465
                } else {                                                                                               // 3466
                    return value;                                                                                      // 3467
                }                                                                                                      // 3468
            }                                                                                                          // 3469
            // All non-repeated fields expect no array                                                                 // 3470
            if (!this.repeated && Array.isArray(value))                                                                // 3471
                fail(typeof value, "no array expected");                                                               // 3472
                                                                                                                       // 3473
            return this.element.verifyValue(value);                                                                    // 3474
        };                                                                                                             // 3475
                                                                                                                       // 3476
        /**                                                                                                            // 3477
         * Determines whether the field will have a presence on the wire given its                                     // 3478
         * value.                                                                                                      // 3479
         * @param {*} value Verified field value                                                                       // 3480
         * @param {!ProtoBuf.Builder.Message} message Runtime message                                                  // 3481
         * @return {boolean} Whether the field will be present on the wire                                             // 3482
         */                                                                                                            // 3483
        FieldPrototype.hasWirePresence = function(value, message) {                                                    // 3484
            if (this.syntax !== 'proto3')                                                                              // 3485
                return (value !== null);                                                                               // 3486
            if (this.oneof && message[this.oneof.name] === this.name)                                                  // 3487
                return true;                                                                                           // 3488
            switch (this.type) {                                                                                       // 3489
                case ProtoBuf.TYPES["int32"]:                                                                          // 3490
                case ProtoBuf.TYPES["sint32"]:                                                                         // 3491
                case ProtoBuf.TYPES["sfixed32"]:                                                                       // 3492
                case ProtoBuf.TYPES["uint32"]:                                                                         // 3493
                case ProtoBuf.TYPES["fixed32"]:                                                                        // 3494
                    return value !== 0;                                                                                // 3495
                                                                                                                       // 3496
                case ProtoBuf.TYPES["int64"]:                                                                          // 3497
                case ProtoBuf.TYPES["sint64"]:                                                                         // 3498
                case ProtoBuf.TYPES["sfixed64"]:                                                                       // 3499
                case ProtoBuf.TYPES["uint64"]:                                                                         // 3500
                case ProtoBuf.TYPES["fixed64"]:                                                                        // 3501
                    return value.low !== 0 || value.high !== 0;                                                        // 3502
                                                                                                                       // 3503
                case ProtoBuf.TYPES["bool"]:                                                                           // 3504
                    return value;                                                                                      // 3505
                                                                                                                       // 3506
                case ProtoBuf.TYPES["float"]:                                                                          // 3507
                case ProtoBuf.TYPES["double"]:                                                                         // 3508
                    return value !== 0.0;                                                                              // 3509
                                                                                                                       // 3510
                case ProtoBuf.TYPES["string"]:                                                                         // 3511
                    return value.length > 0;                                                                           // 3512
                                                                                                                       // 3513
                case ProtoBuf.TYPES["bytes"]:                                                                          // 3514
                    return value.remaining() > 0;                                                                      // 3515
                                                                                                                       // 3516
                case ProtoBuf.TYPES["enum"]:                                                                           // 3517
                    return value !== 0;                                                                                // 3518
                                                                                                                       // 3519
                case ProtoBuf.TYPES["message"]:                                                                        // 3520
                    return value !== null;                                                                             // 3521
                default:                                                                                               // 3522
                    return true;                                                                                       // 3523
            }                                                                                                          // 3524
        };                                                                                                             // 3525
                                                                                                                       // 3526
        /**                                                                                                            // 3527
         * Encodes the specified field value to the specified buffer.                                                  // 3528
         * @param {*} value Verified field value                                                                       // 3529
         * @param {ByteBuffer} buffer ByteBuffer to encode to                                                          // 3530
         * @param {!ProtoBuf.Builder.Message} message Runtime message                                                  // 3531
         * @return {ByteBuffer} The ByteBuffer for chaining                                                            // 3532
         * @throws {Error} If the field cannot be encoded                                                              // 3533
         * @expose                                                                                                     // 3534
         */                                                                                                            // 3535
        FieldPrototype.encode = function(value, buffer, message) {                                                     // 3536
            if (this.type === null || typeof this.type !== 'object')                                                   // 3537
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);                      // 3538
            if (value === null || (this.repeated && value.length == 0))                                                // 3539
                return buffer; // Optional omitted                                                                     // 3540
            try {                                                                                                      // 3541
                if (this.repeated) {                                                                                   // 3542
                    var i;                                                                                             // 3543
                    // "Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire
                    // types) can be declared 'packed'."                                                               // 3545
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {     // 3546
                        // "All of the elements of the field are packed into a single key-value pair with wire type 2  // 3547
                        // (length-delimited). Each element is encoded the same way it would be normally, except without a
                        // tag preceding it."                                                                          // 3549
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);                             // 3550
                        buffer.ensureCapacity(buffer.offset += 1); // We do not know the length yet, so let's assume a varint of length 1
                        var start = buffer.offset; // Remember where the contents begin                                // 3552
                        for (i=0; i<value.length; i++)                                                                 // 3553
                            this.element.encodeValue(this.id, value[i], buffer);                                       // 3554
                        var len = buffer.offset-start,                                                                 // 3555
                            varintLen = ByteBuffer.calculateVarint32(len);                                             // 3556
                        if (varintLen > 1) { // We need to move the contents                                           // 3557
                            var contents = buffer.slice(start, buffer.offset);                                         // 3558
                            start += varintLen-1;                                                                      // 3559
                            buffer.offset = start;                                                                     // 3560
                            buffer.append(contents);                                                                   // 3561
                        }                                                                                              // 3562
                        buffer.writeVarint32(len, start-varintLen);                                                    // 3563
                    } else {                                                                                           // 3564
                        // "If your message definition has repeated elements (without the [packed=true] option), the encoded
                        // message has zero or more key-value pairs with the same tag number"                          // 3566
                        for (i=0; i<value.length; i++)                                                                 // 3567
                            buffer.writeVarint32((this.id << 3) | this.type.wireType),                                 // 3568
                            this.element.encodeValue(this.id, value[i], buffer);                                       // 3569
                    }                                                                                                  // 3570
                } else if (this.map) {                                                                                 // 3571
                    // Write out each map entry as a submessage.                                                       // 3572
                    value.forEach(function(val, key, m) {                                                              // 3573
                        // Compute the length of the submessage (key, val) pair.                                       // 3574
                        var length =                                                                                   // 3575
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +                           // 3576
                            this.keyElement.calculateLength(1, key) +                                                  // 3577
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +                              // 3578
                            this.element.calculateLength(2, val);                                                      // 3579
                                                                                                                       // 3580
                        // Submessage with wire type of length-delimited.                                              // 3581
                        buffer.writeVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);                             // 3582
                        buffer.writeVarint32(length);                                                                  // 3583
                                                                                                                       // 3584
                        // Write out the key and val.                                                                  // 3585
                        buffer.writeVarint32((1 << 3) | this.keyType.wireType);                                        // 3586
                        this.keyElement.encodeValue(1, key, buffer);                                                   // 3587
                        buffer.writeVarint32((2 << 3) | this.type.wireType);                                           // 3588
                        this.element.encodeValue(2, val, buffer);                                                      // 3589
                    }, this);                                                                                          // 3590
                } else {                                                                                               // 3591
                    if (this.hasWirePresence(value, message)) {                                                        // 3592
                        buffer.writeVarint32((this.id << 3) | this.type.wireType);                                     // 3593
                        this.element.encodeValue(this.id, value, buffer);                                              // 3594
                    }                                                                                                  // 3595
                }                                                                                                      // 3596
            } catch (e) {                                                                                              // 3597
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");                           // 3598
            }                                                                                                          // 3599
            return buffer;                                                                                             // 3600
        };                                                                                                             // 3601
                                                                                                                       // 3602
        /**                                                                                                            // 3603
         * Calculates the length of this field's value on the network level.                                           // 3604
         * @param {*} value Field value                                                                                // 3605
         * @param {!ProtoBuf.Builder.Message} message Runtime message                                                  // 3606
         * @returns {number} Byte length                                                                               // 3607
         * @expose                                                                                                     // 3608
         */                                                                                                            // 3609
        FieldPrototype.calculate = function(value, message) {                                                          // 3610
            value = this.verifyValue(value); // May throw                                                              // 3611
            if (this.type === null || typeof this.type !== 'object')                                                   // 3612
                throw Error("[INTERNAL] Unresolved type in "+this.toString(true)+": "+this.type);                      // 3613
            if (value === null || (this.repeated && value.length == 0))                                                // 3614
                return 0; // Optional omitted                                                                          // 3615
            var n = 0;                                                                                                 // 3616
            try {                                                                                                      // 3617
                if (this.repeated) {                                                                                   // 3618
                    var i, ni;                                                                                         // 3619
                    if (this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {     // 3620
                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);                // 3621
                        ni = 0;                                                                                        // 3622
                        for (i=0; i<value.length; i++)                                                                 // 3623
                            ni += this.element.calculateLength(this.id, value[i]);                                     // 3624
                        n += ByteBuffer.calculateVarint32(ni);                                                         // 3625
                        n += ni;                                                                                       // 3626
                    } else {                                                                                           // 3627
                        for (i=0; i<value.length; i++)                                                                 // 3628
                            n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType),                    // 3629
                            n += this.element.calculateLength(this.id, value[i]);                                      // 3630
                    }                                                                                                  // 3631
                } else if (this.map) {                                                                                 // 3632
                    // Each map entry becomes a submessage.                                                            // 3633
                    value.forEach(function(val, key, m) {                                                              // 3634
                        // Compute the length of the submessage (key, val) pair.                                       // 3635
                        var length =                                                                                   // 3636
                            ByteBuffer.calculateVarint32((1 << 3) | this.keyType.wireType) +                           // 3637
                            this.keyElement.calculateLength(1, key) +                                                  // 3638
                            ByteBuffer.calculateVarint32((2 << 3) | this.type.wireType) +                              // 3639
                            this.element.calculateLength(2, val);                                                      // 3640
                                                                                                                       // 3641
                        n += ByteBuffer.calculateVarint32((this.id << 3) | ProtoBuf.WIRE_TYPES.LDELIM);                // 3642
                        n += ByteBuffer.calculateVarint32(length);                                                     // 3643
                        n += length;                                                                                   // 3644
                    }, this);                                                                                          // 3645
                } else {                                                                                               // 3646
                    if (this.hasWirePresence(value, message)) {                                                        // 3647
                        n += ByteBuffer.calculateVarint32((this.id << 3) | this.type.wireType);                        // 3648
                        n += this.element.calculateLength(this.id, value);                                             // 3649
                    }                                                                                                  // 3650
                }                                                                                                      // 3651
            } catch (e) {                                                                                              // 3652
                throw Error("Illegal value for "+this.toString(true)+": "+value+" ("+e+")");                           // 3653
            }                                                                                                          // 3654
            return n;                                                                                                  // 3655
        };                                                                                                             // 3656
                                                                                                                       // 3657
        /**                                                                                                            // 3658
         * Decode the field value from the specified buffer.                                                           // 3659
         * @param {number} wireType Leading wire type                                                                  // 3660
         * @param {ByteBuffer} buffer ByteBuffer to decode from                                                        // 3661
         * @param {boolean=} skipRepeated Whether to skip the repeated check or not. Defaults to false.                // 3662
         * @return {*} Decoded value: array for packed repeated fields, [key, value] for                               // 3663
         *             map fields, or an individual value otherwise.                                                   // 3664
         * @throws {Error} If the field cannot be decoded                                                              // 3665
         * @expose                                                                                                     // 3666
         */                                                                                                            // 3667
        FieldPrototype.decode = function(wireType, buffer, skipRepeated) {                                             // 3668
            var value, nBytes;                                                                                         // 3669
                                                                                                                       // 3670
            // We expect wireType to match the underlying type's wireType unless we see                                // 3671
            // a packed repeated field, or unless this is a map field.                                                 // 3672
            var wireTypeOK =                                                                                           // 3673
                (!this.map && wireType == this.type.wireType) ||                                                       // 3674
                (!skipRepeated && this.repeated && this.options["packed"] &&                                           // 3675
                 wireType == ProtoBuf.WIRE_TYPES.LDELIM) ||                                                            // 3676
                (this.map && wireType == ProtoBuf.WIRE_TYPES.LDELIM);                                                  // 3677
            if (!wireTypeOK)                                                                                           // 3678
                throw Error("Illegal wire type for field "+this.toString(true)+": "+wireType+" ("+this.type.wireType+" expected)");
                                                                                                                       // 3680
            // Handle packed repeated fields.                                                                          // 3681
            if (wireType == ProtoBuf.WIRE_TYPES.LDELIM && this.repeated && this.options["packed"] && ProtoBuf.PACKABLE_WIRE_TYPES.indexOf(this.type.wireType) >= 0) {
                if (!skipRepeated) {                                                                                   // 3683
                    nBytes = buffer.readVarint32();                                                                    // 3684
                    nBytes = buffer.offset + nBytes; // Limit                                                          // 3685
                    var values = [];                                                                                   // 3686
                    while (buffer.offset < nBytes)                                                                     // 3687
                        values.push(this.decode(this.type.wireType, buffer, true));                                    // 3688
                    return values;                                                                                     // 3689
                }                                                                                                      // 3690
                // Read the next value otherwise...                                                                    // 3691
            }                                                                                                          // 3692
                                                                                                                       // 3693
            // Handle maps.                                                                                            // 3694
            if (this.map) {                                                                                            // 3695
                // Read one (key, value) submessage, and return [key, value]                                           // 3696
                var key = Element.defaultFieldValue(this.keyType);                                                     // 3697
                value = Element.defaultFieldValue(this.type);                                                          // 3698
                                                                                                                       // 3699
                // Read the length                                                                                     // 3700
                nBytes = buffer.readVarint32();                                                                        // 3701
                if (buffer.remaining() < nBytes)                                                                       // 3702
                    throw Error("Illegal number of bytes for "+this.toString(true)+": "+nBytes+" required but got only "+buffer.remaining());
                                                                                                                       // 3704
                // Get a sub-buffer of this key/value submessage                                                       // 3705
                var msgbuf = buffer.clone();                                                                           // 3706
                msgbuf.limit = msgbuf.offset + nBytes;                                                                 // 3707
                buffer.offset += nBytes;                                                                               // 3708
                                                                                                                       // 3709
                while (msgbuf.remaining() > 0) {                                                                       // 3710
                    var tag = msgbuf.readVarint32();                                                                   // 3711
                    wireType = tag & 0x07;                                                                             // 3712
                    var id = tag >>> 3;                                                                                // 3713
                    if (id === 1) {                                                                                    // 3714
                        key = this.keyElement.decode(msgbuf, wireType, id);                                            // 3715
                    } else if (id === 2) {                                                                             // 3716
                        value = this.element.decode(msgbuf, wireType, id);                                             // 3717
                    } else {                                                                                           // 3718
                        throw Error("Unexpected tag in map field key/value submessage");                               // 3719
                    }                                                                                                  // 3720
                }                                                                                                      // 3721
                                                                                                                       // 3722
                return [key, value];                                                                                   // 3723
            }                                                                                                          // 3724
                                                                                                                       // 3725
            // Handle singular and non-packed repeated field values.                                                   // 3726
            return this.element.decode(buffer, wireType, this.id);                                                     // 3727
        };                                                                                                             // 3728
                                                                                                                       // 3729
        /**                                                                                                            // 3730
         * @alias ProtoBuf.Reflect.Message.Field                                                                       // 3731
         * @expose                                                                                                     // 3732
         */                                                                                                            // 3733
        Reflect.Message.Field = Field;                                                                                 // 3734
                                                                                                                       // 3735
        /**                                                                                                            // 3736
         * Constructs a new Message ExtensionField.                                                                    // 3737
         * @exports ProtoBuf.Reflect.Message.ExtensionField                                                            // 3738
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3739
         * @param {!ProtoBuf.Reflect.Message} message Message reference                                                // 3740
         * @param {string} rule Rule, one of requried, optional, repeated                                              // 3741
         * @param {string} type Data type, e.g. int32                                                                  // 3742
         * @param {string} name Field name                                                                             // 3743
         * @param {number} id Unique field id                                                                          // 3744
         * @param {!Object.<string,*>=} options Options                                                                // 3745
         * @constructor                                                                                                // 3746
         * @extends ProtoBuf.Reflect.Message.Field                                                                     // 3747
         */                                                                                                            // 3748
        var ExtensionField = function(builder, message, rule, type, name, id, options) {                               // 3749
            Field.call(this, builder, message, rule, /* keytype = */ null, type, name, id, options);                   // 3750
                                                                                                                       // 3751
            /**                                                                                                        // 3752
             * Extension reference.                                                                                    // 3753
             * @type {!ProtoBuf.Reflect.Extension}                                                                     // 3754
             * @expose                                                                                                 // 3755
             */                                                                                                        // 3756
            this.extension;                                                                                            // 3757
        };                                                                                                             // 3758
                                                                                                                       // 3759
        // Extends Field                                                                                               // 3760
        ExtensionField.prototype = Object.create(Field.prototype);                                                     // 3761
                                                                                                                       // 3762
        /**                                                                                                            // 3763
         * @alias ProtoBuf.Reflect.Message.ExtensionField                                                              // 3764
         * @expose                                                                                                     // 3765
         */                                                                                                            // 3766
        Reflect.Message.ExtensionField = ExtensionField;                                                               // 3767
                                                                                                                       // 3768
        /**                                                                                                            // 3769
         * Constructs a new Message OneOf.                                                                             // 3770
         * @exports ProtoBuf.Reflect.Message.OneOf                                                                     // 3771
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3772
         * @param {!ProtoBuf.Reflect.Message} message Message reference                                                // 3773
         * @param {string} name OneOf name                                                                             // 3774
         * @constructor                                                                                                // 3775
         * @extends ProtoBuf.Reflect.T                                                                                 // 3776
         */                                                                                                            // 3777
        var OneOf = function(builder, message, name) {                                                                 // 3778
            T.call(this, builder, message, name);                                                                      // 3779
                                                                                                                       // 3780
            /**                                                                                                        // 3781
             * Enclosed fields.                                                                                        // 3782
             * @type {!Array.<!ProtoBuf.Reflect.Message.Field>}                                                        // 3783
             * @expose                                                                                                 // 3784
             */                                                                                                        // 3785
            this.fields = [];                                                                                          // 3786
        };                                                                                                             // 3787
                                                                                                                       // 3788
        /**                                                                                                            // 3789
         * @alias ProtoBuf.Reflect.Message.OneOf                                                                       // 3790
         * @expose                                                                                                     // 3791
         */                                                                                                            // 3792
        Reflect.Message.OneOf = OneOf;                                                                                 // 3793
                                                                                                                       // 3794
        /**                                                                                                            // 3795
         * Constructs a new Enum.                                                                                      // 3796
         * @exports ProtoBuf.Reflect.Enum                                                                              // 3797
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3798
         * @param {!ProtoBuf.Reflect.T} parent Parent Reflect object                                                   // 3799
         * @param {string} name Enum name                                                                              // 3800
         * @param {Object.<string,*>=} options Enum options                                                            // 3801
         * @param {string?} syntax The syntax level (e.g., proto3)                                                     // 3802
         * @constructor                                                                                                // 3803
         * @extends ProtoBuf.Reflect.Namespace                                                                         // 3804
         */                                                                                                            // 3805
        var Enum = function(builder, parent, name, options, syntax) {                                                  // 3806
            Namespace.call(this, builder, parent, name, options, syntax);                                              // 3807
                                                                                                                       // 3808
            /**                                                                                                        // 3809
             * @override                                                                                               // 3810
             */                                                                                                        // 3811
            this.className = "Enum";                                                                                   // 3812
                                                                                                                       // 3813
            /**                                                                                                        // 3814
             * Runtime enum object.                                                                                    // 3815
             * @type {Object.<string,number>|null}                                                                     // 3816
             * @expose                                                                                                 // 3817
             */                                                                                                        // 3818
            this.object = null;                                                                                        // 3819
        };                                                                                                             // 3820
                                                                                                                       // 3821
        /**                                                                                                            // 3822
         * Gets the string name of an enum value.                                                                      // 3823
         * @param {!ProtoBuf.Builder.Enum} enm Runtime enum                                                            // 3824
         * @param {number} value Enum value                                                                            // 3825
         * @returns {?string} Name or `null` if not present                                                            // 3826
         * @expose                                                                                                     // 3827
         */                                                                                                            // 3828
        Enum.getName = function(enm, value) {                                                                          // 3829
            var keys = Object.keys(enm);                                                                               // 3830
            for (var i=0, key; i<keys.length; ++i)                                                                     // 3831
                if (enm[key = keys[i]] === value)                                                                      // 3832
                    return key;                                                                                        // 3833
            return null;                                                                                               // 3834
        };                                                                                                             // 3835
                                                                                                                       // 3836
        /**                                                                                                            // 3837
         * @alias ProtoBuf.Reflect.Enum.prototype                                                                      // 3838
         * @inner                                                                                                      // 3839
         */                                                                                                            // 3840
        var EnumPrototype = Enum.prototype = Object.create(Namespace.prototype);                                       // 3841
                                                                                                                       // 3842
        /**                                                                                                            // 3843
         * Builds this enum and returns the runtime counterpart.                                                       // 3844
         * @param {boolean} rebuild Whether to rebuild or not, defaults to false                                       // 3845
         * @returns {!Object.<string,number>}                                                                          // 3846
         * @expose                                                                                                     // 3847
         */                                                                                                            // 3848
        EnumPrototype.build = function(rebuild) {                                                                      // 3849
            if (this.object && !rebuild)                                                                               // 3850
                return this.object;                                                                                    // 3851
            var enm = new ProtoBuf.Builder.Enum(),                                                                     // 3852
                values = this.getChildren(Enum.Value);                                                                 // 3853
            for (var i=0, k=values.length; i<k; ++i)                                                                   // 3854
                enm[values[i]['name']] = values[i]['id'];                                                              // 3855
            if (Object.defineProperty)                                                                                 // 3856
                Object.defineProperty(enm, '$options', {                                                               // 3857
                    "value": this.buildOpt(),                                                                          // 3858
                    "enumerable": false                                                                                // 3859
                });                                                                                                    // 3860
            return this.object = enm;                                                                                  // 3861
        };                                                                                                             // 3862
                                                                                                                       // 3863
        /**                                                                                                            // 3864
         * @alias ProtoBuf.Reflect.Enum                                                                                // 3865
         * @expose                                                                                                     // 3866
         */                                                                                                            // 3867
        Reflect.Enum = Enum;                                                                                           // 3868
                                                                                                                       // 3869
        /**                                                                                                            // 3870
         * Constructs a new Enum Value.                                                                                // 3871
         * @exports ProtoBuf.Reflect.Enum.Value                                                                        // 3872
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3873
         * @param {!ProtoBuf.Reflect.Enum} enm Enum reference                                                          // 3874
         * @param {string} name Field name                                                                             // 3875
         * @param {number} id Unique field id                                                                          // 3876
         * @constructor                                                                                                // 3877
         * @extends ProtoBuf.Reflect.T                                                                                 // 3878
         */                                                                                                            // 3879
        var Value = function(builder, enm, name, id) {                                                                 // 3880
            T.call(this, builder, enm, name);                                                                          // 3881
                                                                                                                       // 3882
            /**                                                                                                        // 3883
             * @override                                                                                               // 3884
             */                                                                                                        // 3885
            this.className = "Enum.Value";                                                                             // 3886
                                                                                                                       // 3887
            /**                                                                                                        // 3888
             * Unique enum value id.                                                                                   // 3889
             * @type {number}                                                                                          // 3890
             * @expose                                                                                                 // 3891
             */                                                                                                        // 3892
            this.id = id;                                                                                              // 3893
        };                                                                                                             // 3894
                                                                                                                       // 3895
        // Extends T                                                                                                   // 3896
        Value.prototype = Object.create(T.prototype);                                                                  // 3897
                                                                                                                       // 3898
        /**                                                                                                            // 3899
         * @alias ProtoBuf.Reflect.Enum.Value                                                                          // 3900
         * @expose                                                                                                     // 3901
         */                                                                                                            // 3902
        Reflect.Enum.Value = Value;                                                                                    // 3903
                                                                                                                       // 3904
        /**                                                                                                            // 3905
         * An extension (field).                                                                                       // 3906
         * @exports ProtoBuf.Reflect.Extension                                                                         // 3907
         * @constructor                                                                                                // 3908
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3909
         * @param {!ProtoBuf.Reflect.T} parent Parent object                                                           // 3910
         * @param {string} name Object name                                                                            // 3911
         * @param {!ProtoBuf.Reflect.Message.Field} field Extension field                                              // 3912
         */                                                                                                            // 3913
        var Extension = function(builder, parent, name, field) {                                                       // 3914
            T.call(this, builder, parent, name);                                                                       // 3915
                                                                                                                       // 3916
            /**                                                                                                        // 3917
             * Extended message field.                                                                                 // 3918
             * @type {!ProtoBuf.Reflect.Message.Field}                                                                 // 3919
             * @expose                                                                                                 // 3920
             */                                                                                                        // 3921
            this.field = field;                                                                                        // 3922
        };                                                                                                             // 3923
                                                                                                                       // 3924
        // Extends T                                                                                                   // 3925
        Extension.prototype = Object.create(T.prototype);                                                              // 3926
                                                                                                                       // 3927
        /**                                                                                                            // 3928
         * @alias ProtoBuf.Reflect.Extension                                                                           // 3929
         * @expose                                                                                                     // 3930
         */                                                                                                            // 3931
        Reflect.Extension = Extension;                                                                                 // 3932
                                                                                                                       // 3933
        /**                                                                                                            // 3934
         * Constructs a new Service.                                                                                   // 3935
         * @exports ProtoBuf.Reflect.Service                                                                           // 3936
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 3937
         * @param {!ProtoBuf.Reflect.Namespace} root Root                                                              // 3938
         * @param {string} name Service name                                                                           // 3939
         * @param {Object.<string,*>=} options Options                                                                 // 3940
         * @constructor                                                                                                // 3941
         * @extends ProtoBuf.Reflect.Namespace                                                                         // 3942
         */                                                                                                            // 3943
        var Service = function(builder, root, name, options) {                                                         // 3944
            Namespace.call(this, builder, root, name, options);                                                        // 3945
                                                                                                                       // 3946
            /**                                                                                                        // 3947
             * @override                                                                                               // 3948
             */                                                                                                        // 3949
            this.className = "Service";                                                                                // 3950
                                                                                                                       // 3951
            /**                                                                                                        // 3952
             * Built runtime service class.                                                                            // 3953
             * @type {?function(new:ProtoBuf.Builder.Service)}                                                         // 3954
             */                                                                                                        // 3955
            this.clazz = null;                                                                                         // 3956
        };                                                                                                             // 3957
                                                                                                                       // 3958
        /**                                                                                                            // 3959
         * @alias ProtoBuf.Reflect.Service.prototype                                                                   // 3960
         * @inner                                                                                                      // 3961
         */                                                                                                            // 3962
        var ServicePrototype = Service.prototype = Object.create(Namespace.prototype);                                 // 3963
                                                                                                                       // 3964
        /**                                                                                                            // 3965
         * Builds the service and returns the runtime counterpart, which is a fully functional class.                  // 3966
         * @see ProtoBuf.Builder.Service                                                                               // 3967
         * @param {boolean=} rebuild Whether to rebuild or not                                                         // 3968
         * @return {Function} Service class                                                                            // 3969
         * @throws {Error} If the message cannot be built                                                              // 3970
         * @expose                                                                                                     // 3971
         */                                                                                                            // 3972
        ServicePrototype.build = function(rebuild) {                                                                   // 3973
            if (this.clazz && !rebuild)                                                                                // 3974
                return this.clazz;                                                                                     // 3975
                                                                                                                       // 3976
            // Create the runtime Service class in its own scope                                                       // 3977
            return this.clazz = (function(ProtoBuf, T) {                                                               // 3978
                                                                                                                       // 3979
                /**                                                                                                    // 3980
                 * Constructs a new runtime Service.                                                                   // 3981
                 * @name ProtoBuf.Builder.Service                                                                      // 3982
                 * @param {function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))=} rpcImpl RPC implementation receiving the method name and the message
                 * @class Barebone of all runtime services.                                                            // 3984
                 * @constructor                                                                                        // 3985
                 * @throws {Error} If the service cannot be created                                                    // 3986
                 */                                                                                                    // 3987
                var Service = function(rpcImpl) {                                                                      // 3988
                    ProtoBuf.Builder.Service.call(this);                                                               // 3989
                                                                                                                       // 3990
                    /**                                                                                                // 3991
                     * Service implementation.                                                                         // 3992
                     * @name ProtoBuf.Builder.Service#rpcImpl                                                          // 3993
                     * @type {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))}
                     * @expose                                                                                         // 3995
                     */                                                                                                // 3996
                    this.rpcImpl = rpcImpl || function(name, msg, callback) {                                          // 3997
                        // This is what a user has to implement: A function receiving the method name, the actual message to
                        // send (type checked) and the callback that's either provided with the error as its first     // 3999
                        // argument or null and the actual response message.                                           // 4000
                        setTimeout(callback.bind(this, Error("Not implemented, see: https://github.com/dcodeIO/ProtoBuf.js/wiki/Services")), 0); // Must be async!
                    };                                                                                                 // 4002
                };                                                                                                     // 4003
                                                                                                                       // 4004
                /**                                                                                                    // 4005
                 * @alias ProtoBuf.Builder.Service.prototype                                                           // 4006
                 * @inner                                                                                              // 4007
                 */                                                                                                    // 4008
                var ServicePrototype = Service.prototype = Object.create(ProtoBuf.Builder.Service.prototype);          // 4009
                                                                                                                       // 4010
                /**                                                                                                    // 4011
                 * Asynchronously performs an RPC call using the given RPC implementation.                             // 4012
                 * @name ProtoBuf.Builder.Service.[Method]                                                             // 4013
                 * @function                                                                                           // 4014
                 * @param {!function(string, ProtoBuf.Builder.Message, function(Error, ProtoBuf.Builder.Message=))} rpcImpl RPC implementation
                 * @param {ProtoBuf.Builder.Message} req Request                                                       // 4016
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes               // 4018
                 * @abstract                                                                                           // 4019
                 */                                                                                                    // 4020
                                                                                                                       // 4021
                /**                                                                                                    // 4022
                 * Asynchronously performs an RPC call using the instance's RPC implementation.                        // 4023
                 * @name ProtoBuf.Builder.Service#[Method]                                                             // 4024
                 * @function                                                                                           // 4025
                 * @param {ProtoBuf.Builder.Message} req Request                                                       // 4026
                 * @param {function(Error, (ProtoBuf.Builder.Message|ByteBuffer|Buffer|string)=)} callback Callback receiving
                 *  the error if any and the response either as a pre-parsed message or as its raw bytes               // 4028
                 * @abstract                                                                                           // 4029
                 */                                                                                                    // 4030
                                                                                                                       // 4031
                var rpc = T.getChildren(ProtoBuf.Reflect.Service.RPCMethod);                                           // 4032
                for (var i=0; i<rpc.length; i++) {                                                                     // 4033
                    (function(method) {                                                                                // 4034
                                                                                                                       // 4035
                        // service#Method(message, callback)                                                           // 4036
                        ServicePrototype[method.name] = function(req, callback) {                                      // 4037
                            try {                                                                                      // 4038
                                try {                                                                                  // 4039
                                    // If given as a buffer, decode the request. Will throw a TypeError if not a valid buffer.
                                    req = method.resolvedRequestType.clazz.decode(ByteBuffer.wrap(req));               // 4041
                                } catch (err) {                                                                        // 4042
                                    if (!(err instanceof TypeError))                                                   // 4043
                                        throw err;                                                                     // 4044
                                }                                                                                      // 4045
                                if (req === null || typeof req !== 'object')                                           // 4046
                                    throw Error("Illegal arguments");                                                  // 4047
                                if (!(req instanceof method.resolvedRequestType.clazz))                                // 4048
                                    req = new method.resolvedRequestType.clazz(req);                                   // 4049
                                this.rpcImpl(method.fqn(), req, function(err, res) { // Assumes that this is properly async
                                    if (err) {                                                                         // 4051
                                        callback(err);                                                                 // 4052
                                        return;                                                                        // 4053
                                    }                                                                                  // 4054
                                    // Coalesce to empty string when service response has empty content                // 4055
                                    if (res === null)                                                                  // 4056
                                        res = ''                                                                       // 4057
                                    try { res = method.resolvedResponseType.clazz.decode(res); } catch (notABuffer) {}
                                    if (!res || !(res instanceof method.resolvedResponseType.clazz)) {                 // 4059
                                        callback(Error("Illegal response type received in service method "+ T.name+"#"+method.name));
                                        return;                                                                        // 4061
                                    }                                                                                  // 4062
                                    callback(null, res);                                                               // 4063
                                });                                                                                    // 4064
                            } catch (err) {                                                                            // 4065
                                setTimeout(callback.bind(this, err), 0);                                               // 4066
                            }                                                                                          // 4067
                        };                                                                                             // 4068
                                                                                                                       // 4069
                        // Service.Method(rpcImpl, message, callback)                                                  // 4070
                        Service[method.name] = function(rpcImpl, req, callback) {                                      // 4071
                            new Service(rpcImpl)[method.name](req, callback);                                          // 4072
                        };                                                                                             // 4073
                                                                                                                       // 4074
                        if (Object.defineProperty)                                                                     // 4075
                            Object.defineProperty(Service[method.name], "$options", { "value": method.buildOpt() }),   // 4076
                            Object.defineProperty(ServicePrototype[method.name], "$options", { "value": Service[method.name]["$options"] });
                    })(rpc[i]);                                                                                        // 4078
                }                                                                                                      // 4079
                                                                                                                       // 4080
                // Properties                                                                                          // 4081
                                                                                                                       // 4082
                /**                                                                                                    // 4083
                 * Service options.                                                                                    // 4084
                 * @name ProtoBuf.Builder.Service.$options                                                             // 4085
                 * @type {Object.<string,*>}                                                                           // 4086
                 * @expose                                                                                             // 4087
                 */                                                                                                    // 4088
                var $optionsS; // cc needs this                                                                        // 4089
                                                                                                                       // 4090
                /**                                                                                                    // 4091
                 * Service options.                                                                                    // 4092
                 * @name ProtoBuf.Builder.Service#$options                                                             // 4093
                 * @type {Object.<string,*>}                                                                           // 4094
                 * @expose                                                                                             // 4095
                 */                                                                                                    // 4096
                var $options;                                                                                          // 4097
                                                                                                                       // 4098
                /**                                                                                                    // 4099
                 * Reflection type.                                                                                    // 4100
                 * @name ProtoBuf.Builder.Service.$type                                                                // 4101
                 * @type {!ProtoBuf.Reflect.Service}                                                                   // 4102
                 * @expose                                                                                             // 4103
                 */                                                                                                    // 4104
                var $typeS;                                                                                            // 4105
                                                                                                                       // 4106
                /**                                                                                                    // 4107
                 * Reflection type.                                                                                    // 4108
                 * @name ProtoBuf.Builder.Service#$type                                                                // 4109
                 * @type {!ProtoBuf.Reflect.Service}                                                                   // 4110
                 * @expose                                                                                             // 4111
                 */                                                                                                    // 4112
                var $type;                                                                                             // 4113
                                                                                                                       // 4114
                if (Object.defineProperty)                                                                             // 4115
                    Object.defineProperty(Service, "$options", { "value": T.buildOpt() }),                             // 4116
                    Object.defineProperty(ServicePrototype, "$options", { "value": Service["$options"] }),             // 4117
                    Object.defineProperty(Service, "$type", { "value": T }),                                           // 4118
                    Object.defineProperty(ServicePrototype, "$type", { "value": T });                                  // 4119
                                                                                                                       // 4120
                return Service;                                                                                        // 4121
                                                                                                                       // 4122
            })(ProtoBuf, this);                                                                                        // 4123
        };                                                                                                             // 4124
                                                                                                                       // 4125
        /**                                                                                                            // 4126
         * @alias ProtoBuf.Reflect.Service                                                                             // 4127
         * @expose                                                                                                     // 4128
         */                                                                                                            // 4129
        Reflect.Service = Service;                                                                                     // 4130
                                                                                                                       // 4131
        /**                                                                                                            // 4132
         * Abstract service method.                                                                                    // 4133
         * @exports ProtoBuf.Reflect.Service.Method                                                                    // 4134
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 4135
         * @param {!ProtoBuf.Reflect.Service} svc Service                                                              // 4136
         * @param {string} name Method name                                                                            // 4137
         * @param {Object.<string,*>=} options Options                                                                 // 4138
         * @constructor                                                                                                // 4139
         * @extends ProtoBuf.Reflect.T                                                                                 // 4140
         */                                                                                                            // 4141
        var Method = function(builder, svc, name, options) {                                                           // 4142
            T.call(this, builder, svc, name);                                                                          // 4143
                                                                                                                       // 4144
            /**                                                                                                        // 4145
             * @override                                                                                               // 4146
             */                                                                                                        // 4147
            this.className = "Service.Method";                                                                         // 4148
                                                                                                                       // 4149
            /**                                                                                                        // 4150
             * Options.                                                                                                // 4151
             * @type {Object.<string, *>}                                                                              // 4152
             * @expose                                                                                                 // 4153
             */                                                                                                        // 4154
            this.options = options || {};                                                                              // 4155
        };                                                                                                             // 4156
                                                                                                                       // 4157
        /**                                                                                                            // 4158
         * @alias ProtoBuf.Reflect.Service.Method.prototype                                                            // 4159
         * @inner                                                                                                      // 4160
         */                                                                                                            // 4161
        var MethodPrototype = Method.prototype = Object.create(T.prototype);                                           // 4162
                                                                                                                       // 4163
        /**                                                                                                            // 4164
         * Builds the method's '$options' property.                                                                    // 4165
         * @name ProtoBuf.Reflect.Service.Method#buildOpt                                                              // 4166
         * @function                                                                                                   // 4167
         * @return {Object.<string,*>}                                                                                 // 4168
         */                                                                                                            // 4169
        MethodPrototype.buildOpt = NamespacePrototype.buildOpt;                                                        // 4170
                                                                                                                       // 4171
        /**                                                                                                            // 4172
         * @alias ProtoBuf.Reflect.Service.Method                                                                      // 4173
         * @expose                                                                                                     // 4174
         */                                                                                                            // 4175
        Reflect.Service.Method = Method;                                                                               // 4176
                                                                                                                       // 4177
        /**                                                                                                            // 4178
         * RPC service method.                                                                                         // 4179
         * @exports ProtoBuf.Reflect.Service.RPCMethod                                                                 // 4180
         * @param {!ProtoBuf.Builder} builder Builder reference                                                        // 4181
         * @param {!ProtoBuf.Reflect.Service} svc Service                                                              // 4182
         * @param {string} name Method name                                                                            // 4183
         * @param {string} request Request message name                                                                // 4184
         * @param {string} response Response message name                                                              // 4185
         * @param {boolean} request_stream Whether requests are streamed                                               // 4186
         * @param {boolean} response_stream Whether responses are streamed                                             // 4187
         * @param {Object.<string,*>=} options Options                                                                 // 4188
         * @constructor                                                                                                // 4189
         * @extends ProtoBuf.Reflect.Service.Method                                                                    // 4190
         */                                                                                                            // 4191
        var RPCMethod = function(builder, svc, name, request, response, request_stream, response_stream, options) {    // 4192
            Method.call(this, builder, svc, name, options);                                                            // 4193
                                                                                                                       // 4194
            /**                                                                                                        // 4195
             * @override                                                                                               // 4196
             */                                                                                                        // 4197
            this.className = "Service.RPCMethod";                                                                      // 4198
                                                                                                                       // 4199
            /**                                                                                                        // 4200
             * Request message name.                                                                                   // 4201
             * @type {string}                                                                                          // 4202
             * @expose                                                                                                 // 4203
             */                                                                                                        // 4204
            this.requestName = request;                                                                                // 4205
                                                                                                                       // 4206
            /**                                                                                                        // 4207
             * Response message name.                                                                                  // 4208
             * @type {string}                                                                                          // 4209
             * @expose                                                                                                 // 4210
             */                                                                                                        // 4211
            this.responseName = response;                                                                              // 4212
                                                                                                                       // 4213
            /**                                                                                                        // 4214
             * Whether requests are streamed                                                                           // 4215
             * @type {bool}                                                                                            // 4216
             * @expose                                                                                                 // 4217
             */                                                                                                        // 4218
            this.requestStream = request_stream;                                                                       // 4219
                                                                                                                       // 4220
            /**                                                                                                        // 4221
             * Whether responses are streamed                                                                          // 4222
             * @type {bool}                                                                                            // 4223
             * @expose                                                                                                 // 4224
             */                                                                                                        // 4225
            this.responseStream = response_stream;                                                                     // 4226
                                                                                                                       // 4227
            /**                                                                                                        // 4228
             * Resolved request message type.                                                                          // 4229
             * @type {ProtoBuf.Reflect.Message}                                                                        // 4230
             * @expose                                                                                                 // 4231
             */                                                                                                        // 4232
            this.resolvedRequestType = null;                                                                           // 4233
                                                                                                                       // 4234
            /**                                                                                                        // 4235
             * Resolved response message type.                                                                         // 4236
             * @type {ProtoBuf.Reflect.Message}                                                                        // 4237
             * @expose                                                                                                 // 4238
             */                                                                                                        // 4239
            this.resolvedResponseType = null;                                                                          // 4240
        };                                                                                                             // 4241
                                                                                                                       // 4242
        // Extends Method                                                                                              // 4243
        RPCMethod.prototype = Object.create(Method.prototype);                                                         // 4244
                                                                                                                       // 4245
        /**                                                                                                            // 4246
         * @alias ProtoBuf.Reflect.Service.RPCMethod                                                                   // 4247
         * @expose                                                                                                     // 4248
         */                                                                                                            // 4249
        Reflect.Service.RPCMethod = RPCMethod;                                                                         // 4250
                                                                                                                       // 4251
        return Reflect;                                                                                                // 4252
                                                                                                                       // 4253
    })(ProtoBuf);                                                                                                      // 4254
                                                                                                                       // 4255
    /**                                                                                                                // 4256
     * @alias ProtoBuf.Builder                                                                                         // 4257
     * @expose                                                                                                         // 4258
     */                                                                                                                // 4259
    ProtoBuf.Builder = (function(ProtoBuf, Lang, Reflect) {                                                            // 4260
        "use strict";                                                                                                  // 4261
                                                                                                                       // 4262
        /**                                                                                                            // 4263
         * Constructs a new Builder.                                                                                   // 4264
         * @exports ProtoBuf.Builder                                                                                   // 4265
         * @class Provides the functionality to build protocol messages.                                               // 4266
         * @param {Object.<string,*>=} options Options                                                                 // 4267
         * @constructor                                                                                                // 4268
         */                                                                                                            // 4269
        var Builder = function(options) {                                                                              // 4270
                                                                                                                       // 4271
            /**                                                                                                        // 4272
             * Namespace.                                                                                              // 4273
             * @type {ProtoBuf.Reflect.Namespace}                                                                      // 4274
             * @expose                                                                                                 // 4275
             */                                                                                                        // 4276
            this.ns = new Reflect.Namespace(this, null, ""); // Global namespace                                       // 4277
                                                                                                                       // 4278
            /**                                                                                                        // 4279
             * Namespace pointer.                                                                                      // 4280
             * @type {ProtoBuf.Reflect.T}                                                                              // 4281
             * @expose                                                                                                 // 4282
             */                                                                                                        // 4283
            this.ptr = this.ns;                                                                                        // 4284
                                                                                                                       // 4285
            /**                                                                                                        // 4286
             * Resolved flag.                                                                                          // 4287
             * @type {boolean}                                                                                         // 4288
             * @expose                                                                                                 // 4289
             */                                                                                                        // 4290
            this.resolved = false;                                                                                     // 4291
                                                                                                                       // 4292
            /**                                                                                                        // 4293
             * The current building result.                                                                            // 4294
             * @type {Object.<string,ProtoBuf.Builder.Message|Object>|null}                                            // 4295
             * @expose                                                                                                 // 4296
             */                                                                                                        // 4297
            this.result = null;                                                                                        // 4298
                                                                                                                       // 4299
            /**                                                                                                        // 4300
             * Imported files.                                                                                         // 4301
             * @type {Array.<string>}                                                                                  // 4302
             * @expose                                                                                                 // 4303
             */                                                                                                        // 4304
            this.files = {};                                                                                           // 4305
                                                                                                                       // 4306
            /**                                                                                                        // 4307
             * Import root override.                                                                                   // 4308
             * @type {?string}                                                                                         // 4309
             * @expose                                                                                                 // 4310
             */                                                                                                        // 4311
            this.importRoot = null;                                                                                    // 4312
                                                                                                                       // 4313
            /**                                                                                                        // 4314
             * Options.                                                                                                // 4315
             * @type {!Object.<string, *>}                                                                             // 4316
             * @expose                                                                                                 // 4317
             */                                                                                                        // 4318
            this.options = options || {};                                                                              // 4319
        };                                                                                                             // 4320
                                                                                                                       // 4321
        /**                                                                                                            // 4322
         * @alias ProtoBuf.Builder.prototype                                                                           // 4323
         * @inner                                                                                                      // 4324
         */                                                                                                            // 4325
        var BuilderPrototype = Builder.prototype;                                                                      // 4326
                                                                                                                       // 4327
        // ----- Definition tests -----                                                                                // 4328
                                                                                                                       // 4329
        /**                                                                                                            // 4330
         * Tests if a definition most likely describes a message.                                                      // 4331
         * @param {!Object} def                                                                                        // 4332
         * @returns {boolean}                                                                                          // 4333
         * @expose                                                                                                     // 4334
         */                                                                                                            // 4335
        Builder.isMessage = function(def) {                                                                            // 4336
            // Messages require a string name                                                                          // 4337
            if (typeof def["name"] !== 'string')                                                                       // 4338
                return false;                                                                                          // 4339
            // Messages do not contain values (enum) or rpc methods (service)                                          // 4340
            if (typeof def["values"] !== 'undefined' || typeof def["rpc"] !== 'undefined')                             // 4341
                return false;                                                                                          // 4342
            return true;                                                                                               // 4343
        };                                                                                                             // 4344
                                                                                                                       // 4345
        /**                                                                                                            // 4346
         * Tests if a definition most likely describes a message field.                                                // 4347
         * @param {!Object} def                                                                                        // 4348
         * @returns {boolean}                                                                                          // 4349
         * @expose                                                                                                     // 4350
         */                                                                                                            // 4351
        Builder.isMessageField = function(def) {                                                                       // 4352
            // Message fields require a string rule, name and type and an id                                           // 4353
            if (typeof def["rule"] !== 'string' || typeof def["name"] !== 'string' || typeof def["type"] !== 'string' || typeof def["id"] === 'undefined')
                return false;                                                                                          // 4355
            return true;                                                                                               // 4356
        };                                                                                                             // 4357
                                                                                                                       // 4358
        /**                                                                                                            // 4359
         * Tests if a definition most likely describes an enum.                                                        // 4360
         * @param {!Object} def                                                                                        // 4361
         * @returns {boolean}                                                                                          // 4362
         * @expose                                                                                                     // 4363
         */                                                                                                            // 4364
        Builder.isEnum = function(def) {                                                                               // 4365
            // Enums require a string name                                                                             // 4366
            if (typeof def["name"] !== 'string')                                                                       // 4367
                return false;                                                                                          // 4368
            // Enums require at least one value                                                                        // 4369
            if (typeof def["values"] === 'undefined' || !Array.isArray(def["values"]) || def["values"].length === 0)   // 4370
                return false;                                                                                          // 4371
            return true;                                                                                               // 4372
        };                                                                                                             // 4373
                                                                                                                       // 4374
        /**                                                                                                            // 4375
         * Tests if a definition most likely describes a service.                                                      // 4376
         * @param {!Object} def                                                                                        // 4377
         * @returns {boolean}                                                                                          // 4378
         * @expose                                                                                                     // 4379
         */                                                                                                            // 4380
        Builder.isService = function(def) {                                                                            // 4381
            // Services require a string name and an rpc object                                                        // 4382
            if (typeof def["name"] !== 'string' || typeof def["rpc"] !== 'object' || !def["rpc"])                      // 4383
                return false;                                                                                          // 4384
            return true;                                                                                               // 4385
        };                                                                                                             // 4386
                                                                                                                       // 4387
        /**                                                                                                            // 4388
         * Tests if a definition most likely describes an extended message                                             // 4389
         * @param {!Object} def                                                                                        // 4390
         * @returns {boolean}                                                                                          // 4391
         * @expose                                                                                                     // 4392
         */                                                                                                            // 4393
        Builder.isExtend = function(def) {                                                                             // 4394
            // Extends rquire a string ref                                                                             // 4395
            if (typeof def["ref"] !== 'string')                                                                        // 4396
                return false;                                                                                          // 4397
            return true;                                                                                               // 4398
        };                                                                                                             // 4399
                                                                                                                       // 4400
        // ----- Building -----                                                                                        // 4401
                                                                                                                       // 4402
        /**                                                                                                            // 4403
         * Resets the pointer to the root namespace.                                                                   // 4404
         * @returns {!ProtoBuf.Builder} this                                                                           // 4405
         * @expose                                                                                                     // 4406
         */                                                                                                            // 4407
        BuilderPrototype.reset = function() {                                                                          // 4408
            this.ptr = this.ns;                                                                                        // 4409
            return this;                                                                                               // 4410
        };                                                                                                             // 4411
                                                                                                                       // 4412
        /**                                                                                                            // 4413
         * Defines a namespace on top of the current pointer position and places the pointer on it.                    // 4414
         * @param {string} namespace                                                                                   // 4415
         * @return {!ProtoBuf.Builder} this                                                                            // 4416
         * @expose                                                                                                     // 4417
         */                                                                                                            // 4418
        BuilderPrototype.define = function(namespace) {                                                                // 4419
            if (typeof namespace !== 'string' || !Lang.TYPEREF.test(namespace))                                        // 4420
                throw Error("illegal namespace: "+namespace);                                                          // 4421
            namespace.split(".").forEach(function(part) {                                                              // 4422
                var ns = this.ptr.getChild(part);                                                                      // 4423
                if (ns === null) // Keep existing                                                                      // 4424
                    this.ptr.addChild(ns = new Reflect.Namespace(this, this.ptr, part));                               // 4425
                this.ptr = ns;                                                                                         // 4426
            }, this);                                                                                                  // 4427
            return this;                                                                                               // 4428
        };                                                                                                             // 4429
                                                                                                                       // 4430
        /**                                                                                                            // 4431
         * Creates the specified definitions at the current pointer position.                                          // 4432
         * @param {!Array.<!Object>} defs Messages, enums or services to create                                        // 4433
         * @returns {!ProtoBuf.Builder} this                                                                           // 4434
         * @throws {Error} If a message definition is invalid                                                          // 4435
         * @expose                                                                                                     // 4436
         */                                                                                                            // 4437
        BuilderPrototype.create = function(defs) {                                                                     // 4438
            if (!defs)                                                                                                 // 4439
                return this; // Nothing to create                                                                      // 4440
            if (!Array.isArray(defs))                                                                                  // 4441
                defs = [defs];                                                                                         // 4442
            else {                                                                                                     // 4443
                if (defs.length === 0)                                                                                 // 4444
                    return this;                                                                                       // 4445
                defs = defs.slice();                                                                                   // 4446
            }                                                                                                          // 4447
                                                                                                                       // 4448
            // It's quite hard to keep track of scopes and memory here, so let's do this iteratively.                  // 4449
            var stack = [defs];                                                                                        // 4450
            while (stack.length > 0) {                                                                                 // 4451
                defs = stack.pop();                                                                                    // 4452
                                                                                                                       // 4453
                if (!Array.isArray(defs)) // Stack always contains entire namespaces                                   // 4454
                    throw Error("not a valid namespace: "+JSON.stringify(defs));                                       // 4455
                                                                                                                       // 4456
                while (defs.length > 0) {                                                                              // 4457
                    var def = defs.shift(); // Namespaces always contain an array of messages, enums and services      // 4458
                                                                                                                       // 4459
                    if (Builder.isMessage(def)) {                                                                      // 4460
                        var obj = new Reflect.Message(this, this.ptr, def["name"], def["options"], def["isGroup"], def["syntax"]);
                                                                                                                       // 4462
                        // Create OneOfs                                                                               // 4463
                        var oneofs = {};                                                                               // 4464
                        if (def["oneofs"])                                                                             // 4465
                            Object.keys(def["oneofs"]).forEach(function(name) {                                        // 4466
                                obj.addChild(oneofs[name] = new Reflect.Message.OneOf(this, obj, name));               // 4467
                            }, this);                                                                                  // 4468
                                                                                                                       // 4469
                        // Create fields                                                                               // 4470
                        if (def["fields"])                                                                             // 4471
                            def["fields"].forEach(function(fld) {                                                      // 4472
                                if (obj.getChild(fld["id"]|0) !== null)                                                // 4473
                                    throw Error("duplicate or invalid field id in "+obj.name+": "+fld['id']);          // 4474
                                if (fld["options"] && typeof fld["options"] !== 'object')                              // 4475
                                    throw Error("illegal field options in "+obj.name+"#"+fld["name"]);                 // 4476
                                var oneof = null;                                                                      // 4477
                                if (typeof fld["oneof"] === 'string' && !(oneof = oneofs[fld["oneof"]]))               // 4478
                                    throw Error("illegal oneof in "+obj.name+"#"+fld["name"]+": "+fld["oneof"]);       // 4479
                                fld = new Reflect.Message.Field(this, obj, fld["rule"], fld["keytype"], fld["type"], fld["name"], fld["id"], fld["options"], oneof, def["syntax"]);
                                if (oneof)                                                                             // 4481
                                    oneof.fields.push(fld);                                                            // 4482
                                obj.addChild(fld);                                                                     // 4483
                            }, this);                                                                                  // 4484
                                                                                                                       // 4485
                        // Push children to stack                                                                      // 4486
                        var subObj = [];                                                                               // 4487
                        if (def["enums"])                                                                              // 4488
                            def["enums"].forEach(function(enm) {                                                       // 4489
                                subObj.push(enm);                                                                      // 4490
                            });                                                                                        // 4491
                        if (def["messages"])                                                                           // 4492
                            def["messages"].forEach(function(msg) {                                                    // 4493
                                subObj.push(msg);                                                                      // 4494
                            });                                                                                        // 4495
                        if (def["services"])                                                                           // 4496
                            def["services"].forEach(function(svc) {                                                    // 4497
                                subObj.push(svc);                                                                      // 4498
                            });                                                                                        // 4499
                                                                                                                       // 4500
                        // Set extension ranges                                                                        // 4501
                        if (def["extensions"]) {                                                                       // 4502
                            if (typeof def["extensions"][0] === 'number') // pre 5.0.1                                 // 4503
                                obj.extensions = [ def["extensions"] ];                                                // 4504
                            else                                                                                       // 4505
                                obj.extensions = def["extensions"];                                                    // 4506
                        }                                                                                              // 4507
                                                                                                                       // 4508
                        // Create on top of current namespace                                                          // 4509
                        this.ptr.addChild(obj);                                                                        // 4510
                        if (subObj.length > 0) {                                                                       // 4511
                            stack.push(defs); // Push the current level back                                           // 4512
                            defs = subObj; // Continue processing sub level                                            // 4513
                            subObj = null;                                                                             // 4514
                            this.ptr = obj; // And move the pointer to this namespace                                  // 4515
                            obj = null;                                                                                // 4516
                            continue;                                                                                  // 4517
                        }                                                                                              // 4518
                        subObj = null;                                                                                 // 4519
                                                                                                                       // 4520
                    } else if (Builder.isEnum(def)) {                                                                  // 4521
                                                                                                                       // 4522
                        obj = new Reflect.Enum(this, this.ptr, def["name"], def["options"], def["syntax"]);            // 4523
                        def["values"].forEach(function(val) {                                                          // 4524
                            obj.addChild(new Reflect.Enum.Value(this, obj, val["name"], val["id"]));                   // 4525
                        }, this);                                                                                      // 4526
                        this.ptr.addChild(obj);                                                                        // 4527
                                                                                                                       // 4528
                    } else if (Builder.isService(def)) {                                                               // 4529
                                                                                                                       // 4530
                        obj = new Reflect.Service(this, this.ptr, def["name"], def["options"]);                        // 4531
                        Object.keys(def["rpc"]).forEach(function(name) {                                               // 4532
                            var mtd = def["rpc"][name];                                                                // 4533
                            obj.addChild(new Reflect.Service.RPCMethod(this, obj, name, mtd["request"], mtd["response"], !!mtd["request_stream"], !!mtd["response_stream"], mtd["options"]));
                        }, this);                                                                                      // 4535
                        this.ptr.addChild(obj);                                                                        // 4536
                                                                                                                       // 4537
                    } else if (Builder.isExtend(def)) {                                                                // 4538
                                                                                                                       // 4539
                        obj = this.ptr.resolve(def["ref"], true);                                                      // 4540
                        if (obj) {                                                                                     // 4541
                            def["fields"].forEach(function(fld) {                                                      // 4542
                                if (obj.getChild(fld['id']|0) !== null)                                                // 4543
                                    throw Error("duplicate extended field id in "+obj.name+": "+fld['id']);            // 4544
                                // Check if field id is allowed to be extended                                         // 4545
                                if (obj.extensions) {                                                                  // 4546
                                    var valid = false;                                                                 // 4547
                                    obj.extensions.forEach(function(range) {                                           // 4548
                                        if (fld["id"] >= range[0] && fld["id"] <= range[1])                            // 4549
                                            valid = true;                                                              // 4550
                                    });                                                                                // 4551
                                    if (!valid)                                                                        // 4552
                                        throw Error("illegal extended field id in "+obj.name+": "+fld['id']+" (not within valid ranges)");
                                }                                                                                      // 4554
                                // Convert extension field names to camel case notation if the override is set         // 4555
                                var name = fld["name"];                                                                // 4556
                                if (this.options['convertFieldsToCamelCase'])                                          // 4557
                                    name = ProtoBuf.Util.toCamelCase(name);                                            // 4558
                                // see #161: Extensions use their fully qualified name as their runtime key and...     // 4559
                                var field = new Reflect.Message.ExtensionField(this, obj, fld["rule"], fld["type"], this.ptr.fqn()+'.'+name, fld["id"], fld["options"]);
                                // ...are added on top of the current namespace as an extension which is used for      // 4561
                                // resolving their type later on (the extension always keeps the original name to      // 4562
                                // prevent naming collisions)                                                          // 4563
                                var ext = new Reflect.Extension(this, this.ptr, fld["name"], field);                   // 4564
                                field.extension = ext;                                                                 // 4565
                                this.ptr.addChild(ext);                                                                // 4566
                                obj.addChild(field);                                                                   // 4567
                            }, this);                                                                                  // 4568
                                                                                                                       // 4569
                        } else if (!/\.?google\.protobuf\./.test(def["ref"])) // Silently skip internal extensions     // 4570
                            throw Error("extended message "+def["ref"]+" is not defined");                             // 4571
                                                                                                                       // 4572
                    } else                                                                                             // 4573
                        throw Error("not a valid definition: "+JSON.stringify(def));                                   // 4574
                                                                                                                       // 4575
                    def = null;                                                                                        // 4576
                    obj = null;                                                                                        // 4577
                }                                                                                                      // 4578
                // Break goes here                                                                                     // 4579
                defs = null;                                                                                           // 4580
                this.ptr = this.ptr.parent; // Namespace done, continue at parent                                      // 4581
            }                                                                                                          // 4582
            this.resolved = false; // Require re-resolve                                                               // 4583
            this.result = null; // Require re-build                                                                    // 4584
            return this;                                                                                               // 4585
        };                                                                                                             // 4586
                                                                                                                       // 4587
        /**                                                                                                            // 4588
         * Propagates syntax to all children.                                                                          // 4589
         * @param {!Object} parent                                                                                     // 4590
         * @inner                                                                                                      // 4591
         */                                                                                                            // 4592
        function propagateSyntax(parent) {                                                                             // 4593
            if (parent['messages']) {                                                                                  // 4594
                parent['messages'].forEach(function(child) {                                                           // 4595
                    child["syntax"] = parent["syntax"];                                                                // 4596
                    propagateSyntax(child);                                                                            // 4597
                });                                                                                                    // 4598
            }                                                                                                          // 4599
            if (parent['enums']) {                                                                                     // 4600
                parent['enums'].forEach(function(child) {                                                              // 4601
                    child["syntax"] = parent["syntax"];                                                                // 4602
                });                                                                                                    // 4603
            }                                                                                                          // 4604
        }                                                                                                              // 4605
                                                                                                                       // 4606
        /**                                                                                                            // 4607
         * Imports another definition into this builder.                                                               // 4608
         * @param {Object.<string,*>} json Parsed import                                                               // 4609
         * @param {(string|{root: string, file: string})=} filename Imported file name                                 // 4610
         * @returns {!ProtoBuf.Builder} this                                                                           // 4611
         * @throws {Error} If the definition or file cannot be imported                                                // 4612
         * @expose                                                                                                     // 4613
         */                                                                                                            // 4614
        BuilderPrototype["import"] = function(json, filename) {                                                        // 4615
            var delim = '/';                                                                                           // 4616
                                                                                                                       // 4617
            // Make sure to skip duplicate imports                                                                     // 4618
                                                                                                                       // 4619
            if (typeof filename === 'string') {                                                                        // 4620
                                                                                                                       // 4621
                if (ProtoBuf.Util.IS_NODE)                                                                             // 4622
                    filename = require("path")['resolve'](filename);                                                   // 4623
                if (this.files[filename] === true)                                                                     // 4624
                    return this.reset();                                                                               // 4625
                this.files[filename] = true;                                                                           // 4626
                                                                                                                       // 4627
            } else if (typeof filename === 'object') { // Object with root, file.                                      // 4628
                                                                                                                       // 4629
                var root = filename.root;                                                                              // 4630
                if (ProtoBuf.Util.IS_NODE)                                                                             // 4631
                    root = require("path")['resolve'](root);                                                           // 4632
                if (root.indexOf("\\") >= 0 || filename.file.indexOf("\\") >= 0)                                       // 4633
                    delim = '\\';                                                                                      // 4634
                var fname = root + delim + filename.file;                                                              // 4635
                if (this.files[fname] === true)                                                                        // 4636
                    return this.reset();                                                                               // 4637
                this.files[fname] = true;                                                                              // 4638
            }                                                                                                          // 4639
                                                                                                                       // 4640
            // Import imports                                                                                          // 4641
                                                                                                                       // 4642
            if (json['imports'] && json['imports'].length > 0) {                                                       // 4643
                var importRoot,                                                                                        // 4644
                    resetRoot = false;                                                                                 // 4645
                                                                                                                       // 4646
                if (typeof filename === 'object') { // If an import root is specified, override                        // 4647
                                                                                                                       // 4648
                    this.importRoot = filename["root"]; resetRoot = true; // ... and reset afterwards                  // 4649
                    importRoot = this.importRoot;                                                                      // 4650
                    filename = filename["file"];                                                                       // 4651
                    if (importRoot.indexOf("\\") >= 0 || filename.indexOf("\\") >= 0)                                  // 4652
                        delim = '\\';                                                                                  // 4653
                                                                                                                       // 4654
                } else if (typeof filename === 'string') {                                                             // 4655
                                                                                                                       // 4656
                    if (this.importRoot) // If import root is overridden, use it                                       // 4657
                        importRoot = this.importRoot;                                                                  // 4658
                    else { // Otherwise compute from filename                                                          // 4659
                        if (filename.indexOf("/") >= 0) { // Unix                                                      // 4660
                            importRoot = filename.replace(/\/[^\/]*$/, "");                                            // 4661
                            if (/* /file.proto */ importRoot === "")                                                   // 4662
                                importRoot = "/";                                                                      // 4663
                        } else if (filename.indexOf("\\") >= 0) { // Windows                                           // 4664
                            importRoot = filename.replace(/\\[^\\]*$/, "");                                            // 4665
                            delim = '\\';                                                                              // 4666
                        } else                                                                                         // 4667
                            importRoot = ".";                                                                          // 4668
                    }                                                                                                  // 4669
                                                                                                                       // 4670
                } else                                                                                                 // 4671
                    importRoot = null;                                                                                 // 4672
                                                                                                                       // 4673
                for (var i=0; i<json['imports'].length; i++) {                                                         // 4674
                    if (typeof json['imports'][i] === 'string') { // Import file                                       // 4675
                        if (!importRoot)                                                                               // 4676
                            throw Error("cannot determine import root");                                               // 4677
                        var importFilename = json['imports'][i];                                                       // 4678
                        if (importFilename === "google/protobuf/descriptor.proto")                                     // 4679
                            continue; // Not needed and therefore not used                                             // 4680
                        importFilename = importRoot + delim + importFilename;                                          // 4681
                        if (this.files[importFilename] === true)                                                       // 4682
                            continue; // Already imported                                                              // 4683
                        if (/\.proto$/i.test(importFilename) && !ProtoBuf.DotProto)       // If this is a light build  // 4684
                            importFilename = importFilename.replace(/\.proto$/, ".json"); // always load the JSON file
                        var contents = ProtoBuf.Util.fetch(importFilename);                                            // 4686
                        if (contents === null)                                                                         // 4687
                            throw Error("failed to import '"+importFilename+"' in '"+filename+"': file not found");    // 4688
                        if (/\.json$/i.test(importFilename)) // Always possible                                        // 4689
                            this["import"](JSON.parse(contents+""), importFilename); // May throw                      // 4690
                        else                                                                                           // 4691
                            this["import"](ProtoBuf.DotProto.Parser.parse(contents), importFilename); // May throw     // 4692
                    } else // Import structure                                                                         // 4693
                        if (!filename)                                                                                 // 4694
                            this["import"](json['imports'][i]);                                                        // 4695
                        else if (/\.(\w+)$/.test(filename)) // With extension: Append _importN to the name portion to make it unique
                            this["import"](json['imports'][i], filename.replace(/^(.+)\.(\w+)$/, function($0, $1, $2) { return $1+"_import"+i+"."+$2; }));
                        else // Without extension: Append _importN to make it unique                                   // 4698
                            this["import"](json['imports'][i], filename+"_import"+i);                                  // 4699
                }                                                                                                      // 4700
                if (resetRoot) // Reset import root override when all imports are done                                 // 4701
                    this.importRoot = null;                                                                            // 4702
            }                                                                                                          // 4703
                                                                                                                       // 4704
            // Import structures                                                                                       // 4705
                                                                                                                       // 4706
            if (json['package'])                                                                                       // 4707
                this.define(json['package']);                                                                          // 4708
            if (json['syntax'])                                                                                        // 4709
                propagateSyntax(json);                                                                                 // 4710
            var base = this.ptr;                                                                                       // 4711
            if (json['options'])                                                                                       // 4712
                Object.keys(json['options']).forEach(function(key) {                                                   // 4713
                    base.options[key] = json['options'][key];                                                          // 4714
                });                                                                                                    // 4715
            if (json['messages'])                                                                                      // 4716
                this.create(json['messages']),                                                                         // 4717
                this.ptr = base;                                                                                       // 4718
            if (json['enums'])                                                                                         // 4719
                this.create(json['enums']),                                                                            // 4720
                this.ptr = base;                                                                                       // 4721
            if (json['services'])                                                                                      // 4722
                this.create(json['services']),                                                                         // 4723
                this.ptr = base;                                                                                       // 4724
            if (json['extends'])                                                                                       // 4725
                this.create(json['extends']);                                                                          // 4726
                                                                                                                       // 4727
            return this.reset();                                                                                       // 4728
        };                                                                                                             // 4729
                                                                                                                       // 4730
        /**                                                                                                            // 4731
         * Resolves all namespace objects.                                                                             // 4732
         * @throws {Error} If a type cannot be resolved                                                                // 4733
         * @returns {!ProtoBuf.Builder} this                                                                           // 4734
         * @expose                                                                                                     // 4735
         */                                                                                                            // 4736
        BuilderPrototype.resolveAll = function() {                                                                     // 4737
            // Resolve all reflected objects                                                                           // 4738
            var res;                                                                                                   // 4739
            if (this.ptr == null || typeof this.ptr.type === 'object')                                                 // 4740
                return this; // Done (already resolved)                                                                // 4741
                                                                                                                       // 4742
            if (this.ptr instanceof Reflect.Namespace) { // Resolve children                                           // 4743
                                                                                                                       // 4744
                this.ptr.children.forEach(function(child) {                                                            // 4745
                    this.ptr = child;                                                                                  // 4746
                    this.resolveAll();                                                                                 // 4747
                }, this);                                                                                              // 4748
                                                                                                                       // 4749
            } else if (this.ptr instanceof Reflect.Message.Field) { // Resolve type                                    // 4750
                                                                                                                       // 4751
                if (!Lang.TYPE.test(this.ptr.type)) {                                                                  // 4752
                    if (!Lang.TYPEREF.test(this.ptr.type))                                                             // 4753
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);          // 4754
                    res = (this.ptr instanceof Reflect.Message.ExtensionField ? this.ptr.extension.parent : this.ptr.parent).resolve(this.ptr.type, true);
                    if (!res)                                                                                          // 4756
                        throw Error("unresolvable type reference in "+this.ptr.toString(true)+": "+this.ptr.type);     // 4757
                    this.ptr.resolvedType = res;                                                                       // 4758
                    if (res instanceof Reflect.Enum) {                                                                 // 4759
                        this.ptr.type = ProtoBuf.TYPES["enum"];                                                        // 4760
                        if (this.ptr.syntax === 'proto3' && res.syntax !== 'proto3')                                   // 4761
                            throw Error("proto3 message cannot reference proto2 enum");                                // 4762
                    }                                                                                                  // 4763
                    else if (res instanceof Reflect.Message)                                                           // 4764
                        this.ptr.type = res.isGroup ? ProtoBuf.TYPES["group"] : ProtoBuf.TYPES["message"];             // 4765
                    else                                                                                               // 4766
                        throw Error("illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.type);          // 4767
                } else                                                                                                 // 4768
                    this.ptr.type = ProtoBuf.TYPES[this.ptr.type];                                                     // 4769
                                                                                                                       // 4770
                // If it's a map field, also resolve the key type. The key type can be only a numeric, string, or bool type
                // (i.e., no enums or messages), so we don't need to resolve against the current namespace.            // 4772
                if (this.ptr.map) {                                                                                    // 4773
                    if (!Lang.TYPE.test(this.ptr.keyType))                                                             // 4774
                        throw Error("illegal key type for map field in "+this.ptr.toString(true)+": "+this.ptr.keyType);
                    this.ptr.keyType = ProtoBuf.TYPES[this.ptr.keyType];                                               // 4776
                }                                                                                                      // 4777
                                                                                                                       // 4778
            } else if (this.ptr instanceof ProtoBuf.Reflect.Service.Method) {                                          // 4779
                                                                                                                       // 4780
                if (this.ptr instanceof ProtoBuf.Reflect.Service.RPCMethod) {                                          // 4781
                    res = this.ptr.parent.resolve(this.ptr.requestName, true);                                         // 4782
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))                                            // 4783
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.requestName);   // 4784
                    this.ptr.resolvedRequestType = res;                                                                // 4785
                    res = this.ptr.parent.resolve(this.ptr.responseName, true);                                        // 4786
                    if (!res || !(res instanceof ProtoBuf.Reflect.Message))                                            // 4787
                        throw Error("Illegal type reference in "+this.ptr.toString(true)+": "+this.ptr.responseName);  // 4788
                    this.ptr.resolvedResponseType = res;                                                               // 4789
                } else // Should not happen as nothing else is implemented                                             // 4790
                    throw Error("illegal service type in "+this.ptr.toString(true));                                   // 4791
                                                                                                                       // 4792
            } else if (                                                                                                // 4793
                !(this.ptr instanceof ProtoBuf.Reflect.Message.OneOf) && // Not built                                  // 4794
                !(this.ptr instanceof ProtoBuf.Reflect.Extension) && // Not built                                      // 4795
                !(this.ptr instanceof ProtoBuf.Reflect.Enum.Value) // Built in enum                                    // 4796
            )                                                                                                          // 4797
                throw Error("illegal object in namespace: "+typeof(this.ptr)+": "+this.ptr);                           // 4798
                                                                                                                       // 4799
            return this.reset();                                                                                       // 4800
        };                                                                                                             // 4801
                                                                                                                       // 4802
        /**                                                                                                            // 4803
         * Builds the protocol. This will first try to resolve all definitions and, if this has been successful,       // 4804
         * return the built package.                                                                                   // 4805
         * @param {(string|Array.<string>)=} path Specifies what to return. If omitted, the entire namespace will be returned.
         * @returns {!ProtoBuf.Builder.Message|!Object.<string,*>}                                                     // 4807
         * @throws {Error} If a type could not be resolved                                                             // 4808
         * @expose                                                                                                     // 4809
         */                                                                                                            // 4810
        BuilderPrototype.build = function(path) {                                                                      // 4811
            this.reset();                                                                                              // 4812
            if (!this.resolved)                                                                                        // 4813
                this.resolveAll(),                                                                                     // 4814
                this.resolved = true,                                                                                  // 4815
                this.result = null; // Require re-build                                                                // 4816
            if (this.result === null) // (Re-)Build                                                                    // 4817
                this.result = this.ns.build();                                                                         // 4818
            if (!path)                                                                                                 // 4819
                return this.result;                                                                                    // 4820
            var part = typeof path === 'string' ? path.split(".") : path,                                              // 4821
                ptr = this.result; // Build namespace pointer (no hasChild etc.)                                       // 4822
            for (var i=0; i<part.length; i++)                                                                          // 4823
                if (ptr[part[i]])                                                                                      // 4824
                    ptr = ptr[part[i]];                                                                                // 4825
                else {                                                                                                 // 4826
                    ptr = null;                                                                                        // 4827
                    break;                                                                                             // 4828
                }                                                                                                      // 4829
            return ptr;                                                                                                // 4830
        };                                                                                                             // 4831
                                                                                                                       // 4832
        /**                                                                                                            // 4833
         * Similar to {@link ProtoBuf.Builder#build}, but looks up the internal reflection descriptor.                 // 4834
         * @param {string=} path Specifies what to return. If omitted, the entire namespace wiil be returned.          // 4835
         * @param {boolean=} excludeNonNamespace Excludes non-namespace types like fields, defaults to `false`         // 4836
         * @returns {?ProtoBuf.Reflect.T} Reflection descriptor or `null` if not found                                 // 4837
         */                                                                                                            // 4838
        BuilderPrototype.lookup = function(path, excludeNonNamespace) {                                                // 4839
            return path ? this.ns.resolve(path, excludeNonNamespace) : this.ns;                                        // 4840
        };                                                                                                             // 4841
                                                                                                                       // 4842
        /**                                                                                                            // 4843
         * Returns a string representation of this object.                                                             // 4844
         * @return {string} String representation as of "Builder"                                                      // 4845
         * @expose                                                                                                     // 4846
         */                                                                                                            // 4847
        BuilderPrototype.toString = function() {                                                                       // 4848
            return "Builder";                                                                                          // 4849
        };                                                                                                             // 4850
                                                                                                                       // 4851
        // ----- Base classes -----                                                                                    // 4852
        // Exist for the sole purpose of being able to "... instanceof ProtoBuf.Builder.Message" etc.                  // 4853
                                                                                                                       // 4854
        /**                                                                                                            // 4855
         * @alias ProtoBuf.Builder.Message                                                                             // 4856
         */                                                                                                            // 4857
        Builder.Message = function() {};                                                                               // 4858
                                                                                                                       // 4859
        /**                                                                                                            // 4860
         * @alias ProtoBuf.Builder.Enum                                                                                // 4861
         */                                                                                                            // 4862
        Builder.Enum = function() {};                                                                                  // 4863
                                                                                                                       // 4864
        /**                                                                                                            // 4865
         * @alias ProtoBuf.Builder.Message                                                                             // 4866
         */                                                                                                            // 4867
        Builder.Service = function() {};                                                                               // 4868
                                                                                                                       // 4869
        return Builder;                                                                                                // 4870
                                                                                                                       // 4871
    })(ProtoBuf, ProtoBuf.Lang, ProtoBuf.Reflect);                                                                     // 4872
                                                                                                                       // 4873
    /**                                                                                                                // 4874
     * @alias ProtoBuf.Map                                                                                             // 4875
     * @expose                                                                                                         // 4876
     */                                                                                                                // 4877
    ProtoBuf.Map = (function(ProtoBuf, Reflect) {                                                                      // 4878
        "use strict";                                                                                                  // 4879
                                                                                                                       // 4880
        /**                                                                                                            // 4881
         * Constructs a new Map. A Map is a container that is used to implement map                                    // 4882
         * fields on message objects. It closely follows the ES6 Map API; however,                                     // 4883
         * it is distinct because we do not want to depend on external polyfills or                                    // 4884
         * on ES6 itself.                                                                                              // 4885
         *                                                                                                             // 4886
         * @exports ProtoBuf.Map                                                                                       // 4887
         * @param {!ProtoBuf.Reflect.Field} field Map field                                                            // 4888
         * @param {Object.<string,*>=} contents Initial contents                                                       // 4889
         * @constructor                                                                                                // 4890
         */                                                                                                            // 4891
        var Map = function(field, contents) {                                                                          // 4892
            if (!field.map)                                                                                            // 4893
                throw Error("field is not a map");                                                                     // 4894
                                                                                                                       // 4895
            /**                                                                                                        // 4896
             * The field corresponding to this map.                                                                    // 4897
             * @type {!ProtoBuf.Reflect.Field}                                                                         // 4898
             */                                                                                                        // 4899
            this.field = field;                                                                                        // 4900
                                                                                                                       // 4901
            /**                                                                                                        // 4902
             * Element instance corresponding to key type.                                                             // 4903
             * @type {!ProtoBuf.Reflect.Element}                                                                       // 4904
             */                                                                                                        // 4905
            this.keyElem = new Reflect.Element(field.keyType, null, true, field.syntax);                               // 4906
                                                                                                                       // 4907
            /**                                                                                                        // 4908
             * Element instance corresponding to value type.                                                           // 4909
             * @type {!ProtoBuf.Reflect.Element}                                                                       // 4910
             */                                                                                                        // 4911
            this.valueElem = new Reflect.Element(field.type, field.resolvedType, false, field.syntax);                 // 4912
                                                                                                                       // 4913
            /**                                                                                                        // 4914
             * Internal map: stores mapping of (string form of key) -> (key, value)                                    // 4915
             * pair.                                                                                                   // 4916
             *                                                                                                         // 4917
             * We provide map semantics for arbitrary key types, but we build on top                                   // 4918
             * of an Object, which has only string keys. In order to avoid the need                                    // 4919
             * to convert a string key back to its native type in many situations,                                     // 4920
             * we store the native key value alongside the value. Thus, we only need                                   // 4921
             * a one-way mapping from a key type to its string form that guarantees                                    // 4922
             * uniqueness and equality (i.e., str(K1) === str(K2) if and only if K1                                    // 4923
             * === K2).                                                                                                // 4924
             *                                                                                                         // 4925
             * @type {!Object<string, {key: *, value: *}>}                                                             // 4926
             */                                                                                                        // 4927
            this.map = {};                                                                                             // 4928
                                                                                                                       // 4929
            /**                                                                                                        // 4930
             * Returns the number of elements in the map.                                                              // 4931
             */                                                                                                        // 4932
            Object.defineProperty(this, "size", {                                                                      // 4933
                get: function() { return Object.keys(this.map).length; }                                               // 4934
            });                                                                                                        // 4935
                                                                                                                       // 4936
            // Fill initial contents from a raw object.                                                                // 4937
            if (contents) {                                                                                            // 4938
                var keys = Object.keys(contents);                                                                      // 4939
                for (var i = 0; i < keys.length; i++) {                                                                // 4940
                    var key = this.keyElem.valueFromString(keys[i]);                                                   // 4941
                    var val = this.valueElem.verifyValue(contents[keys[i]]);                                           // 4942
                    this.map[this.keyElem.valueToString(key)] =                                                        // 4943
                        { key: key, value: val };                                                                      // 4944
                }                                                                                                      // 4945
            }                                                                                                          // 4946
        };                                                                                                             // 4947
                                                                                                                       // 4948
        var MapPrototype = Map.prototype;                                                                              // 4949
                                                                                                                       // 4950
        /**                                                                                                            // 4951
         * Helper: return an iterator over an array.                                                                   // 4952
         * @param {!Array<*>} arr the array                                                                            // 4953
         * @returns {!Object} an iterator                                                                              // 4954
         * @inner                                                                                                      // 4955
         */                                                                                                            // 4956
        function arrayIterator(arr) {                                                                                  // 4957
            var idx = 0;                                                                                               // 4958
            return {                                                                                                   // 4959
                next: function() {                                                                                     // 4960
                    if (idx < arr.length)                                                                              // 4961
                        return { done: false, value: arr[idx++] };                                                     // 4962
                    return { done: true };                                                                             // 4963
                }                                                                                                      // 4964
            }                                                                                                          // 4965
        }                                                                                                              // 4966
                                                                                                                       // 4967
        /**                                                                                                            // 4968
         * Clears the map.                                                                                             // 4969
         */                                                                                                            // 4970
        MapPrototype.clear = function() {                                                                              // 4971
            this.map = {};                                                                                             // 4972
        };                                                                                                             // 4973
                                                                                                                       // 4974
        /**                                                                                                            // 4975
         * Deletes a particular key from the map.                                                                      // 4976
         * @returns {boolean} Whether any entry with this key was deleted.                                             // 4977
         */                                                                                                            // 4978
        MapPrototype["delete"] = function(key) {                                                                       // 4979
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));                                  // 4980
            var hadKey = keyValue in this.map;                                                                         // 4981
            delete this.map[keyValue];                                                                                 // 4982
            return hadKey;                                                                                             // 4983
        };                                                                                                             // 4984
                                                                                                                       // 4985
        /**                                                                                                            // 4986
         * Returns an iterator over [key, value] pairs in the map.                                                     // 4987
         * @returns {Object} The iterator                                                                              // 4988
         */                                                                                                            // 4989
        MapPrototype.entries = function() {                                                                            // 4990
            var entries = [];                                                                                          // 4991
            var strKeys = Object.keys(this.map);                                                                       // 4992
            for (var i = 0, entry; i < strKeys.length; i++)                                                            // 4993
                entries.push([(entry=this.map[strKeys[i]]).key, entry.value]);                                         // 4994
            return arrayIterator(entries);                                                                             // 4995
        };                                                                                                             // 4996
                                                                                                                       // 4997
        /**                                                                                                            // 4998
         * Returns an iterator over keys in the map.                                                                   // 4999
         * @returns {Object} The iterator                                                                              // 5000
         */                                                                                                            // 5001
        MapPrototype.keys = function() {                                                                               // 5002
            var keys = [];                                                                                             // 5003
            var strKeys = Object.keys(this.map);                                                                       // 5004
            for (var i = 0; i < strKeys.length; i++)                                                                   // 5005
                keys.push(this.map[strKeys[i]].key);                                                                   // 5006
            return arrayIterator(keys);                                                                                // 5007
        };                                                                                                             // 5008
                                                                                                                       // 5009
        /**                                                                                                            // 5010
         * Returns an iterator over values in the map.                                                                 // 5011
         * @returns {!Object} The iterator                                                                             // 5012
         */                                                                                                            // 5013
        MapPrototype.values = function() {                                                                             // 5014
            var values = [];                                                                                           // 5015
            var strKeys = Object.keys(this.map);                                                                       // 5016
            for (var i = 0; i < strKeys.length; i++)                                                                   // 5017
                values.push(this.map[strKeys[i]].value);                                                               // 5018
            return arrayIterator(values);                                                                              // 5019
        };                                                                                                             // 5020
                                                                                                                       // 5021
        /**                                                                                                            // 5022
         * Iterates over entries in the map, calling a function on each.                                               // 5023
         * @param {function(this:*, *, *, *)} cb The callback to invoke with value, key, and map arguments.            // 5024
         * @param {Object=} thisArg The `this` value for the callback                                                  // 5025
         */                                                                                                            // 5026
        MapPrototype.forEach = function(cb, thisArg) {                                                                 // 5027
            var strKeys = Object.keys(this.map);                                                                       // 5028
            for (var i = 0, entry; i < strKeys.length; i++)                                                            // 5029
                cb.call(thisArg, (entry=this.map[strKeys[i]]).value, entry.key, this);                                 // 5030
        };                                                                                                             // 5031
                                                                                                                       // 5032
        /**                                                                                                            // 5033
         * Sets a key in the map to the given value.                                                                   // 5034
         * @param {*} key The key                                                                                      // 5035
         * @param {*} value The value                                                                                  // 5036
         * @returns {!ProtoBuf.Map} The map instance                                                                   // 5037
         */                                                                                                            // 5038
        MapPrototype.set = function(key, value) {                                                                      // 5039
            var keyValue = this.keyElem.verifyValue(key);                                                              // 5040
            var valValue = this.valueElem.verifyValue(value);                                                          // 5041
            this.map[this.keyElem.valueToString(keyValue)] =                                                           // 5042
                { key: keyValue, value: valValue };                                                                    // 5043
            return this;                                                                                               // 5044
        };                                                                                                             // 5045
                                                                                                                       // 5046
        /**                                                                                                            // 5047
         * Gets the value corresponding to a key in the map.                                                           // 5048
         * @param {*} key The key                                                                                      // 5049
         * @returns {*|undefined} The value, or `undefined` if key not present                                         // 5050
         */                                                                                                            // 5051
        MapPrototype.get = function(key) {                                                                             // 5052
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));                                  // 5053
            if (!(keyValue in this.map))                                                                               // 5054
                return undefined;                                                                                      // 5055
            return this.map[keyValue].value;                                                                           // 5056
        };                                                                                                             // 5057
                                                                                                                       // 5058
        /**                                                                                                            // 5059
         * Determines whether the given key is present in the map.                                                     // 5060
         * @param {*} key The key                                                                                      // 5061
         * @returns {boolean} `true` if the key is present                                                             // 5062
         */                                                                                                            // 5063
        MapPrototype.has = function(key) {                                                                             // 5064
            var keyValue = this.keyElem.valueToString(this.keyElem.verifyValue(key));                                  // 5065
            return (keyValue in this.map);                                                                             // 5066
        };                                                                                                             // 5067
                                                                                                                       // 5068
        return Map;                                                                                                    // 5069
    })(ProtoBuf, ProtoBuf.Reflect);                                                                                    // 5070
                                                                                                                       // 5071
                                                                                                                       // 5072
    /**                                                                                                                // 5073
     * Loads a .proto string and returns the Builder.                                                                  // 5074
     * @param {string} proto .proto file contents                                                                      // 5075
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages                                                       // 5078
     * @throws {Error} If the definition cannot be parsed or built                                                     // 5079
     * @expose                                                                                                         // 5080
     */                                                                                                                // 5081
    ProtoBuf.loadProto = function(proto, builder, filename) {                                                          // 5082
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,                                                                                        // 5084
            builder = undefined;                                                                                       // 5085
        return ProtoBuf.loadJson(ProtoBuf.DotProto.Parser.parse(proto), builder, filename);                            // 5086
    };                                                                                                                 // 5087
                                                                                                                       // 5088
    /**                                                                                                                // 5089
     * Loads a .proto string and returns the Builder. This is an alias of {@link ProtoBuf.loadProto}.                  // 5090
     * @function                                                                                                       // 5091
     * @param {string} proto .proto file contents                                                                      // 5092
     * @param {(ProtoBuf.Builder|string)=} builder Builder to append to. Will create a new one if omitted.             // 5093
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages                                                       // 5095
     * @throws {Error} If the definition cannot be parsed or built                                                     // 5096
     * @expose                                                                                                         // 5097
     */                                                                                                                // 5098
    ProtoBuf.protoFromString = ProtoBuf.loadProto; // Legacy                                                           // 5099
                                                                                                                       // 5100
    /**                                                                                                                // 5101
     * Loads a .proto file and returns the Builder.                                                                    // 5102
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with    // 5103
     *  an overridden 'root' path for all imported files.                                                              // 5104
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and      // 5105
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the      // 5106
     *  file will be read synchronously and this function will return the Builder.                                     // 5107
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.                      // 5108
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the    // 5109
     *   request has failed), else undefined                                                                           // 5110
     * @expose                                                                                                         // 5111
     */                                                                                                                // 5112
    ProtoBuf.loadProtoFile = function(filename, callback, builder) {                                                   // 5113
        if (callback && typeof callback === 'object')                                                                  // 5114
            builder = callback,                                                                                        // 5115
            callback = null;                                                                                           // 5116
        else if (!callback || typeof callback !== 'function')                                                          // 5117
            callback = null;                                                                                           // 5118
        if (callback)                                                                                                  // 5119
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {                                                                               // 5121
                    callback(Error("Failed to fetch file"));                                                           // 5122
                    return;                                                                                            // 5123
                }                                                                                                      // 5124
                try {                                                                                                  // 5125
                    callback(null, ProtoBuf.loadProto(contents, builder, filename));                                   // 5126
                } catch (e) {                                                                                          // 5127
                    callback(e);                                                                                       // 5128
                }                                                                                                      // 5129
            });                                                                                                        // 5130
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadProto(contents, builder, filename);                             // 5132
    };                                                                                                                 // 5133
                                                                                                                       // 5134
    /**                                                                                                                // 5135
     * Loads a .proto file and returns the Builder. This is an alias of {@link ProtoBuf.loadProtoFile}.                // 5136
     * @function                                                                                                       // 5137
     * @param {string|{root: string, file: string}} filename Path to proto file or an object specifying 'file' with    // 5138
     *  an overridden 'root' path for all imported files.                                                              // 5139
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and      // 5140
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the      // 5141
     *  file will be read synchronously and this function will return the Builder.                                     // 5142
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.                      // 5143
     * @return {!ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the    // 5144
     *   request has failed), else undefined                                                                           // 5145
     * @expose                                                                                                         // 5146
     */                                                                                                                // 5147
    ProtoBuf.protoFromFile = ProtoBuf.loadProtoFile; // Legacy                                                         // 5148
                                                                                                                       // 5149
                                                                                                                       // 5150
    /**                                                                                                                // 5151
     * Constructs a new empty Builder.                                                                                 // 5152
     * @param {Object.<string,*>=} options Builder options, defaults to global options set on ProtoBuf                 // 5153
     * @return {!ProtoBuf.Builder} Builder                                                                             // 5154
     * @expose                                                                                                         // 5155
     */                                                                                                                // 5156
    ProtoBuf.newBuilder = function(options) {                                                                          // 5157
        options = options || {};                                                                                       // 5158
        if (typeof options['convertFieldsToCamelCase'] === 'undefined')                                                // 5159
            options['convertFieldsToCamelCase'] = ProtoBuf.convertFieldsToCamelCase;                                   // 5160
        if (typeof options['populateAccessors'] === 'undefined')                                                       // 5161
            options['populateAccessors'] = ProtoBuf.populateAccessors;                                                 // 5162
        return new ProtoBuf.Builder(options);                                                                          // 5163
    };                                                                                                                 // 5164
                                                                                                                       // 5165
    /**                                                                                                                // 5166
     * Loads a .json definition and returns the Builder.                                                               // 5167
     * @param {!*|string} json JSON definition                                                                         // 5168
     * @param {(ProtoBuf.Builder|string|{root: string, file: string})=} builder Builder to append to. Will create a new one if omitted.
     * @param {(string|{root: string, file: string})=} filename The corresponding file name if known. Must be specified for imports.
     * @return {ProtoBuf.Builder} Builder to create new messages                                                       // 5171
     * @throws {Error} If the definition cannot be parsed or built                                                     // 5172
     * @expose                                                                                                         // 5173
     */                                                                                                                // 5174
    ProtoBuf.loadJson = function(json, builder, filename) {                                                            // 5175
        if (typeof builder === 'string' || (builder && typeof builder["file"] === 'string' && typeof builder["root"] === 'string'))
            filename = builder,                                                                                        // 5177
            builder = null;                                                                                            // 5178
        if (!builder || typeof builder !== 'object')                                                                   // 5179
            builder = ProtoBuf.newBuilder();                                                                           // 5180
        if (typeof json === 'string')                                                                                  // 5181
            json = JSON.parse(json);                                                                                   // 5182
        builder["import"](json, filename);                                                                             // 5183
        builder.resolveAll();                                                                                          // 5184
        return builder;                                                                                                // 5185
    };                                                                                                                 // 5186
                                                                                                                       // 5187
    /**                                                                                                                // 5188
     * Loads a .json file and returns the Builder.                                                                     // 5189
     * @param {string|!{root: string, file: string}} filename Path to json file or an object specifying 'file' with    // 5190
     *  an overridden 'root' path for all imported files.                                                              // 5191
     * @param {function(?Error, !ProtoBuf.Builder=)=} callback Callback that will receive `null` as the first and      // 5192
     *  the Builder as its second argument on success, otherwise the error as its first argument. If omitted, the      // 5193
     *  file will be read synchronously and this function will return the Builder.                                     // 5194
     * @param {ProtoBuf.Builder=} builder Builder to append to. Will create a new one if omitted.                      // 5195
     * @return {?ProtoBuf.Builder|undefined} The Builder if synchronous (no callback specified, will be NULL if the    // 5196
     *   request has failed), else undefined                                                                           // 5197
     * @expose                                                                                                         // 5198
     */                                                                                                                // 5199
    ProtoBuf.loadJsonFile = function(filename, callback, builder) {                                                    // 5200
        if (callback && typeof callback === 'object')                                                                  // 5201
            builder = callback,                                                                                        // 5202
            callback = null;                                                                                           // 5203
        else if (!callback || typeof callback !== 'function')                                                          // 5204
            callback = null;                                                                                           // 5205
        if (callback)                                                                                                  // 5206
            return ProtoBuf.Util.fetch(typeof filename === 'string' ? filename : filename["root"]+"/"+filename["file"], function(contents) {
                if (contents === null) {                                                                               // 5208
                    callback(Error("Failed to fetch file"));                                                           // 5209
                    return;                                                                                            // 5210
                }                                                                                                      // 5211
                try {                                                                                                  // 5212
                    callback(null, ProtoBuf.loadJson(JSON.parse(contents), builder, filename));                        // 5213
                } catch (e) {                                                                                          // 5214
                    callback(e);                                                                                       // 5215
                }                                                                                                      // 5216
            });                                                                                                        // 5217
        var contents = ProtoBuf.Util.fetch(typeof filename === 'object' ? filename["root"]+"/"+filename["file"] : filename);
        return contents === null ? null : ProtoBuf.loadJson(JSON.parse(contents), builder, filename);                  // 5219
    };                                                                                                                 // 5220
                                                                                                                       // 5221
//     return ProtoBuf;                                                                                                // 5222
// });                                                                                                                 // 5223
                                                                                                                       // 5224
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/json_proto.js                                                                                   //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
var protoString = "package js;" +                                                                                      // 1
"message Value {" +                                                                                                    // 2
"oneof type {" +                                                                                                       // 3
"sint32 integer = 1;" +                                                                                                // 4
"double double = 2;" +                                                                                                 // 5
"string string = 3;" +                                                                                                 // 6
"bool boolean = 4;" +                                                                                                  // 7
"bool null = 5;" +                                                                                                     // 8
"Array array = 6;" +                                                                                                   // 9
"Object object = 7;" +                                                                                                 // 10
"}" +                                                                                                                  // 11
"}" +                                                                                                                  // 12
"message Array {" +                                                                                                    // 13
"repeated Value values = 1;" +                                                                                         // 14
"}" +                                                                                                                  // 15
"message Object {" +                                                                                                   // 16
"repeated Value keys = 1;" +                                                                                           // 17
"repeated Value values = 2;" +                                                                                         // 18
"}";                                                                                                                   // 19
                                                                                                                       // 20
// Option 1: Loading the .proto file directly                                                                          // 21
var builder = ProtoBuf.loadProto(protoString),    // Creates the Builder                                               // 22
    JS = builder.build("js");                            // Returns just the 'js' namespace if that's all we need      // 23
                                                                                                                       // 24
/**                                                                                                                    // 25
 * Converts a JSON-like structure to JS-Namespace values.                                                              // 26
 * @param {*} val JSON                                                                                                 // 27
 * @returns {!JS.Value} JS-Namespace value                                                                             // 28
 * @inner                                                                                                              // 29
 */                                                                                                                    // 30
function _protoify(val) {                                                                                              // 31
    switch (typeof val) {                                                                                              // 32
        case 'number':                                                                                                 // 33
            if (val%1 === 0 && val >= (0x80000000|0) && val <= (0x7fffffff|0))                                         // 34
                return new JS.Value(val); // sets the first field declared in .js.Value                                // 35
            else                                                                                                       // 36
                return new JS.Value(null, val); // sets the second field                                               // 37
        case 'string':                                                                                                 // 38
            return new JS.Value({ 'string': val }); // uses object notation instead                                    // 39
        case 'boolean':                                                                                                // 40
            return new JS.Value({ 'boolean': val });                                                                   // 41
        case 'object':                                                                                                 // 42
            if (val === null)                                                                                          // 43
                return new JS.Value({ 'null': true });                                                                 // 44
            if (Object.prototype.toString.call(val) === "[object Array]") {                                            // 45
                var arr = new JS.Array();                                                                              // 46
                for (var i=0; i<val.length; ++i)                                                                       // 47
                    arr['values'][i] = _protoify(val[i]);                                                              // 48
                return new JS.Value({ 'array': arr });                                                                 // 49
            }                                                                                                          // 50
            var obj = new JS.Object();                                                                                 // 51
            for (var key in val)                                                                                       // 52
                if (val.hasOwnProperty(key))                                                                           // 53
                    obj['keys'].push(_protoify(key)),                                                                  // 54
                        obj['values'].push(_protoify(val[key]));                                                       // 55
            return new JS.Value({ 'object': obj });                                                                    // 56
        case 'undefined':                                                                                              // 57
            return new JS.Value(); // undefined                                                                        // 58
        default:                                                                                                       // 59
            throw Error("Unsupported type: "+(typeof val)); // symbol, function                                        // 60
    }                                                                                                                  // 61
}                                                                                                                      // 62
                                                                                                                       // 63
/**                                                                                                                    // 64
 * Converts JS-Namespace values to JSON.                                                                               // 65
 * @param {!JS.Value} value JS value                                                                                   // 66
 * @returns {*} JSON                                                                                                   // 67
 * @inner                                                                                                              // 68
 */                                                                                                                    // 69
function _jsonify(value) {                                                                                             // 70
    if (value.type === null)                                                                                           // 71
        return undefined;                                                                                              // 72
    switch (value.type) {                                                                                              // 73
        case 'null':                                                                                                   // 74
            return null;                                                                                               // 75
        case 'array':                                                                                                  // 76
            return (function() {                                                                                       // 77
                var values = value['array']['values'],                                                                 // 78
                    i = 0,                                                                                             // 79
                    k = values.length,                                                                                 // 80
                    arr = new Array(k);                                                                                // 81
                for (; i<k; ++i)                                                                                       // 82
                    arr[i] = _jsonify(values[i]);                                                                      // 83
                return arr;                                                                                            // 84
            })();                                                                                                      // 85
        case 'object':                                                                                                 // 86
            return (function() {                                                                                       // 87
                var keys = value['object']['keys'],                                                                    // 88
                    values = value['object']['values'],                                                                // 89
                    i = 0,                                                                                             // 90
                    k = keys.length,                                                                                   // 91
                    obj = {};                                                                                          // 92
                for (; i<k; ++i)                                                                                       // 93
                    obj[keys[i]['string'] /* is a JS.Value, here always a string */] = _jsonify(values[i]);            // 94
                return obj;                                                                                            // 95
            })();                                                                                                      // 96
        default:                                                                                                       // 97
            return value[value.type];                                                                                  // 98
    }                                                                                                                  // 99
}                                                                                                                      // 100
                                                                                                                       // 101
// And this is how we actually encode and decode them:                                                                 // 102
                                                                                                                       // 103
/**                                                                                                                    // 104
 * A temporary Buffer to speed up encoding.                                                                            // 105
 * @type {!ByteBuffer}                                                                                                 // 106
 * @inner                                                                                                              // 107
 */                                                                                                                    // 108
var tempBuffer = ByteBuffer.allocate(1024);                                                                            // 109
                                                                                                                       // 110
/**                                                                                                                    // 111
 * Converts a JSON structure to a Buffer.                                                                              // 112
 * @param {*} json JSON                                                                                                // 113
 * @returns {!Buffer|!ArrayBuffer}                                                                                     // 114
 * @expose                                                                                                             // 115
 */                                                                                                                    // 116
JSONproto.protoify = function(json) {                                                                                  // 117
      return _protoify(json).encode64()                                                                                // 118
};                                                                                                                     // 119
                                                                                                                       // 120
/**                                                                                                                    // 121
 * Converts a Buffer to a JSON structure.                                                                              // 122
 * @param {!Buffer|!ArrayBuffer} proto Buffer                                                                          // 123
 * @returns {*} JSON                                                                                                   // 124
 * @expose                                                                                                             // 125
 */                                                                                                                    // 126
JSONproto.parse = function(proto) {                                                                                    // 127
    return _jsonify(           // Processes JS-namespace objects                                                       // 128
        JS.Value.decode64(proto) // Decodes the JS.Value from a ByteBuffer, a Buffer, an ArrayBuffer, an Uint8Array, ...
    );                                                                                                                 // 130
};                                                                                                                     // 131
                                                                                                                       // 132
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/heartbeat.js                                                                                    //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Heartbeat options:                                                                                                  // 1
//   heartbeatInterval: interval to send pings, in milliseconds.                                                       // 2
//   heartbeatTimeout: timeout to close the connection if a reply isn't                                                // 3
//     received, in milliseconds.                                                                                      // 4
//   sendPing: function to call to send a ping on the connection.                                                      // 5
//   onTimeout: function to call to close the connection.                                                              // 6
                                                                                                                       // 7
DDPCommon.Heartbeat = function (options) {                                                                             // 8
  var self = this;                                                                                                     // 9
                                                                                                                       // 10
  self.heartbeatInterval = options.heartbeatInterval;                                                                  // 11
  self.heartbeatTimeout = options.heartbeatTimeout;                                                                    // 12
  self._sendPing = options.sendPing;                                                                                   // 13
  self._onTimeout = options.onTimeout;                                                                                 // 14
  self._seenPacket = false;                                                                                            // 15
                                                                                                                       // 16
  self._heartbeatIntervalHandle = null;                                                                                // 17
  self._heartbeatTimeoutHandle = null;                                                                                 // 18
};                                                                                                                     // 19
                                                                                                                       // 20
_.extend(DDPCommon.Heartbeat.prototype, {                                                                              // 21
  stop: function () {                                                                                                  // 22
    var self = this;                                                                                                   // 23
    self._clearHeartbeatIntervalTimer();                                                                               // 24
    self._clearHeartbeatTimeoutTimer();                                                                                // 25
  },                                                                                                                   // 26
                                                                                                                       // 27
  start: function () {                                                                                                 // 28
    var self = this;                                                                                                   // 29
    self.stop();                                                                                                       // 30
    self._startHeartbeatIntervalTimer();                                                                               // 31
  },                                                                                                                   // 32
                                                                                                                       // 33
  _startHeartbeatIntervalTimer: function () {                                                                          // 34
    var self = this;                                                                                                   // 35
    self._heartbeatIntervalHandle = Meteor.setInterval(                                                                // 36
      _.bind(self._heartbeatIntervalFired, self),                                                                      // 37
      self.heartbeatInterval                                                                                           // 38
    );                                                                                                                 // 39
  },                                                                                                                   // 40
                                                                                                                       // 41
  _startHeartbeatTimeoutTimer: function () {                                                                           // 42
    var self = this;                                                                                                   // 43
    self._heartbeatTimeoutHandle = Meteor.setTimeout(                                                                  // 44
      _.bind(self._heartbeatTimeoutFired, self),                                                                       // 45
      self.heartbeatTimeout                                                                                            // 46
    );                                                                                                                 // 47
  },                                                                                                                   // 48
                                                                                                                       // 49
  _clearHeartbeatIntervalTimer: function () {                                                                          // 50
    var self = this;                                                                                                   // 51
    if (self._heartbeatIntervalHandle) {                                                                               // 52
      Meteor.clearInterval(self._heartbeatIntervalHandle);                                                             // 53
      self._heartbeatIntervalHandle = null;                                                                            // 54
    }                                                                                                                  // 55
  },                                                                                                                   // 56
                                                                                                                       // 57
  _clearHeartbeatTimeoutTimer: function () {                                                                           // 58
    var self = this;                                                                                                   // 59
    if (self._heartbeatTimeoutHandle) {                                                                                // 60
      Meteor.clearTimeout(self._heartbeatTimeoutHandle);                                                               // 61
      self._heartbeatTimeoutHandle = null;                                                                             // 62
    }                                                                                                                  // 63
  },                                                                                                                   // 64
                                                                                                                       // 65
  // The heartbeat interval timer is fired when we should send a ping.                                                 // 66
  _heartbeatIntervalFired: function () {                                                                               // 67
    var self = this;                                                                                                   // 68
    // don't send ping if we've seen a packet since we last checked,                                                   // 69
    // *or* if we have already sent a ping and are awaiting a timeout.                                                 // 70
    // That shouldn't happen, but it's possible if                                                                     // 71
    // `self.heartbeatInterval` is smaller than                                                                        // 72
    // `self.heartbeatTimeout`.                                                                                        // 73
    if (! self._seenPacket && ! self._heartbeatTimeoutHandle) {                                                        // 74
      self._sendPing();                                                                                                // 75
      // Set up timeout, in case a pong doesn't arrive in time.                                                        // 76
      self._startHeartbeatTimeoutTimer();                                                                              // 77
    }                                                                                                                  // 78
    self._seenPacket = false;                                                                                          // 79
  },                                                                                                                   // 80
                                                                                                                       // 81
  // The heartbeat timeout timer is fired when we sent a ping, but we                                                  // 82
  // timed out waiting for the pong.                                                                                   // 83
  _heartbeatTimeoutFired: function () {                                                                                // 84
    var self = this;                                                                                                   // 85
    self._heartbeatTimeoutHandle = null;                                                                               // 86
    self._onTimeout();                                                                                                 // 87
  },                                                                                                                   // 88
                                                                                                                       // 89
  messageReceived: function () {                                                                                       // 90
    var self = this;                                                                                                   // 91
    // Tell periodic checkin that we have seen a packet, and thus it                                                   // 92
    // does not need to send a ping this cycle.                                                                        // 93
    self._seenPacket = true;                                                                                           // 94
    // If we were waiting for a pong, we got it.                                                                       // 95
    if (self._heartbeatTimeoutHandle) {                                                                                // 96
      self._clearHeartbeatTimeoutTimer();                                                                              // 97
    }                                                                                                                  // 98
  }                                                                                                                    // 99
});                                                                                                                    // 100
                                                                                                                       // 101
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/utils.js                                                                                        //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
                                                                                                                       // 1
DDPCommon.SUPPORTED_DDP_VERSIONS = [ '1', 'pre2', 'pre1' ];                                                            // 2
                                                                                                                       // 3
DDPCommon.parseDDP = function (stringMessage) {                                                                        // 4
  try {                                                                                                                // 5
    var msg = JSONproto.parse(stringMessage);                                                                          // 6
  } catch (e) {                                                                                                        // 7
    Meteor._debug("Discarding message with invalid JSON", stringMessage);                                              // 8
    return null;                                                                                                       // 9
  }                                                                                                                    // 10
  // DDP messages must be objects.                                                                                     // 11
  if (msg === null || typeof msg !== 'object') {                                                                       // 12
    Meteor._debug("Discarding non-object DDP message", stringMessage);                                                 // 13
    return null;                                                                                                       // 14
  }                                                                                                                    // 15
                                                                                                                       // 16
  // massage msg to get it into "abstract ddp" rather than "wire ddp" format.                                          // 17
                                                                                                                       // 18
  // switch between "cleared" rep of unsetting fields and "undefined"                                                  // 19
  // rep of same                                                                                                       // 20
  if (_.has(msg, 'cleared')) {                                                                                         // 21
    if (!_.has(msg, 'fields'))                                                                                         // 22
      msg.fields = {};                                                                                                 // 23
    _.each(msg.cleared, function (clearKey) {                                                                          // 24
      msg.fields[clearKey] = undefined;                                                                                // 25
    });                                                                                                                // 26
    delete msg.cleared;                                                                                                // 27
  }                                                                                                                    // 28
                                                                                                                       // 29
  _.each(['fields', 'params', 'result'], function (field) {                                                            // 30
    if (_.has(msg, field))                                                                                             // 31
      msg[field] = EJSON._adjustTypesFromJSONValue(msg[field]);                                                        // 32
  });                                                                                                                  // 33
                                                                                                                       // 34
  return msg;                                                                                                          // 35
};                                                                                                                     // 36
                                                                                                                       // 37
DDPCommon.stringifyDDP = function (msg) {                                                                              // 38
  var copy = EJSON.clone(msg);                                                                                         // 39
  // swizzle 'changed' messages from 'fields undefined' rep to 'fields                                                 // 40
  // and cleared' rep                                                                                                  // 41
  if (_.has(msg, 'fields')) {                                                                                          // 42
    var cleared = [];                                                                                                  // 43
    _.each(msg.fields, function (value, key) {                                                                         // 44
      if (value === undefined) {                                                                                       // 45
        cleared.push(key);                                                                                             // 46
        delete copy.fields[key];                                                                                       // 47
      }                                                                                                                // 48
    });                                                                                                                // 49
    if (!_.isEmpty(cleared))                                                                                           // 50
      copy.cleared = cleared;                                                                                          // 51
    if (_.isEmpty(copy.fields))                                                                                        // 52
      delete copy.fields;                                                                                              // 53
  }                                                                                                                    // 54
  // adjust types to basic                                                                                             // 55
  _.each(['fields', 'params', 'result'], function (field) {                                                            // 56
    if (_.has(copy, field))                                                                                            // 57
      copy[field] = EJSON._adjustTypesToJSONValue(copy[field]);                                                        // 58
  });                                                                                                                  // 59
  if (msg.id && typeof msg.id !== 'string') {                                                                          // 60
    throw new Error("Message id is not a string");                                                                     // 61
  }                                                                                                                    // 62
  return JSONproto.protoify(copy);                                                                                     // 63
};                                                                                                                     // 64
                                                                                                                       // 65
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/method_invocation.js                                                                            //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// Instance name is this because it is usually referred to as this inside a                                            // 1
// method definition                                                                                                   // 2
/**                                                                                                                    // 3
 * @summary The state for a single invocation of a method, referenced by this                                          // 4
 * inside a method definition.                                                                                         // 5
 * @param {Object} options                                                                                             // 6
 * @instanceName this                                                                                                  // 7
 */                                                                                                                    // 8
DDPCommon.MethodInvocation = function (options) {                                                                      // 9
  var self = this;                                                                                                     // 10
                                                                                                                       // 11
  // true if we're running not the actual method, but a stub (that is,                                                 // 12
  // if we're on a client (which may be a browser, or in the future a                                                  // 13
  // server connecting to another server) and presently running a                                                      // 14
  // simulation of a server-side method for latency compensation                                                       // 15
  // purposes). not currently true except in a client such as a browser,                                               // 16
  // since there's usually no point in running stubs unless you have a                                                 // 17
  // zero-latency connection to the user.                                                                              // 18
                                                                                                                       // 19
  /**                                                                                                                  // 20
   * @summary Access inside a method invocation.  Boolean value, true if this invocation is a stub.                    // 21
   * @locus Anywhere                                                                                                   // 22
   * @name  isSimulation                                                                                               // 23
   * @memberOf DDPCommon.MethodInvocation                                                                              // 24
   * @instance                                                                                                         // 25
   * @type {Boolean}                                                                                                   // 26
   */                                                                                                                  // 27
  this.isSimulation = options.isSimulation;                                                                            // 28
                                                                                                                       // 29
  // call this function to allow other method invocations (from the                                                    // 30
  // same client) to continue running without waiting for this one to                                                  // 31
  // complete.                                                                                                         // 32
  this._unblock = options.unblock || function () {};                                                                   // 33
  this._calledUnblock = false;                                                                                         // 34
                                                                                                                       // 35
  // current user id                                                                                                   // 36
                                                                                                                       // 37
  /**                                                                                                                  // 38
   * @summary The id of the user that made this method call, or `null` if no user was logged in.                       // 39
   * @locus Anywhere                                                                                                   // 40
   * @name  userId                                                                                                     // 41
   * @memberOf DDPCommon.MethodInvocation                                                                              // 42
   * @instance                                                                                                         // 43
   */                                                                                                                  // 44
  this.userId = options.userId;                                                                                        // 45
                                                                                                                       // 46
  // sets current user id in all appropriate server contexts and                                                       // 47
  // reruns subscriptions                                                                                              // 48
  this._setUserId = options.setUserId || function () {};                                                               // 49
                                                                                                                       // 50
  // On the server, the connection this method call came in on.                                                        // 51
                                                                                                                       // 52
  /**                                                                                                                  // 53
   * @summary Access inside a method invocation. The [connection](#meteor_onconnection) that this method was received on. `null` if the method is not associated with a connection, eg. a server initiated method call.
   * @locus Server                                                                                                     // 55
   * @name  connection                                                                                                 // 56
   * @memberOf DDPCommon.MethodInvocation                                                                              // 57
   * @instance                                                                                                         // 58
   */                                                                                                                  // 59
  this.connection = options.connection;                                                                                // 60
                                                                                                                       // 61
  // The seed for randomStream value generation                                                                        // 62
  this.randomSeed = options.randomSeed;                                                                                // 63
                                                                                                                       // 64
  // This is set by RandomStream.get; and holds the random stream state                                                // 65
  this.randomStream = null;                                                                                            // 66
};                                                                                                                     // 67
                                                                                                                       // 68
_.extend(DDPCommon.MethodInvocation.prototype, {                                                                       // 69
  /**                                                                                                                  // 70
   * @summary Call inside a method invocation.  Allow subsequent method from this client to begin running in a new fiber.
   * @locus Server                                                                                                     // 72
   * @memberOf DDPCommon.MethodInvocation                                                                              // 73
   * @instance                                                                                                         // 74
   */                                                                                                                  // 75
  unblock: function () {                                                                                               // 76
    var self = this;                                                                                                   // 77
    self._calledUnblock = true;                                                                                        // 78
    self._unblock();                                                                                                   // 79
  },                                                                                                                   // 80
                                                                                                                       // 81
  /**                                                                                                                  // 82
   * @summary Set the logged in user.                                                                                  // 83
   * @locus Server                                                                                                     // 84
   * @memberOf DDPCommon.MethodInvocation                                                                              // 85
   * @instance                                                                                                         // 86
   * @param {String | null} userId The value that should be returned by `userId` on this connection.                   // 87
   */                                                                                                                  // 88
  setUserId: function(userId) {                                                                                        // 89
    var self = this;                                                                                                   // 90
    if (self._calledUnblock)                                                                                           // 91
      throw new Error("Can't call setUserId in a method after calling unblock");                                       // 92
    self.userId = userId;                                                                                              // 93
    self._setUserId(userId);                                                                                           // 94
  }                                                                                                                    // 95
});                                                                                                                    // 96
                                                                                                                       // 97
                                                                                                                       // 98
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);






(function(){

/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                                                     //
// packages/ddp-common/random_stream.js                                                                                //
//                                                                                                                     //
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                                                                                                                       //
// RandomStream allows for generation of pseudo-random values, from a seed.                                            // 1
//                                                                                                                     // 2
// We use this for consistent 'random' numbers across the client and server.                                           // 3
// We want to generate probably-unique IDs on the client, and we ideally want                                          // 4
// the server to generate the same IDs when it executes the method.                                                    // 5
//                                                                                                                     // 6
// For generated values to be the same, we must seed ourselves the same way,                                           // 7
// and we must keep track of the current state of our pseudo-random generators.                                        // 8
// We call this state the scope. By default, we use the current DDP method                                             // 9
// invocation as our scope.  DDP now allows the client to specify a randomSeed.                                        // 10
// If a randomSeed is provided it will be used to seed our random sequences.                                           // 11
// In this way, client and server method calls will generate the same values.                                          // 12
//                                                                                                                     // 13
// We expose multiple named streams; each stream is independent                                                        // 14
// and is seeded differently (but predictably from the name).                                                          // 15
// By using multiple streams, we support reordering of requests,                                                       // 16
// as long as they occur on different streams.                                                                         // 17
//                                                                                                                     // 18
// @param options {Optional Object}                                                                                    // 19
//   seed: Array or value - Seed value(s) for the generator.                                                           // 20
//                          If an array, will be used as-is                                                            // 21
//                          If a value, will be converted to a single-value array                                      // 22
//                          If omitted, a random array will be used as the seed.                                       // 23
DDPCommon.RandomStream = function (options) {                                                                          // 24
  var self = this;                                                                                                     // 25
                                                                                                                       // 26
  this.seed = [].concat(options.seed || randomToken());                                                                // 27
                                                                                                                       // 28
  this.sequences = {};                                                                                                 // 29
};                                                                                                                     // 30
                                                                                                                       // 31
// Returns a random string of sufficient length for a random seed.                                                     // 32
// This is a placeholder function; a similar function is planned                                                       // 33
// for Random itself; when that is added we should remove this function,                                               // 34
// and call Random's randomToken instead.                                                                              // 35
function randomToken() {                                                                                               // 36
  return Random.hexString(20);                                                                                         // 37
};                                                                                                                     // 38
                                                                                                                       // 39
// Returns the random stream with the specified name, in the specified                                                 // 40
// scope. If a scope is passed, then we use that to seed a (not                                                        // 41
// cryptographically secure) PRNG using the fast Alea algorithm.  If                                                   // 42
// scope is null (or otherwise falsey) then we use a generated seed.                                                   // 43
//                                                                                                                     // 44
// However, scope will normally be the current DDP method invocation,                                                  // 45
// so we'll use the stream with the specified name, and we should get                                                  // 46
// consistent values on the client and server sides of a method call.                                                  // 47
DDPCommon.RandomStream.get = function (scope, name) {                                                                  // 48
  if (!name) {                                                                                                         // 49
    name = "default";                                                                                                  // 50
  }                                                                                                                    // 51
  if (!scope) {                                                                                                        // 52
    // There was no scope passed in; the sequence won't actually be                                                    // 53
    // reproducible. but make it fast (and not cryptographically                                                       // 54
    // secure) anyways, so that the behavior is similar to what you'd                                                  // 55
    // get by passing in a scope.                                                                                      // 56
    return Random.insecure;                                                                                            // 57
  }                                                                                                                    // 58
  var randomStream = scope.randomStream;                                                                               // 59
  if (!randomStream) {                                                                                                 // 60
    scope.randomStream = randomStream = new DDPCommon.RandomStream({                                                   // 61
      seed: scope.randomSeed                                                                                           // 62
    });                                                                                                                // 63
  }                                                                                                                    // 64
  return randomStream._sequence(name);                                                                                 // 65
};                                                                                                                     // 66
                                                                                                                       // 67
                                                                                                                       // 68
// Creates a randomSeed for passing to a method call.                                                                  // 69
// Note that we take enclosing as an argument,                                                                         // 70
// though we expect it to be DDP._CurrentInvocation.get()                                                              // 71
// However, we often evaluate makeRpcSeed lazily, and thus the relevant                                                // 72
// invocation may not be the one currently in scope.                                                                   // 73
// If enclosing is null, we'll use Random and values won't be repeatable.                                              // 74
DDPCommon.makeRpcSeed = function (enclosing, methodName) {                                                             // 75
  var stream = DDPCommon.RandomStream.get(enclosing, '/rpc/' + methodName);                                            // 76
  return stream.hexString(20);                                                                                         // 77
};                                                                                                                     // 78
                                                                                                                       // 79
_.extend(DDPCommon.RandomStream.prototype, {                                                                           // 80
  // Get a random sequence with the specified name, creating it if does not exist.                                     // 81
  // New sequences are seeded with the seed concatenated with the name.                                                // 82
  // By passing a seed into Random.create, we use the Alea generator.                                                  // 83
  _sequence: function (name) {                                                                                         // 84
    var self = this;                                                                                                   // 85
                                                                                                                       // 86
    var sequence = self.sequences[name] || null;                                                                       // 87
    if (sequence === null) {                                                                                           // 88
      var sequenceSeed = self.seed.concat(name);                                                                       // 89
      for (var i = 0; i < sequenceSeed.length; i++) {                                                                  // 90
        if (_.isFunction(sequenceSeed[i])) {                                                                           // 91
          sequenceSeed[i] = sequenceSeed[i]();                                                                         // 92
        }                                                                                                              // 93
      }                                                                                                                // 94
      self.sequences[name] = sequence = Random.createWithSeeds.apply(null, sequenceSeed);                              // 95
    }                                                                                                                  // 96
    return sequence;                                                                                                   // 97
  }                                                                                                                    // 98
});                                                                                                                    // 99
                                                                                                                       // 100
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

}).call(this);


/* Exports */
if (typeof Package === 'undefined') Package = {};
Package['ddp-common'] = {
  DDPCommon: DDPCommon
};

})();
